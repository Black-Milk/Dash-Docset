
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Weave (scipy.weave) &mdash; SciPy v0.13.0 Reference Guide</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/jquery-ui.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.13.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-ui.min.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="SciPy v0.13.0 Reference Guide" href="../index.html" />
    <link rel="up" title="SciPy Tutorial" href="index.html" />
    <link rel="next" title="Contributing to SciPy" href="../hacking.html" />
    <link rel="prev" title="File IO (scipy.io)" href="io.html" /> 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../index.html">SciPy v0.13.0 Reference Guide</a></li>
	
          <li class="active"><a href="index.html" accesskey="U">SciPy Tutorial</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="../hacking.html" title="Contributing to SciPy"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="io.html" title="File IO (scipy.io)"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/scipyshiny_small.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Weave (<tt class="docutils literal"><span class="pre">scipy.weave</span></tt>)</a><ul>
<li><a class="reference internal" href="#outline">Outline</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#testing">Testing</a><ul>
<li><a class="reference internal" href="#testing-notes">Testing Notes:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#benchmarks">Benchmarks</a></li>
<li><a class="reference internal" href="#inline">Inline</a><ul>
<li><a class="reference internal" href="#more-with-printf">More with printf</a></li>
<li><a class="reference internal" href="#more-examples">More examples</a><ul>
<li><a class="reference internal" href="#binary-search">Binary search</a></li>
<li><a class="reference internal" href="#dictionary-sort">Dictionary Sort</a></li>
<li><a class="reference internal" href="#numpy-cast-copy-transpose">NumPy &#8211; cast/copy/transpose</a></li>
<li><a class="reference internal" href="#wxpython">wxPython</a></li>
</ul>
</li>
<li><a class="reference internal" href="#keyword-option">Keyword Option</a></li>
<li><a class="reference internal" href="#inline-arguments">Inline Arguments</a></li>
<li><a class="reference internal" href="#distutils-keywords">Distutils keywords</a><ul>
<li><a class="reference internal" href="#keyword-option-examples">Keyword Option Examples</a></li>
<li><a class="reference internal" href="#returning-values">Returning Values</a><ul>
<li><a class="reference internal" href="#the-issue-with-locals">The issue with <tt class="docutils literal"><span class="pre">locals()</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-quick-look-at-the-code">A quick look at the code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#technical-details">Technical Details</a></li>
<li><a class="reference internal" href="#passing-variables-in-out-of-the-c-c-code">Passing Variables in/out of the C/C++ code</a></li>
<li><a class="reference internal" href="#type-conversions">Type Conversions</a><ul>
<li><a class="reference internal" href="#numpy-argument-conversion">NumPy Argument Conversion</a></li>
<li><a class="reference internal" href="#string-list-tuple-and-dictionary-conversion">String, List, Tuple, and Dictionary Conversion</a></li>
<li><a class="reference internal" href="#file-conversion">File Conversion</a></li>
<li><a class="reference internal" href="#callable-instance-and-module-conversion">Callable, Instance, and Module Conversion</a></li>
<li><a class="reference internal" href="#customizing-conversions">Customizing Conversions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-catalog">The Catalog</a><ul>
<li><a class="reference internal" href="#function-storage">Function Storage</a></li>
<li><a class="reference internal" href="#catalog-search-paths-and-the-pythoncompiled-variable">Catalog search paths and the PYTHONCOMPILED variable</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#blitz">Blitz</a><ul>
<li><a class="reference internal" href="#id1">Requirements</a></li>
<li><a class="reference internal" href="#limitations">Limitations</a></li>
<li><a class="reference internal" href="#numpy-efficiency-issues-what-compilation-buys-you">NumPy efficiency issues: What compilation buys you</a></li>
<li><a class="reference internal" href="#the-tools">The Tools</a><ul>
<li><a class="reference internal" href="#parser">Parser</a></li>
<li><a class="reference internal" href="#blitz-and-numpy">Blitz and NumPy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-definitions-and-coersion">Type definitions and coersion</a></li>
<li><a class="reference internal" href="#cataloging-compiled-functions">Cataloging Compiled Functions</a></li>
<li><a class="reference internal" href="#checking-array-sizes">Checking Array Sizes</a></li>
<li><a class="reference internal" href="#creating-the-extension-module">Creating the Extension Module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extension-modules">Extension Modules</a><ul>
<li><a class="reference internal" href="#a-simple-example">A Simple Example</a></li>
<li><a class="reference internal" href="#fibonacci-example">Fibonacci Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-type-conversions-type-factories">Customizing Type Conversions &#8211; Type Factories</a></li>
<li><a class="reference internal" href="#things-i-wish-weave-did">Things I wish <tt class="docutils literal"><span class="pre">weave</span></tt> did</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="io.html"
                        title="previous chapter">File IO (<tt class="docutils literal"><span class="pre">scipy.io</span></tt>)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../hacking.html"
                        title="next chapter">Contributing to SciPy</a></p>


        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="weave-scipy-weave">
<h1><a class="toc-backref" href="#id3">Weave (<a class="reference internal" href="../weave.html#module-scipy.weave" title="scipy.weave"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.weave</span></tt></a>)</a><a class="headerlink" href="#weave-scipy-weave" title="Permalink to this headline">¶</a></h1>
<div class="section" id="outline">
<h2><a class="toc-backref" href="#id4">Outline</a><a class="headerlink" href="#outline" title="Permalink to this headline">¶</a></h2>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#weave-scipy-weave" id="id3">Weave (<a class="reference internal" href="../weave.html#module-scipy.weave" title="scipy.weave"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.weave</span></tt></a>)</a><ul>
<li><a class="reference internal" href="#outline" id="id4">Outline</a></li>
<li><a class="reference internal" href="#introduction" id="id5">Introduction</a></li>
<li><a class="reference internal" href="#requirements" id="id6">Requirements</a></li>
<li><a class="reference internal" href="#installation" id="id7">Installation</a></li>
<li><a class="reference internal" href="#testing" id="id8">Testing</a><ul>
<li><a class="reference internal" href="#testing-notes" id="id9">Testing Notes:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#benchmarks" id="id10">Benchmarks</a></li>
<li><a class="reference internal" href="#inline" id="id11">Inline</a><ul>
<li><a class="reference internal" href="#more-with-printf" id="id12">More with printf</a></li>
<li><a class="reference internal" href="#more-examples" id="id13">More examples</a><ul>
<li><a class="reference internal" href="#binary-search" id="id14">Binary search</a></li>
<li><a class="reference internal" href="#dictionary-sort" id="id15">Dictionary Sort</a></li>
<li><a class="reference internal" href="#numpy-cast-copy-transpose" id="id16">NumPy &#8211; cast/copy/transpose</a></li>
<li><a class="reference internal" href="#wxpython" id="id17">wxPython</a></li>
</ul>
</li>
<li><a class="reference internal" href="#keyword-option" id="id18">Keyword Option</a></li>
<li><a class="reference internal" href="#inline-arguments" id="id19">Inline Arguments</a></li>
<li><a class="reference internal" href="#distutils-keywords" id="id20">Distutils keywords</a><ul>
<li><a class="reference internal" href="#keyword-option-examples" id="id21">Keyword Option Examples</a></li>
<li><a class="reference internal" href="#returning-values" id="id22">Returning Values</a><ul>
<li><a class="reference internal" href="#the-issue-with-locals" id="id23">The issue with <tt class="docutils literal"><span class="pre">locals()</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-quick-look-at-the-code" id="id24">A quick look at the code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#technical-details" id="id25">Technical Details</a></li>
<li><a class="reference internal" href="#passing-variables-in-out-of-the-c-c-code" id="id26">Passing Variables in/out of the C/C++ code</a></li>
<li><a class="reference internal" href="#type-conversions" id="id27">Type Conversions</a><ul>
<li><a class="reference internal" href="#numpy-argument-conversion" id="id28">NumPy Argument Conversion</a></li>
<li><a class="reference internal" href="#string-list-tuple-and-dictionary-conversion" id="id29">String, List, Tuple, and Dictionary Conversion</a></li>
<li><a class="reference internal" href="#file-conversion" id="id30">File Conversion</a></li>
<li><a class="reference internal" href="#callable-instance-and-module-conversion" id="id31">Callable, Instance, and Module Conversion</a></li>
<li><a class="reference internal" href="#customizing-conversions" id="id32">Customizing Conversions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-catalog" id="id33">The Catalog</a><ul>
<li><a class="reference internal" href="#function-storage" id="id34">Function Storage</a></li>
<li><a class="reference internal" href="#catalog-search-paths-and-the-pythoncompiled-variable" id="id35">Catalog search paths and the PYTHONCOMPILED variable</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#blitz" id="id36">Blitz</a><ul>
<li><a class="reference internal" href="#id1" id="id37">Requirements</a></li>
<li><a class="reference internal" href="#limitations" id="id38">Limitations</a></li>
<li><a class="reference internal" href="#numpy-efficiency-issues-what-compilation-buys-you" id="id39">NumPy efficiency issues: What compilation buys you</a></li>
<li><a class="reference internal" href="#the-tools" id="id40">The Tools</a><ul>
<li><a class="reference internal" href="#parser" id="id41">Parser</a></li>
<li><a class="reference internal" href="#blitz-and-numpy" id="id42">Blitz and NumPy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-definitions-and-coersion" id="id43">Type definitions and coersion</a></li>
<li><a class="reference internal" href="#cataloging-compiled-functions" id="id44">Cataloging Compiled Functions</a></li>
<li><a class="reference internal" href="#checking-array-sizes" id="id45">Checking Array Sizes</a></li>
<li><a class="reference internal" href="#creating-the-extension-module" id="id46">Creating the Extension Module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extension-modules" id="id47">Extension Modules</a><ul>
<li><a class="reference internal" href="#a-simple-example" id="id48">A Simple Example</a></li>
<li><a class="reference internal" href="#fibonacci-example" id="id49">Fibonacci Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-type-conversions-type-factories" id="id50">Customizing Type Conversions &#8211; Type Factories</a></li>
<li><a class="reference internal" href="#things-i-wish-weave-did" id="id51">Things I wish <tt class="docutils literal"><span class="pre">weave</span></tt> did</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id5">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="../weave.html#module-scipy.weave" title="scipy.weave"><tt class="xref py py-mod docutils literal"><span class="pre">scipy.weave</span></tt></a> (below just <tt class="xref py py-mod docutils literal"><span class="pre">weave</span></tt>) package provides tools for
including C/C++ code within in
Python code. This offers both another level of optimization to those who need
it, and an easy way to modify and extend any supported extension libraries
such as wxPython and hopefully VTK soon. Inlining C/C++ code within Python
generally results in speed ups of 1.5x to 30x speed-up over algorithms
written in pure Python (However, it is also possible to slow things down...).
Generally algorithms that require a large number of calls to the Python API
don&#8217;t benefit as much from the conversion to C/C++ as algorithms that have
inner loops completely convertable to C.</p>
<p>There are three basic ways to use <tt class="docutils literal"><span class="pre">weave</span></tt>. The <tt class="docutils literal"><span class="pre">weave.inline()</span></tt> function
executes C code directly within Python, and <tt class="docutils literal"><span class="pre">weave.blitz()</span></tt> translates
Python NumPy expressions to C++ for fast execution. <tt class="docutils literal"><span class="pre">blitz()</span></tt> was the
original reason <tt class="docutils literal"><span class="pre">weave</span></tt> was built. For those interested in building
extension libraries, the <tt class="docutils literal"><span class="pre">ext_tools</span></tt> module provides classes for building
extension modules within Python.</p>
<p>Most of <tt class="docutils literal"><span class="pre">weave's</span></tt> functionality should work on Windows and Unix, although
some of its functionality requires <tt class="docutils literal"><span class="pre">gcc</span></tt> or a similarly modern C++ compiler
that handles templates well. Up to now, most testing has been done on Windows
2000 with Microsoft&#8217;s C++ compiler (MSVC) and with gcc (mingw32 2.95.2 and
2.95.3-6). All tests also pass on Linux (RH 7.1 with gcc 2.96), and I&#8217;ve had
reports that it works on Debian also (thanks Pearu).</p>
<p>The <tt class="docutils literal"><span class="pre">inline</span></tt> and <tt class="docutils literal"><span class="pre">blitz</span></tt> provide new functionality to Python (although
I&#8217;ve recently learned about the <a class="reference external" href="http://pyinline.sourceforge.net/">PyInline</a> project which may offer similar
functionality to <tt class="docutils literal"><span class="pre">inline</span></tt>). On the other hand, tools for building Python
extension modules already exists (SWIG, SIP, pycpp, CXX, and others). As of
yet, I&#8217;m not sure where <tt class="docutils literal"><span class="pre">weave</span></tt> fits in this spectrum. It is closest in
flavor to CXX in that it makes creating new C/C++ extension modules pretty
easy. However, if you&#8217;re wrapping a gaggle of legacy functions or classes,
SWIG and friends are definitely the better choice. <tt class="docutils literal"><span class="pre">weave</span></tt> is set up so
that you can customize how Python types are converted to C types in
<tt class="docutils literal"><span class="pre">weave</span></tt>. This is great for <tt class="docutils literal"><span class="pre">inline()</span></tt>, but, for wrapping legacy code, it
is more flexible to specify things the other way around &#8211; that is how C
types map to Python types. This <tt class="docutils literal"><span class="pre">weave</span></tt> does not do. I guess it would be
possible to build such a tool on top of <tt class="docutils literal"><span class="pre">weave</span></tt>, but with good tools like
SWIG around, I&#8217;m not sure the effort produces any new capabilities. Things
like function overloading are probably easily implemented in <tt class="docutils literal"><span class="pre">weave</span></tt> and it
might be easier to mix Python/C code in function calls, but nothing beyond
this comes to mind. So, if you&#8217;re developing new extension modules or
optimizing Python functions in C, <tt class="docutils literal"><span class="pre">weave.ext_tools()</span></tt> might be the tool for
you. If you&#8217;re wrapping legacy code, stick with SWIG.</p>
<p>The next several sections give the basics of how to use <tt class="docutils literal"><span class="pre">weave</span></tt>. We&#8217;ll
discuss what&#8217;s happening under the covers in more detail later on. Serious
users will need to at least look at the type conversion section to understand
how Python variables map to C/C++ types and how to customize this behavior.
One other note. If you don&#8217;t know C or C++ then these docs are probably of
very little help to you. Further, it&#8217;d be helpful if you know something about
writing Python extensions. <tt class="docutils literal"><span class="pre">weave</span></tt> does quite a bit for you, but for
anything complex, you&#8217;ll need to do some conversions, reference counting,
etc.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">weave</span></tt> is actually part of the <a class="reference external" href="http://www.scipy.org">SciPy</a> package. However, it
also works fine as a standalone package (you can install from scipy/weave
with <tt class="docutils literal"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></tt>). The examples here are given as if it is
used as a stand alone package. If you are using from within scipy, you can
use <tt class="docutils literal"><span class="pre">from</span> <span class="pre">scipy</span> <span class="pre">import</span> <span class="pre">weave</span></tt> and the examples will work identically.</p>
</div>
</div>
<div class="section" id="requirements">
<h2><a class="toc-backref" href="#id6">Requirements</a><a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">Python</p>
<p>I use 2.1.1. Probably 2.0 or higher should work.</p>
</li>
<li><p class="first">C++ compiler</p>
<p><tt class="docutils literal"><span class="pre">weave</span></tt> uses <tt class="docutils literal"><span class="pre">distutils</span></tt> to actually build extension modules, so
it uses whatever compiler was originally used to build Python. <tt class="docutils literal"><span class="pre">weave</span></tt>
itself requires a C++ compiler. If you used a C++ compiler to build
Python, your probably fine.</p>
<p>On Unix gcc is the preferred choice because I&#8217;ve done a little
testing with it. All testing has been done with gcc, but I expect the
majority of compilers should work for <tt class="docutils literal"><span class="pre">inline</span></tt> and <tt class="docutils literal"><span class="pre">ext_tools</span></tt>. The
one issue I&#8217;m not sure about is that I&#8217;ve hard coded things so that
compilations are linked with the <tt class="docutils literal"><span class="pre">stdc++</span></tt> library. <em>Is this standard
across Unix compilers, or is this a gcc-ism?</em></p>
<p>For <tt class="docutils literal"><span class="pre">blitz()</span></tt>, you&#8217;ll need a reasonably recent version of gcc.
2.95.2 works on windows and 2.96 looks fine on Linux. Other versions are
likely to work. Its likely that KAI&#8217;s C++ compiler and maybe some others
will work, but I haven&#8217;t tried. My advice is to use gcc for now unless
your willing to tinker with the code some.</p>
<p>On Windows, either MSVC or gcc (<a class="reference external" href="http://www.mingw.org%3Ewww.mingw.org">mingw32</a>) should work. Again,
you&#8217;ll need gcc for <tt class="docutils literal"><span class="pre">blitz()</span></tt> as the MSVC compiler doesn&#8217;t handle
templates well.</p>
<p>I have not tried Cygwin, so please report success if it works for
you.</p>
</li>
<li><p class="first">NumPy</p>
<p>The python <a class="reference external" href="http://numeric.scipy.org/">NumPy</a> module is required for <tt class="docutils literal"><span class="pre">blitz()</span></tt> to
work and for numpy.distutils which is used by weave.</p>
</li>
</ul>
</div>
<div class="section" id="installation">
<h2><a class="toc-backref" href="#id7">Installation</a><a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>There are currently two ways to get <tt class="docutils literal"><span class="pre">weave</span></tt>. First, <tt class="docutils literal"><span class="pre">weave</span></tt> is part of
SciPy and installed automatically (as a sub- package) whenever SciPy is
installed. Second, since <tt class="docutils literal"><span class="pre">weave</span></tt> is useful outside of the scientific
community, it has been setup so that it can be used as a stand-alone module.</p>
<p>The stand-alone version can be downloaded from <a class="reference external" href="http://www.scipy.org/Weave">here</a>.  Instructions for
installing should be found there as well.  setup.py file to simplify
installation.</p>
</div>
<div class="section" id="testing">
<h2><a class="toc-backref" href="#id8">Testing</a><a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h2>
<p>Once <tt class="docutils literal"><span class="pre">weave</span></tt> is installed, fire up python and run its unit tests.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">weave</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">test</span><span class="p">()</span>
<span class="go">runs long time... spews tons of output and a few warnings</span>
<span class="go">.</span>
<span class="go">.</span>
<span class="go">.</span>
<span class="go">..............................................................</span>
<span class="go">................................................................</span>
<span class="go">..................................................</span>
<span class="go">----------------------------------------------------------------------</span>
<span class="go">Ran 184 tests in 158.418s</span>
<span class="go">OK</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>This takes a while, usually several minutes. On Unix with remote file
systems, I&#8217;ve had it take 15 or so minutes. In the end, it should run about
180 tests and spew some speed results along the way. If you get errors,
they&#8217;ll be reported at the end of the output. Please report errors that you
find. Some tests are known to fail at this point.</p>
<p>If you only want to test a single module of the package, you can do this by
running test() for that specific module.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">weave.scalar_spec</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">scalar_spec</span><span class="o">.</span><span class="n">test</span><span class="p">()</span>
<span class="go">.......</span>
<span class="go"> ----------------------------------------------------------------------</span>
<span class="go">Ran 7 tests in 23.284s</span>
</pre></div>
</div>
<div class="section" id="testing-notes">
<h3><a class="toc-backref" href="#id9">Testing Notes:</a><a class="headerlink" href="#testing-notes" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Windows 1</p>
<p>I&#8217;ve had some test fail on windows machines where I have msvc,
gcc-2.95.2 (in c:gcc-2.95.2), and gcc-2.95.3-6 (in c:gcc) all
installed. My environment has c:gcc in the path and does not have
c:gcc-2.95.2 in the path. The test process runs very smoothly until the
end where several test using gcc fail with cpp0 not found by g++. If I
check os.system(&#8216;gcc -v&#8217;) before running tests, I get gcc-2.95.3-6. If I
check after running tests (and after failure), I get gcc-2.95.2. ??huh??.
The os.environ[&#8216;PATH&#8217;] still has c:gcc first in it and is not corrupted
(msvc/distutils messes with the environment variables, so we have to undo
its work in some places). If anyone else sees this, let me know - - it
may just be an quirk on my machine (unlikely). Testing with the gcc-
2.95.2 installation always works.</p>
</li>
<li><p class="first">Windows 2</p>
<p>If you run the tests from PythonWin or some other GUI tool, you&#8217;ll
get a ton of DOS windows popping up periodically as <tt class="docutils literal"><span class="pre">weave</span></tt> spawns the
compiler multiple times. Very annoying. Anyone know how to fix this?</p>
</li>
<li><p class="first">wxPython</p>
<p>wxPython tests are not enabled by default because importing wxPython
on a Unix machine without access to a X-term will cause the program to
exit. Anyone know of a safe way to detect whether wxPython can be
imported and whether a display exists on a machine?</p>
</li>
</ul>
</div>
</div>
<div class="section" id="benchmarks">
<h2><a class="toc-backref" href="#id10">Benchmarks</a><a class="headerlink" href="#benchmarks" title="Permalink to this headline">¶</a></h2>
<p>This section has not been updated from old scipy weave and Numeric....</p>
<p>This section has a few benchmarks  &#8211; thats all people want to see anyway
right? These are mostly taken from running files in the <tt class="docutils literal"><span class="pre">weave/example</span></tt>
directory and also from the test scripts. Without more information about what
the test actually do, their value is limited. Still, their here for the
curious. Look at the example scripts for more specifics about what problem
was actually solved by each run. These examples are run under windows 2000
using Microsoft Visual C++ and python2.1 on a 850 MHz PIII laptop with 320 MB
of RAM. Speed up is the improvement (degredation) factor of <tt class="docutils literal"><span class="pre">weave</span></tt>
compared to conventional Python functions. <tt class="docutils literal"><span class="pre">The</span> <span class="pre">blitz()</span></tt> comparisons are
shown compared to NumPy.</p>
<table border="1" class="docutils">
<caption>inline and ext_tools</caption>
<colgroup>
<col width="67%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Algorithm</th>
<th class="head">Speed up</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>binary search</td>
<td>1.50</td>
</tr>
<tr class="row-odd"><td>fibonacci (recursive)</td>
<td>82.10</td>
</tr>
<tr class="row-even"><td>fibonacci (loop)</td>
<td>9.17</td>
</tr>
<tr class="row-odd"><td>return None</td>
<td>0.14</td>
</tr>
<tr class="row-even"><td>map</td>
<td>1.20</td>
</tr>
<tr class="row-odd"><td>dictionary sort</td>
<td>2.54</td>
</tr>
<tr class="row-even"><td>vector quantization</td>
<td>37.40</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<caption>blitz &#8211; double precision</caption>
<colgroup>
<col width="73%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Algorithm</th>
<th class="head">Speed up</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>a = b + c 512x512</td>
<td>3.05</td>
</tr>
<tr class="row-odd"><td>a = b + c + d 512x512</td>
<td>4.59</td>
</tr>
<tr class="row-even"><td>5 pt avg. filter, 2D Image 512x512</td>
<td>9.01</td>
</tr>
<tr class="row-odd"><td>Electromagnetics (FDTD) 100x100x100</td>
<td>8.61</td>
</tr>
</tbody>
</table>
<p>The benchmarks shown <tt class="docutils literal"><span class="pre">blitz</span></tt> in the best possible light. NumPy (at least on
my machine) is significantly worse for double precision than it is for single
precision calculations. If your interested in single precision results, you
can pretty much divide the double precision speed up by 3 and you&#8217;ll be
close.</p>
</div>
<div class="section" id="inline">
<h2><a class="toc-backref" href="#id11">Inline</a><a class="headerlink" href="#inline" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">inline()</span></tt> compiles and executes C/C++ code on the fly. Variables in the
local and global Python scope are also available in the C/C++ code. Values
are passed to the C/C++ code by assignment much like variables are passed
into a standard Python function. Values are returned from the C/C++ code
through a special argument called return_val. Also, the contents of mutable
objects can be changed within the C/C++ code and the changes remain after the
C code exits and returns to Python. (more on this later)</p>
<p>Here&#8217;s a trivial <tt class="docutils literal"><span class="pre">printf</span></tt> example using <tt class="docutils literal"><span class="pre">inline()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">weave</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="s">&#39;printf(&quot;</span><span class="si">%d</span><span class="se">\\</span><span class="s">n&quot;,a);&#39;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="go">1</span>
</pre></div>
</div>
<p>In this, its most basic form, <tt class="docutils literal"><span class="pre">inline(c_code,</span> <span class="pre">var_list)</span></tt> requires two
arguments. <tt class="docutils literal"><span class="pre">c_code</span></tt> is a string of valid C/C++ code. <tt class="docutils literal"><span class="pre">var_list</span></tt> is a list
of variable names that are passed from Python into C/C++. Here we have a
simple <tt class="docutils literal"><span class="pre">printf</span></tt> statement that writes the Python variable <tt class="docutils literal"><span class="pre">a</span></tt> to the
screen. The first time you run this, there will be a pause while the code is
written to a .cpp file, compiled into an extension module, loaded into
Python, cataloged for future use, and executed. On windows (850 MHz PIII),
this takes about 1.5 seconds when using Microsoft&#8217;s C++ compiler (MSVC) and
6-12 seconds using gcc (mingw32 2.95.2). All subsequent executions of the
code will happen very quickly because the code only needs to be compiled
once. If you kill and restart the interpreter and then execute the same code
fragment again, there will be a much shorter delay in the fractions of
seconds range. This is because <tt class="docutils literal"><span class="pre">weave</span></tt> stores a catalog of all previously
compiled functions in an on disk cache. When it sees a string that has been
compiled, it loads the already compiled module and executes the appropriate
function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you try the <tt class="docutils literal"><span class="pre">printf</span></tt> example in a GUI shell such as IDLE,
PythonWin, PyShell, etc., you&#8217;re unlikely to see the output. This is because
the C code is writing to stdout, instead of to the GUI window. This doesn&#8217;t
mean that inline doesn&#8217;t work in these environments &#8211; it only means that
standard out in C is not the same as the standard out for Python in these
cases. Non input/output functions will work as expected.</p>
</div>
<p>Although effort has been made to reduce the overhead associated with calling
inline, it is still less efficient for simple code snippets than using
equivalent Python code. The simple <tt class="docutils literal"><span class="pre">printf</span></tt> example is actually slower by
30% or so than using Python <tt class="docutils literal"><span class="pre">print</span></tt> statement. And, it is not difficult to
create code fragments that are 8-10 times slower using inline than equivalent
Python. However, for more complicated algorithms, the speedup can be
worthwhile &#8211; anywhere from 1.5-30 times faster. Algorithms that have to
manipulate Python objects (sorting a list) usually only see a factor of 2 or
so improvement. Algorithms that are highly computational or manipulate NumPy
arrays can see much larger improvements. The examples/vq.py file shows a
factor of 30 or more improvement on the vector quantization algorithm that is
used heavily in information theory and classification problems.</p>
<div class="section" id="more-with-printf">
<h3><a class="toc-backref" href="#id12">More with printf</a><a class="headerlink" href="#more-with-printf" title="Permalink to this headline">¶</a></h3>
<p>MSVC users will actually see a bit of compiler output that distutils does not
suppress the first time the code executes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="s">r&#39;printf(&quot;</span><span class="si">%d</span><span class="s">\n&quot;,a);&#39;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="go">sc_e013937dbc8c647ac62438874e5795131.cpp</span>
<span class="go">   Creating library C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp</span>
<span class="go">   \Release\sc_e013937dbc8c647ac62438874e5795131.lib and</span>
<span class="go">   object C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\sc_e013937dbc8c647ac62438874e5795131.exp</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Nothing bad is happening, its just a bit annoying. * Anyone know how to turn
this off?*</p>
<p>This example also demonstrates using &#8216;raw strings&#8217;. The <tt class="docutils literal"><span class="pre">r</span></tt> preceeding the
code string in the last example denotes that this is a &#8216;raw string&#8217;. In raw
strings, the backslash character is not interpreted as an escape character,
and so it isn&#8217;t necessary to use a double backslash to indicate that the &#8216;n&#8217;
is meant to be interpreted in the C <tt class="docutils literal"><span class="pre">printf</span></tt> statement instead of by
Python. If your C code contains a lot of strings and control characters, raw
strings might make things easier. Most of the time, however, standard strings
work just as well.</p>
<p>The <tt class="docutils literal"><span class="pre">printf</span></tt> statement in these examples is formatted to print out
integers. What happens if <tt class="docutils literal"><span class="pre">a</span></tt> is a string? <tt class="docutils literal"><span class="pre">inline</span></tt> will happily, compile
a new version of the code to accept strings as input, and execute the code.
The result?</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s">&#39;string&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="s">r&#39;printf(&quot;</span><span class="si">%d</span><span class="s">\n&quot;,a);&#39;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="go">32956972</span>
</pre></div>
</div>
<p>In this case, the result is non-sensical, but also non-fatal. In other
situations, it might produce a compile time error because <tt class="docutils literal"><span class="pre">a</span></tt> is required
to be an integer at some point in the code, or it could produce a
segmentation fault. Its possible to protect against passing <tt class="docutils literal"><span class="pre">inline</span></tt>
arguments of the wrong data type by using asserts in Python.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s">&#39;string&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">protected_printf</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">assert</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="s">r&#39;printf(&quot;</span><span class="si">%d</span><span class="s">\n&quot;,a);&#39;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">protected_printf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go"> 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">protected_printf</span><span class="p">(</span><span class="s">&#39;string&#39;</span><span class="p">)</span>
<span class="go">AssertError...</span>
</pre></div>
</div>
<p>For printing strings, the format statement needs to be changed. Also, weave
doesn&#8217;t convert strings to char*. Instead it uses CXX Py::String type, so you
have to do a little more work. Here we convert it to a C++ std::string and
then ask cor the char* version.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s">&#39;string&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="s">r&#39;printf(&quot;</span><span class="si">%s</span><span class="s">\n&quot;,std::string(a).c_str());&#39;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="go">string</span>
</pre></div>
</div>
<div class="admonition-xxx admonition">
<p class="first admonition-title">XXX</p>
<p class="last">This is a little convoluted. Perhaps strings should convert to <tt class="docutils literal"><span class="pre">std::string</span></tt>
objects instead of CXX objects. Or maybe to <tt class="docutils literal"><span class="pre">char*</span></tt>.</p>
</div>
<p>As in this case, C/C++ code fragments often have to change to accept
different types. For the given printing task, however, C++ streams provide a
way of a single statement that works for integers and strings. By default,
the stream objects live in the std (standard) namespace and thus require the
use of <tt class="docutils literal"><span class="pre">std::</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="s">&#39;std::cout &lt;&lt; a &lt;&lt; std::endl;&#39;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s">&#39;string&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="s">&#39;std::cout &lt;&lt; a &lt;&lt; std::endl;&#39;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="go">string</span>
</pre></div>
</div>
<p>Examples using <tt class="docutils literal"><span class="pre">printf</span></tt> and <tt class="docutils literal"><span class="pre">cout</span></tt> are included in
examples/print_example.py.</p>
</div>
<div class="section" id="more-examples">
<h3><a class="toc-backref" href="#id13">More examples</a><a class="headerlink" href="#more-examples" title="Permalink to this headline">¶</a></h3>
<p>This section shows several more advanced uses of <tt class="docutils literal"><span class="pre">inline</span></tt>. It includes a
few algorithms from the <a class="reference external" href="http://aspn.activestate.com/ASPN/Cookbook/Python">Python Cookbook</a> that have been re-written in
inline C to improve speed as well as a couple examples using NumPy and
wxPython.</p>
<div class="section" id="binary-search">
<h4><a class="toc-backref" href="#id14">Binary search</a><a class="headerlink" href="#binary-search" title="Permalink to this headline">¶</a></h4>
<p>Lets look at the example of searching a sorted list of integers for a value.
For inspiration, we&#8217;ll use Kalle Svensson&#8217;s <a class="reference external" href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/81188">binary_search()</a> algorithm
from the Python Cookbook. His recipe follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="nb">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">max</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">max</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span>  <span class="o">+</span> <span class="nb">max</span><span class="p">)</span>  <span class="o">/</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">seq</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">:</span>
            <span class="nb">min</span> <span class="o">=</span> <span class="n">m</span>  <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">seq</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">:</span>
            <span class="nb">max</span> <span class="o">=</span> <span class="n">m</span>  <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">m</span>
</pre></div>
</div>
<p>This Python version works for arbitrary Python data types. The C version
below is specialized to handle integer values. There is a little type
checking done in Python to assure that we&#8217;re working with the correct data
types before heading into C. The variables <tt class="docutils literal"><span class="pre">seq</span></tt> and <tt class="docutils literal"><span class="pre">t</span></tt> don&#8217;t need to be
declared beacuse <tt class="docutils literal"><span class="pre">weave</span></tt> handles converting and declaring them in the C
code. All other temporary variables such as <tt class="docutils literal"><span class="pre">min,</span> <span class="pre">max</span></tt>, etc. must be
declared &#8211; it is C after all. Here&#8217;s the new mixed Python/C function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">c_int_binary_search</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="c"># do a little type checking in Python</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">([]))</span>

    <span class="c"># now the C code</span>
    <span class="n">code</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">           #line 29 &quot;binary_search.py&quot;</span>
<span class="s">           int val, m, min = 0;</span>
<span class="s">           int max = seq.length() - 1;</span>
<span class="s">           PyObject *py_val;</span>
<span class="s">           for(;;)</span>
<span class="s">           {</span>
<span class="s">               if (max &lt; min  )</span>
<span class="s">               {</span>
<span class="s">                   return_val =  Py::new_reference_to(Py::Int(-1));</span>
<span class="s">                   break;</span>
<span class="s">               }</span>
<span class="s">               m =  (min + max) /2;</span>
<span class="s">               val = py_to_int(PyList_GetItem(seq.ptr(),m),&quot;val&quot;);</span>
<span class="s">               if (val  &lt; t)</span>
<span class="s">                   min = m  + 1;</span>
<span class="s">               else if (val &gt;  t)</span>
<span class="s">                   max = m - 1;</span>
<span class="s">               else</span>
<span class="s">               {</span>
<span class="s">                   return_val = Py::new_reference_to(Py::Int(m));</span>
<span class="s">                   break;</span>
<span class="s">               }</span>
<span class="s">           }</span>
<span class="s">           &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;seq&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>We have two variables <tt class="docutils literal"><span class="pre">seq</span></tt> and <tt class="docutils literal"><span class="pre">t</span></tt> passed in. <tt class="docutils literal"><span class="pre">t</span></tt> is guaranteed (by
the <tt class="docutils literal"><span class="pre">assert</span></tt>) to be an integer. Python integers are converted to C int
types in the transition from Python to C. <tt class="docutils literal"><span class="pre">seq</span></tt> is a Python list. By
default, it is translated to a CXX list object. Full documentation for the
CXX library can be found at its <a class="reference external" href="http://cxx.sourceforge.net/">website</a>. The basics are that the CXX
provides C++ class equivalents for Python objects that simplify, or at least
object orientify, working with Python objects in C/C++. For example,
<tt class="docutils literal"><span class="pre">seq.length()</span></tt> returns the length of the list. A little more about CXX and
its class methods, etc. is in the <em class="xref py py-obj">Type Conversions</em> section.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">CXX uses templates and therefore may be a little less portable than
another alternative by Gordan McMillan called SCXX which was
inspired by CXX. It doesn&#8217;t use templates so it should compile
faster and be more portable. SCXX has a few less features, but it
appears to me that it would mesh with the needs of weave quite well.
Hopefully xxx_spec files will be written for SCXX in the future, and
we&#8217;ll be able to compare on a more empirical basis. Both sets of
spec files will probably stick around, it just a question of which
becomes the default.</p>
</div>
<p>Most of the algorithm above looks similar in C to the original Python code.
There are two main differences. The first is the setting of <tt class="docutils literal"><span class="pre">return_val</span></tt>
instead of directly returning from the C code with a <tt class="docutils literal"><span class="pre">return</span></tt> statement.
<tt class="docutils literal"><span class="pre">return_val</span></tt> is an automatically defined variable of type <tt class="docutils literal"><span class="pre">PyObject*</span></tt>
that is returned from the C code back to Python. You&#8217;ll have to handle
reference counting issues when setting this variable. In this example, CXX
classes and functions handle the dirty work. All CXX functions and classes
live in the namespace <tt class="docutils literal"><span class="pre">Py::</span></tt>. The following code converts the integer <tt class="docutils literal"><span class="pre">m</span></tt>
to a CXX <tt class="docutils literal"><span class="pre">Int()</span></tt> object and then to a <tt class="docutils literal"><span class="pre">PyObject*</span></tt> with an incremented
reference count using <tt class="docutils literal"><span class="pre">Py::new_reference_to()</span></tt>.</p>
<div class="highlight-python"><pre>return_val = Py::new_reference_to(Py::Int(m));</pre>
</div>
<p>The second big differences shows up in the retrieval of integer values from
the Python list. The simple Python <tt class="docutils literal"><span class="pre">seq[i]</span></tt> call balloons into a C Python
API call to grab the value out of the list and then a separate call to
<tt class="docutils literal"><span class="pre">py_to_int()</span></tt> that converts the PyObject* to an integer. <tt class="docutils literal"><span class="pre">py_to_int()</span></tt>
includes both a NULL cheack and a <tt class="docutils literal"><span class="pre">PyInt_Check()</span></tt> call as well as the
conversion call. If either of the checks fail, an exception is raised. The
entire C++ code block is executed with in a <tt class="docutils literal"><span class="pre">try/catch</span></tt> block that handles
exceptions much like Python does. This removes the need for most error
checking code.</p>
<p>It is worth note that CXX lists do have indexing operators that result in
code that looks much like Python. However, the overhead in using them appears
to be relatively high, so the standard Python API was used on the
<tt class="docutils literal"><span class="pre">seq.ptr()</span></tt> which is the underlying <tt class="docutils literal"><span class="pre">PyObject*</span></tt> of the List object.</p>
<p>The <tt class="docutils literal"><span class="pre">#line</span></tt> directive that is the first line of the C code block isn&#8217;t
necessary, but it&#8217;s nice for debugging. If the compilation fails because of
the syntax error in the code, the error will be reported as an error in the
Python file &#8220;binary_search.py&#8221; with an offset from the given line number (29
here).</p>
<p>So what was all our effort worth in terms of efficiency? Well not a lot in
this case. The examples/binary_search.py file runs both Python and C versions
of the functions As well as using the standard <tt class="docutils literal"><span class="pre">bisect</span></tt> module. If we run
it on a 1 million element list and run the search 3000 times (for 0- 2999),
here are the results we get:</p>
<div class="highlight-python"><pre>C:\home\ej\wrk\scipy\weave\examples&gt; python binary_search.py
Binary search for 3000 items in 1000000 length list of integers:
speed in python: 0.159999966621
speed of bisect: 0.121000051498
speed up: 1.32
speed in c: 0.110000014305
speed up: 1.45
speed in c(no asserts): 0.0900000333786
speed up: 1.78</pre>
</div>
<p>So, we get roughly a 50-75% improvement depending on whether we use the
Python asserts in our C version. If we move down to searching a 10000 element
list, the advantage evaporates. Even smaller lists might result in the Python
version being faster. I&#8217;d like to say that moving to NumPy lists (and getting
rid of the GetItem() call) offers a substantial speed up, but my preliminary
efforts didn&#8217;t produce one. I think the log(N) algorithm is to blame. Because
the algorithm is nice, there just isn&#8217;t much time spent computing things, so
moving to C isn&#8217;t that big of a win. If there are ways to reduce conversion
overhead of values, this may improve the C/Python speed up. Anyone have other
explanations or faster code, please let me know.</p>
</div>
<div class="section" id="dictionary-sort">
<h4><a class="toc-backref" href="#id15">Dictionary Sort</a><a class="headerlink" href="#dictionary-sort" title="Permalink to this headline">¶</a></h4>
<p>The demo in examples/dict_sort.py is another example from the Python
CookBook. <a class="reference external" href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52306">This submission</a>, by Alex Martelli, demonstrates how to return
the values from a dictionary sorted by their keys:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">sortedDictValues3</span><span class="p">(</span><span class="n">adict</span><span class="p">):</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="n">adict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">keys</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">adict</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>
</pre></div>
</div>
<p>Alex provides 3 algorithms and this is the 3rd and fastest of the set. The C
version of this same algorithm follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">c_sort</span><span class="p">(</span><span class="n">adict</span><span class="p">):</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">adict</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">({}))</span>
    <span class="n">code</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">    #line 21 &quot;dict_sort.py&quot;</span>
<span class="s">    Py::List keys = adict.keys();</span>
<span class="s">    Py::List items(keys.length()); keys.sort();</span>
<span class="s">    PyObject* item = NULL;</span>
<span class="s">    for(int i = 0;  i &lt; keys.length();i++)</span>
<span class="s">    {</span>
<span class="s">        item = PyList_GET_ITEM(keys.ptr(),i);</span>
<span class="s">        item = PyDict_GetItem(adict.ptr(),item);</span>
<span class="s">        Py_XINCREF(item);</span>
<span class="s">        PyList_SetItem(items.ptr(),i,item);</span>
<span class="s">    }</span>
<span class="s">    return_val = Py::new_reference_to(items);</span>
<span class="s">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">inline_tools</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;adict&#39;</span><span class="p">],</span><span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Like the original Python function, the C++ version can handle any Python
dictionary regardless of the key/value pair types. It uses CXX objects for
the most part to declare python types in C++, but uses Python API calls to
manipulate their contents. Again, this choice is made for speed. The C++
version, while more complicated, is about a factor of 2 faster than Python.</p>
<div class="highlight-python"><pre>C:\home\ej\wrk\scipy\weave\examples&gt; python dict_sort.py
Dict sort of 1000 items for 300 iterations:
 speed in python: 0.319999933243
[0, 1, 2, 3, 4]
 speed in c: 0.151000022888
 speed up: 2.12
[0, 1, 2, 3, 4]</pre>
</div>
</div>
<div class="section" id="numpy-cast-copy-transpose">
<h4><a class="toc-backref" href="#id16">NumPy &#8211; cast/copy/transpose</a><a class="headerlink" href="#numpy-cast-copy-transpose" title="Permalink to this headline">¶</a></h4>
<p>CastCopyTranspose is a function called quite heavily by Linear Algebra
routines in the NumPy library. Its needed in part because of the row-major
memory layout of multi-demensional Python (and C) arrays vs. the col-major
order of the underlying Fortran algorithms. For small matrices (say 100x100
or less), a significant portion of the common routines such as LU
decompisition or singular value decompostion are spent in this setup routine.
This shouldn&#8217;t happen. Here is the Python version of the function using
standard NumPy operations.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_castCopyAndTranspose</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">typecode</span><span class="p">()</span> <span class="o">==</span> <span class="nb">type</span><span class="p">:</span>
        <span class="n">cast_array</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NumPy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cast_array</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NumPy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">type</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">cast_array</span>
</pre></div>
</div>
<p>And the following is a inline C version of the same function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">weave.blitz_tools</span> <span class="kn">import</span> <span class="n">blitz_type_factories</span>
<span class="kn">from</span> <span class="nn">weave</span> <span class="kn">import</span> <span class="n">scalar_spec</span>
<span class="kn">from</span> <span class="nn">weave</span> <span class="kn">import</span> <span class="n">inline</span>
<span class="k">def</span> <span class="nf">_cast_copy_transpose</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span><span class="n">a_2d</span><span class="p">):</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a_2d</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">new_array</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a_2d</span><span class="p">),</span><span class="nb">type</span><span class="p">)</span>
    <span class="n">NumPy_type</span> <span class="o">=</span> <span class="n">scalar_spec</span><span class="o">.</span><span class="n">NumPy_to_blitz_type_mapping</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span>
    <span class="n">code</span> <span class="o">=</span> \
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    for(int i = 0;i &lt; _Na_2d[0]; i++)</span>
<span class="sd">        for(int j = 0;  j &lt; _Na_2d[1]; j++)</span>
<span class="sd">            new_array(i,j) = (%s) a_2d(j,i);</span>
<span class="sd">    &quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">NumPy_type</span>
    <span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;new_array&#39;</span><span class="p">,</span><span class="s">&#39;a_2d&#39;</span><span class="p">],</span>
           <span class="n">type_factories</span> <span class="o">=</span> <span class="n">blitz_type_factories</span><span class="p">,</span><span class="n">compiler</span><span class="o">=</span><span class="s">&#39;gcc&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_array</span>
</pre></div>
</div>
<p>This example uses blitz++ arrays instead of the standard representation of
NumPy arrays so that indexing is simplier to write. This is accomplished by
passing in the blitz++ &#8220;type factories&#8221; to override the standard Python to
C++ type conversions. Blitz++ arrays allow you to write clean, fast code, but
they also are sloooow to compile (20 seconds or more for this snippet). This
is why they aren&#8217;t the default type used for Numeric arrays (and also because
most compilers can&#8217;t compile blitz arrays...). <tt class="docutils literal"><span class="pre">inline()</span></tt> is also forced to
use &#8216;gcc&#8217; as the compiler because the default compiler on Windows (MSVC) will
not compile blitz code. (&#8216;gcc&#8217; I think will use the standard compiler on
Unix machine instead of explicitly forcing gcc (check this)) Comparisons of
the Python vs inline C++ code show a factor of 3 speed up. Also shown are the
results of an &#8220;inplace&#8221; transpose routine that can be used if the output of
the linear algebra routine can overwrite the original matrix (this is often
appropriate). This provides another factor of 2 improvement.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#C:\home\ej\wrk\scipy\weave\examples&gt; python cast_copy_transpose.py</span>
<span class="c"># Cast/Copy/Transposing (150,150)array 1 times</span>
<span class="c">#  speed in python: 0.870999932289</span>
<span class="c">#  speed in c: 0.25</span>
<span class="c">#  speed up: 3.48</span>
<span class="c">#  inplace transpose c: 0.129999995232</span>
<span class="c">#  speed up: 6.70</span>
</pre></div>
</div>
</div>
<div class="section" id="wxpython">
<h4><a class="toc-backref" href="#id17">wxPython</a><a class="headerlink" href="#wxpython" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">inline</span></tt> knows how to handle wxPython objects. Thats nice in and of itself,
but it also demonstrates that the type conversion mechanism is reasonably
flexible. Chances are, it won&#8217;t take a ton of effort to support special types
you might have. The examples/wx_example.py borrows the scrolled window
example from the wxPython demo, accept that it mixes inline C code in the
middle of the drawing function.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">DoDrawing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dc</span><span class="p">):</span>

    <span class="n">red</span> <span class="o">=</span> <span class="n">wxNamedColour</span><span class="p">(</span><span class="s">&quot;RED&quot;</span><span class="p">);</span>
    <span class="n">blue</span> <span class="o">=</span> <span class="n">wxNamedColour</span><span class="p">(</span><span class="s">&quot;BLUE&quot;</span><span class="p">);</span>
    <span class="n">grey_brush</span> <span class="o">=</span> <span class="n">wxLIGHT_GREY_BRUSH</span><span class="p">;</span>
    <span class="n">code</span> <span class="o">=</span> \
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    #line 108 &quot;wx_example.py&quot;</span>
<span class="sd">    dc-&gt;BeginDrawing();</span>
<span class="sd">    dc-&gt;SetPen(wxPen(*red,4,wxSOLID));</span>
<span class="sd">    dc-&gt;DrawRectangle(5,5,50,50);</span>
<span class="sd">    dc-&gt;SetBrush(*grey_brush);</span>
<span class="sd">    dc-&gt;SetPen(wxPen(*blue,4,wxSOLID));</span>
<span class="sd">    dc-&gt;DrawRectangle(15, 15, 50, 50);</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;dc&#39;</span><span class="p">,</span><span class="s">&#39;red&#39;</span><span class="p">,</span><span class="s">&#39;blue&#39;</span><span class="p">,</span><span class="s">&#39;grey_brush&#39;</span><span class="p">])</span>

    <span class="n">dc</span><span class="o">.</span><span class="n">SetFont</span><span class="p">(</span><span class="n">wxFont</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="n">wxSWISS</span><span class="p">,</span> <span class="n">wxNORMAL</span><span class="p">,</span> <span class="n">wxNORMAL</span><span class="p">))</span>
    <span class="n">dc</span><span class="o">.</span><span class="n">SetTextForeground</span><span class="p">(</span><span class="n">wxColour</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">))</span>
    <span class="n">te</span> <span class="o">=</span> <span class="n">dc</span><span class="o">.</span><span class="n">GetTextExtent</span><span class="p">(</span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span>
    <span class="n">dc</span><span class="o">.</span><span class="n">DrawText</span><span class="p">(</span><span class="s">&quot;Hello World&quot;</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">65</span><span class="p">)</span>

    <span class="n">dc</span><span class="o">.</span><span class="n">SetPen</span><span class="p">(</span><span class="n">wxPen</span><span class="p">(</span><span class="n">wxNamedColour</span><span class="p">(</span><span class="s">&#39;VIOLET&#39;</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>
    <span class="n">dc</span><span class="o">.</span><span class="n">DrawLine</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">65</span><span class="o">+</span><span class="n">te</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">60</span><span class="o">+</span><span class="n">te</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">65</span><span class="o">+</span><span class="n">te</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Here, some of the Python calls to wx objects were just converted to C++
calls. There isn&#8217;t any benefit, it just demonstrates the capabilities. You
might want to use this if you have a computationally intensive loop in your
drawing code that you want to speed up. On windows, you&#8217;ll have to use the
MSVC compiler if you use the standard wxPython DLLs distributed by Robin
Dunn. Thats because MSVC and gcc, while binary compatible in C, are not
binary compatible for C++. In fact, its probably best, no matter what
platform you&#8217;re on, to specify that <tt class="docutils literal"><span class="pre">inline</span></tt> use the same compiler that was
used to build wxPython to be on the safe side. There isn&#8217;t currently a way to
learn this info from the library &#8211; you just have to know. Also, at least on
the windows platform, you&#8217;ll need to install the wxWindows libraries and link
to them. I think there is a way around this, but I haven&#8217;t found it yet &#8211; I
get some linking errors dealing with wxString. One final note. You&#8217;ll
probably have to tweak weave/wx_spec.py or weave/wx_info.py for your
machine&#8217;s configuration to point at the correct directories etc. There. That
should sufficiently scare people into not even looking at this... :)</p>
</div>
</div>
<div class="section" id="keyword-option">
<h3><a class="toc-backref" href="#id18">Keyword Option</a><a class="headerlink" href="#keyword-option" title="Permalink to this headline">¶</a></h3>
<p>The basic definition of the <tt class="docutils literal"><span class="pre">inline()</span></tt> function has a slew of optional
variables. It also takes keyword arguments that are passed to <tt class="docutils literal"><span class="pre">distutils</span></tt>
as compiler options. The following is a formatted cut/paste of the argument
section of <tt class="docutils literal"><span class="pre">inline's</span></tt> doc-string. It explains all of the variables. Some
examples using various options will follow.</p>
<div class="highlight-python"><pre>def inline(code,arg_names,local_dict = None, global_dict = None,
           force = 0,
           compiler='',
           verbose = 0,
           support_code = None,
           customize=None,
           type_factories = None,
           auto_downcast=1,
           **kw):</pre>
</div>
<p><tt class="docutils literal"><span class="pre">inline</span></tt> has quite a few options as listed below. Also, the keyword
arguments for distutils extension modules are accepted to specify extra
information needed for compiling.</p>
</div>
<div class="section" id="inline-arguments">
<h3><a class="toc-backref" href="#id19">Inline Arguments</a><a class="headerlink" href="#inline-arguments" title="Permalink to this headline">¶</a></h3>
<p>code  string. A string of valid C++ code. It should not specify a return
statement. Instead it should assign results that need to be returned to
Python in the return_val.  arg_names  list of strings. A list of Python
variable names that should be transferred from Python into the C/C++ code.
local_dict  optional. dictionary. If specified, it is a dictionary of values
that should be used as the local scope for the C/C++ code. If local_dict is
not specified the local dictionary of the calling function is used.
global_dict  optional. dictionary. If specified, it is a dictionary of values
that should be used as the global scope for the C/C++ code. If global_dict is
not specified the global dictionary of the calling function is used.  force
optional. 0 or 1. default 0. If 1, the C++ code is compiled every time inline
is called. This is really only useful for debugging, and probably only useful
if you&#8217;re editing support_code a lot.  compiler  optional. string. The name
of compiler to use when compiling. On windows, it understands &#8216;msvc&#8217; and
&#8216;gcc&#8217; as well as all the compiler names understood by distutils. On Unix,
it&#8217;ll only understand the values understoof by distutils. (I should add &#8216;gcc&#8217;
though to this).</p>
<p>On windows, the compiler defaults to the Microsoft C++ compiler. If this
isn&#8217;t available, it looks for mingw32 (the gcc compiler).</p>
<p>On Unix, it&#8217;ll probably use the same compiler that was used when compiling
Python. Cygwin&#8217;s behavior should be similar.</p>
<p>verbose  optional. 0,1, or 2. defualt 0. Speficies how much much
information is printed during the compile phase of inlining code. 0 is silent
(except on windows with msvc where it still prints some garbage). 1 informs
you when compiling starts, finishes, and how long it took. 2 prints out the
command lines for the compilation process and can be useful if you&#8217;re having
problems getting code to work. Its handy for finding the name of the .cpp
file if you need to examine it. verbose has no affect if the compilation
isn&#8217;t necessary.  support_code  optional. string. A string of valid C++ code
declaring extra code that might be needed by your compiled function. This
could be declarations of functions, classes, or structures.  customize
optional. base_info.custom_info object. An alternative way to specifiy
support_code, headers, etc. needed by the function see the weave.base_info
module for more details. (not sure this&#8217;ll be used much).  type_factories
optional. list of type specification factories. These guys are what convert
Python data types to C/C++ data types. If you&#8217;d like to use a different set
of type conversions than the default, specify them here. Look in the type
conversions section of the main documentation for examples.  auto_downcast
optional. 0 or 1. default 1. This only affects functions that have Numeric
arrays as input variables. Setting this to 1 will cause all floating point
values to be cast as float instead of double if all the NumPy arrays are of
type float. If even one of the arrays has type double or double complex, all
variables maintain there standard types.</p>
</div>
<div class="section" id="distutils-keywords">
<h3><a class="toc-backref" href="#id20">Distutils keywords</a><a class="headerlink" href="#distutils-keywords" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">inline()</span></tt> also accepts a number of <tt class="docutils literal"><span class="pre">distutils</span></tt> keywords for
controlling how the code is compiled. The following descriptions have been
copied from Greg Ward&#8217;s <tt class="docutils literal"><span class="pre">distutils.extension.Extension</span></tt> class doc- strings
for convenience:  sources  [string] list of source filenames, relative to the
distribution root (where the setup script lives), in Unix form (slash-
separated) for portability. Source files may be C, C++, SWIG (.i), platform-
specific resource files, or whatever else is recognized by the &#8220;build_ext&#8221;
command as source for a Python extension. Note: The module_path file is
always appended to the front of this list  include_dirs  [string] list of
directories to search for C/C++ header files (in Unix form for portability)
define_macros  [(name : string, value : string|None)] list of macros to
define; each macro is defined using a 2-tuple, where &#8216;value&#8217; is either the
string to define it to or None to define it without a particular value
(equivalent of &#8220;#define FOO&#8221; in source or -DFOO on Unix C compiler command
line)  undef_macros  [string] list of macros to undefine explicitly
library_dirs  [string] list of directories to search for C/C++ libraries at
link time  libraries  [string] list of library names (not filenames or paths)
to link against  runtime_library_dirs  [string] list of directories to search
for C/C++ libraries at run time (for shared extensions, this is when the
extension is loaded)  extra_objects  [string] list of extra files to link
with (eg. object files not implied by &#8216;sources&#8217;, static library that must be
explicitly specified, binary resource files, etc.)  extra_compile_args
[string] any extra platform- and compiler-specific information to use when
compiling the source files in &#8216;sources&#8217;. For platforms and compilers where
&#8220;command line&#8221; makes sense, this is typically a list of command-line
arguments, but for other platforms it could be anything.  extra_link_args
[string] any extra platform- and compiler-specific information to use when
linking object files together to create the extension (or to create a new
static Python interpreter). Similar interpretation as for
&#8216;extra_compile_args&#8217;.  export_symbols  [string] list of symbols to be
exported from a shared extension. Not used on all platforms, and not
generally necessary for Python extensions, which typically export exactly one
symbol: &#8220;init&#8221; + extension_name.</p>
<div class="section" id="keyword-option-examples">
<h4><a class="toc-backref" href="#id21">Keyword Option Examples</a><a class="headerlink" href="#keyword-option-examples" title="Permalink to this headline">¶</a></h4>
<p>We&#8217;ll walk through several examples here to demonstrate the behavior of
<tt class="docutils literal"><span class="pre">inline</span></tt> and also how the various arguments are used. In the simplest
(most) cases, <tt class="docutils literal"><span class="pre">code</span></tt> and <tt class="docutils literal"><span class="pre">arg_names</span></tt> are the only arguments that need to
be specified. Here&#8217;s a simple example run on Windows machine that has
Microsoft VC++ installed.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">weave</span> <span class="kn">import</span> <span class="n">inline</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s">&#39;string&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">code</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="gp">... </span><span class="s">       int l = a.length();</span>
<span class="gp">... </span><span class="s">       return_val = Py::new_reference_to(Py::Int(l));</span>
<span class="gp">... </span><span class="s">       &quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="go"> sc_86e98826b65b047ffd2cd5f479c627f12.cpp</span>
<span class="go">Creating</span>
<span class="go">   library C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\sc_86e98826b65b047ffd2cd5f479c627f12.lib</span>
<span class="go">and object C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\sc_86e98826b65b047ff</span>
<span class="go">d2cd5f479c627f12.exp</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="go">6</span>
</pre></div>
</div>
<p>When <tt class="docutils literal"><span class="pre">inline</span></tt> is first run, you&#8217;ll notice that pause and some trash printed
to the screen. The &#8220;trash&#8221; is actually part of the compiler&#8217;s output that
distutils does not supress. The name of the extension file,
<tt class="docutils literal"><span class="pre">sc_bighonkingnumber.cpp</span></tt>, is generated from the SHA-256 check sum of the
C/C++ code fragment. On Unix or windows machines with only gcc installed, the
trash will not appear. On the second call, the code fragment is not compiled
since it already exists, and only the answer is returned. Now kill the
interpreter and restart, and run the same code with a different string.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">weave</span> <span class="kn">import</span> <span class="n">inline</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s">&#39;a longer string&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">code</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="gp">... </span><span class="s">       int l = a.length();</span>
<span class="gp">... </span><span class="s">       return_val = Py::new_reference_to(Py::Int(l));</span>
<span class="gp">... </span><span class="s">       &quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="go">15</span>
</pre></div>
</div>
<p>Notice this time, <tt class="docutils literal"><span class="pre">inline()</span></tt> did not recompile the code because it found
the compiled function in the persistent catalog of functions. There is a
short pause as it looks up and loads the function, but it is much shorter
than compiling would require.</p>
<p>You can specify the local and global dictionaries if you&#8217;d like (much like
<tt class="docutils literal"><span class="pre">exec</span></tt> or <tt class="docutils literal"><span class="pre">eval()</span></tt> in Python), but if they aren&#8217;t specified, the
&#8220;expected&#8221; ones are used &#8211; i.e. the ones from the function that called
<tt class="docutils literal"><span class="pre">inline()</span></tt>. This is accomplished through a little call frame trickery.
Here is an example where the local_dict is specified using the same code
example from above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s">&#39;a longer string&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="s">&#39;an even  longer string&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span><span class="n">b</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="go">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">],</span><span class="n">my_dict</span><span class="p">)</span>
<span class="go">21</span>
</pre></div>
</div>
<p>Everytime, the <tt class="docutils literal"><span class="pre">code</span></tt> is changed, <tt class="docutils literal"><span class="pre">inline</span></tt> does a recompile. However,
changing any of the other options in inline does not force a recompile. The
<tt class="docutils literal"><span class="pre">force</span></tt> option was added so that one could force a recompile when tinkering
with other variables. In practice, it is just as easy to change the <tt class="docutils literal"><span class="pre">code</span></tt>
by a single character (like adding a space some place) to force the
recompile.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It also might be nice to add some methods for purging the
cache and on disk catalogs.</p>
</div>
<p>I use <tt class="docutils literal"><span class="pre">verbose</span></tt> sometimes for debugging. When set to 2, it&#8217;ll output all
the information (including the name of the .cpp file) that you&#8217;d expect from
running a make file. This is nice if you need to examine the generated code
to see where things are going haywire. Note that error messages from failed
compiles are printed to the screen even if <tt class="docutils literal"><span class="pre">verbose</span></tt> is set to 0.</p>
<p>The following example demonstrates using gcc instead of the standard msvc
compiler on windows using same code fragment as above. Because the example
has already been compiled, the <tt class="docutils literal"><span class="pre">force=1</span></tt> flag is needed to make
<tt class="docutils literal"><span class="pre">inline()</span></tt> ignore the previously compiled version and recompile using gcc.
The verbose flag is added to show what is printed out:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;inline(code,[&#39;a&#39;],compiler=&#39;gcc&#39;,verbose=2,force=1)</span>
<span class="go">running build_ext</span>
<span class="go">building &#39;sc_86e98826b65b047ffd2cd5f479c627f13&#39; extension</span>
<span class="go">c:\gcc-2.95.2\bin\g++.exe -mno-cygwin -mdll -O2 -w -Wstrict-prototypes -IC:</span>
<span class="go">\home\ej\wrk\scipy\weave -IC:\Python21\Include -c C:\DOCUME~1\eric\LOCAL</span>
<span class="go">S~1\Temp\python21_compiled\sc_86e98826b65b047ffd2cd5f479c627f13.cpp</span>
<span class="go">-o C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\sc_86e98826b65b04ffd2cd5f479c627f13.o</span>
<span class="go">skipping C:\home\ej\wrk\scipy\weave\CXX\cxxextensions.c</span>
<span class="go">(C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\cxxextensions.o up-to-date)</span>
<span class="go">skipping C:\home\ej\wrk\scipy\weave\CXX\cxxsupport.cxx</span>
<span class="go">(C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\cxxsupport.o up-to-date)</span>
<span class="go">skipping C:\home\ej\wrk\scipy\weave\CXX\IndirectPythonInterface.cxx</span>
<span class="go">(C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\indirectpythoninterface.o up-to-date)</span>
<span class="go">skipping C:\home\ej\wrk\scipy\weave\CXX\cxx_extensions.cxx</span>
<span class="go">(C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\cxx_extensions.o</span>
<span class="go">up-to-date)</span>
<span class="go">writing C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\sc_86e98826b65b047ffd2cd5f479c627f13.def</span>
<span class="go">c:\gcc-2.95.2\bin\dllwrap.exe --driver-name g++ -mno-cygwin</span>
<span class="go">-mdll -static --output-lib</span>
<span class="go">C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\libsc_86e98826b65b047ffd2cd5f479c627f13.a --def</span>
<span class="go">C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\sc_86e98826b65b047ffd2cd5f479c627f13.def</span>
<span class="go">-sC:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\sc_86e98826b65b047ffd2cd5f479c627f13.o</span>
<span class="go">C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\cxxextensions.o</span>
<span class="go">C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\cxxsupport.o</span>
<span class="go">C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\indirectpythoninterface.o</span>
<span class="go">C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\temp\Release\cxx_extensions.o -LC:\Python21\libs</span>
<span class="go">-lpython21 -o</span>
<span class="go">C:\DOCUME~1\eric\LOCALS~1\Temp\python21_compiled\sc_86e98826b65b047ffd2cd5f479c627f13.pyd</span>
<span class="go">15</span>
</pre></div>
</div>
<p>That&#8217;s quite a bit of output. <tt class="docutils literal"><span class="pre">verbose=1</span></tt> just prints the compile time.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;inline(code,[&#39;a&#39;],compiler=&#39;gcc&#39;,verbose=1,force=1)</span>
<span class="go">Compiling code...</span>
<span class="go">finished compiling (sec):  6.00800001621</span>
<span class="go">15</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">I&#8217;ve only used the <tt class="docutils literal"><span class="pre">compiler</span></tt> option for switching between &#8216;msvc&#8217;
and &#8216;gcc&#8217; on windows. It may have use on Unix also, but I don&#8217;t know yet.</p>
</div>
<p>The <tt class="docutils literal"><span class="pre">support_code</span></tt> argument is likely to be used a lot. It allows you to
specify extra code fragments such as function, structure or class definitions
that you want to use in the <tt class="docutils literal"><span class="pre">code</span></tt> string. Note that changes to
<tt class="docutils literal"><span class="pre">support_code</span></tt> do <em>not</em> force a recompile. The catalog only relies on
<tt class="docutils literal"><span class="pre">code</span></tt> (for performance reasons) to determine whether recompiling is
necessary. So, if you make a change to support_code, you&#8217;ll need to alter
<tt class="docutils literal"><span class="pre">code</span></tt> in some way or use the <tt class="docutils literal"><span class="pre">force</span></tt> argument to get the code to
recompile. I usually just add some inocuous whitespace to the end of one of
the lines in <tt class="docutils literal"><span class="pre">code</span></tt> somewhere. Here&#8217;s an example of defining a separate
method for calculating the string length:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">weave</span> <span class="kn">import</span> <span class="n">inline</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s">&#39;a longer string&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">support_code</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="gp">... </span><span class="s">               PyObject* length(Py::String a)</span>
<span class="gp">... </span><span class="s">               {</span>
<span class="gp">... </span><span class="s">                   int l = a.length();</span>
<span class="gp">... </span><span class="s">                   return Py::new_reference_to(Py::Int(l));</span>
<span class="gp">... </span><span class="s">               }</span>
<span class="gp">... </span><span class="s">               &quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inline</span><span class="p">(</span><span class="s">&quot;return_val = length(a);&quot;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">],</span>
<span class="gp">... </span>       <span class="n">support_code</span> <span class="o">=</span> <span class="n">support_code</span><span class="p">)</span>
<span class="go">15</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">customize</span></tt> is a left over from a previous way of specifying compiler
options. It is a <tt class="docutils literal"><span class="pre">custom_info</span></tt> object that can specify quite a bit of
information about how a file is compiled. These <tt class="docutils literal"><span class="pre">info</span></tt> objects are the
standard way of defining compile information for type conversion classes.
However, I don&#8217;t think they are as handy here, especially since we&#8217;ve exposed
all the keyword arguments that distutils can handle. Between these keywords,
and the <tt class="docutils literal"><span class="pre">support_code</span></tt> option, I think <tt class="docutils literal"><span class="pre">customize</span></tt> may be obsolete. We&#8217;ll
see if anyone cares to use it. If not, it&#8217;ll get axed in the next version.</p>
<p>The <tt class="docutils literal"><span class="pre">type_factories</span></tt> variable is important to people who want to customize
the way arguments are converted from Python to C. We&#8217;ll talk about this in
the next chapter <strong>xx</strong> of this document when we discuss type conversions.</p>
<p><tt class="docutils literal"><span class="pre">auto_downcast</span></tt> handles one of the big type conversion issues that is
common when using NumPy arrays in conjunction with Python scalar values. If
you have an array of single precision values and multiply that array by a
Python scalar, the result is upcast to a double precision array because the
scalar value is double precision. This is not usually the desired behavior
because it can double your memory usage. <tt class="docutils literal"><span class="pre">auto_downcast</span></tt> goes some distance
towards changing the casting precedence of arrays and scalars. If your only
using single precision arrays, it will automatically downcast all scalar
values from double to single precision when they are passed into the C++
code. This is the default behavior. If you want all values to keep there
default type, set <tt class="docutils literal"><span class="pre">auto_downcast</span></tt> to 0.</p>
</div>
<div class="section" id="returning-values">
<h4><a class="toc-backref" href="#id22">Returning Values</a><a class="headerlink" href="#returning-values" title="Permalink to this headline">¶</a></h4>
<p>Python variables in the local and global scope transfer seemlessly from
Python into the C++ snippets. And, if <tt class="docutils literal"><span class="pre">inline</span></tt> were to completely live up
to its name, any modifications to variables in the C++ code would be
reflected in the Python variables when control was passed back to Python. For
example, the desired behavior would be something like:</p>
<div class="highlight-python"><pre># THIS DOES NOT WORK
&gt;&gt;&gt; a = 1
&gt;&gt;&gt; weave.inline("a++;",['a'])
&gt;&gt;&gt; a
2</pre>
</div>
<p>Instead you get:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="s">&quot;a++;&quot;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Variables are passed into C++ as if you are calling a Python function.
Python&#8217;s calling convention is sometimes called &#8220;pass by assignment&#8221;. This
means its as if a <tt class="docutils literal"><span class="pre">c_a</span> <span class="pre">=</span> <span class="pre">a</span></tt> assignment is made right before <tt class="docutils literal"><span class="pre">inline</span></tt> call
is made and the <tt class="docutils literal"><span class="pre">c_a</span></tt> variable is used within the C++ code. Thus, any
changes made to <tt class="docutils literal"><span class="pre">c_a</span></tt> are not reflected in Python&#8217;s <tt class="docutils literal"><span class="pre">a</span></tt> variable. Things
do get a little more confusing, however, when looking at variables with
mutable types. Changes made in C++ to the contents of mutable types <em>are</em>
reflected in the Python variables.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="s">&quot;PyList_SetItem(a.ptr(),0,PyInt_FromLong(3));&quot;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">[3, 2]</span>
</pre></div>
</div>
<p>So modifications to the contents of mutable types in C++ are seen when
control is returned to Python. Modifications to immutable types such as
tuples, strings, and numbers do not alter the Python variables. If you need
to make changes to an immutable variable, you&#8217;ll need to assign the new value
to the &#8220;magic&#8221; variable <tt class="docutils literal"><span class="pre">return_val</span></tt> in C++. This value is returned by the
<tt class="docutils literal"><span class="pre">inline()</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="s">&quot;return_val = Py::new_reference_to(Py::Int(a+1));&quot;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">return_val</span></tt> variable can also be used to return newly created values.
This is possible by returning a tuple. The following trivial example
illustrates how this can be done:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># python version</span>
<span class="k">def</span> <span class="nf">multi_return</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;2nd&#39;</span>

<span class="c"># C version.</span>
<span class="k">def</span> <span class="nf">c_multi_return</span><span class="p">():</span>
    <span class="n">code</span> <span class="o">=</span>  <span class="s">&quot;&quot;&quot;</span>
<span class="s">              py::tuple results(2);</span>
<span class="s">              results[0] = 1;</span>
<span class="s">              results[1] = &quot;2nd&quot;;</span>
<span class="s">              return_val = results;</span>
<span class="s">            &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">inline_tools</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
<p>The example is available in <tt class="docutils literal"><span class="pre">examples/tuple_return.py</span></tt>. It also has the
dubious honor of demonstrating how much <tt class="docutils literal"><span class="pre">inline()</span></tt> can slow things down.
The C version here is about 7-10 times slower than the Python version. Of
course, something so trivial has no reason to be written in C anyway.</p>
<div class="section" id="the-issue-with-locals">
<h5><a class="toc-backref" href="#id23">The issue with <tt class="docutils literal"><span class="pre">locals()</span></tt></a><a class="headerlink" href="#the-issue-with-locals" title="Permalink to this headline">¶</a></h5>
<p><tt class="docutils literal"><span class="pre">inline</span></tt> passes the <tt class="docutils literal"><span class="pre">locals()</span></tt> and <tt class="docutils literal"><span class="pre">globals()</span></tt> dictionaries from Python
into the C++ function from the calling function. It extracts the variables
that are used in the C++ code from these dictionaries, converts then to C++
variables, and then calculates using them. It seems like it would be trivial,
then, after the calculations were finished to then insert the new values back
into the <tt class="docutils literal"><span class="pre">locals()</span></tt> and <tt class="docutils literal"><span class="pre">globals()</span></tt> dictionaries so that the modified
values were reflected in Python. Unfortunately, as pointed out by the Python
manual, the locals() dictionary is not writable.</p>
<p>I suspect <tt class="docutils literal"><span class="pre">locals()</span></tt> is not writable because there are some optimizations
done to speed lookups of the local namespace. I&#8217;m guessing local lookups
don&#8217;t always look at a dictionary to find values. Can someone &#8220;in the know&#8221;
confirm or correct this? Another thing I&#8217;d like to know is whether there is a
way to write to the local namespace of another stack frame from C/C++. If so,
it would be possible to have some clean up code in compiled functions that
wrote final values of variables in C++ back to the correct Python stack
frame. I think this goes a long way toward making <tt class="docutils literal"><span class="pre">inline</span></tt> truely live up
to its name. I don&#8217;t think we&#8217;ll get to the point of creating variables in
Python for variables created in C &#8211; although I suppose with a C/C++ parser
you could do that also.</p>
</div>
</div>
<div class="section" id="a-quick-look-at-the-code">
<h4><a class="toc-backref" href="#id24">A quick look at the code</a><a class="headerlink" href="#a-quick-look-at-the-code" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">weave</span></tt> generates a C++ file holding an extension function for each
<tt class="docutils literal"><span class="pre">inline</span></tt> code snippet. These file names are generated using from the
SHA-256 signature of the code snippet and saved to a location specified by the
PYTHONCOMPILED environment variable (discussed later). The cpp files are
generally about 200-400 lines long and include quite a few functions to
support type conversions, etc. However, the actual compiled function is
pretty simple. Below is the familiar <tt class="docutils literal"><span class="pre">printf</span></tt> example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">weave</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="s">&#39;printf(&quot;</span><span class="si">%d</span><span class="se">\\</span><span class="s">n&quot;,a);&#39;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="go">1</span>
</pre></div>
</div>
<p>And here is the extension function generated by <tt class="docutils literal"><span class="pre">inline</span></tt>:</p>
<div class="highlight-python"><pre>static PyObject* compiled_func(PyObject*self, PyObject* args)
{
    py::object return_val;
    int exception_occured = 0;
    PyObject *py__locals = NULL;
    PyObject *py__globals = NULL;
    PyObject *py_a;
    py_a = NULL;

    if(!PyArg_ParseTuple(args,"OO:compiled_func",&amp;py__locals,&amp;py__globals))
        return NULL;
    try
    {
        PyObject* raw_locals = py_to_raw_dict(py__locals,"_locals");
        PyObject* raw_globals = py_to_raw_dict(py__globals,"_globals");
        /* argument conversion code */
        py_a = get_variable("a",raw_locals,raw_globals);
        int a = convert_to_int(py_a,"a");
        /* inline code */
        /* NDARRAY API VERSION 90907 */
        printf("%d\n",a);    /*I would like to fill in changed locals and globals here...*/
    }
    catch(...)
    {
        return_val =  py::object();
        exception_occured = 1;
    }
    /* cleanup code */
    if(!(PyObject*)return_val &amp;&amp; !exception_occured)
    {
        return_val = Py_None;
    }
    return return_val.disown();
}</pre>
</div>
<p>Every inline function takes exactly two arguments &#8211; the local and global
dictionaries for the current scope. All variable values are looked up out of
these dictionaries. The lookups, along with all <tt class="docutils literal"><span class="pre">inline</span></tt> code execution,
are done within a C++ <tt class="docutils literal"><span class="pre">try</span></tt> block. If the variables aren&#8217;t found, or there
is an error converting a Python variable to the appropriate type in C++, an
exception is raised. The C++ exception is automatically converted to a Python
exception by SCXX and returned to Python. The <tt class="docutils literal"><span class="pre">py_to_int()</span></tt> function
illustrates how the conversions and exception handling works. py_to_int first
checks that the given PyObject* pointer is not NULL and is a Python integer.
If all is well, it calls the Python API to convert the value to an <tt class="docutils literal"><span class="pre">int</span></tt>.
Otherwise, it calls <tt class="docutils literal"><span class="pre">handle_bad_type()</span></tt> which gathers information about
what went wrong and then raises a SCXX TypeError which returns to Python as a
TypeError.</p>
<div class="highlight-python"><pre>int py_to_int(PyObject* py_obj,char* name)
{
    if (!py_obj || !PyInt_Check(py_obj))
        handle_bad_type(py_obj,"int", name);
    return (int) PyInt_AsLong(py_obj);
}</pre>
</div>
<div class="highlight-python"><pre>void handle_bad_type(PyObject* py_obj, char* good_type, char* var_name)
{
    char msg[500];
    sprintf(msg,"received '%s' type instead of '%s' for variable '%s'",
            find_type(py_obj),good_type,var_name);
    throw Py::TypeError(msg);
}

char* find_type(PyObject* py_obj)
{
    if(py_obj == NULL) return "C NULL value";
    if(PyCallable_Check(py_obj)) return "callable";
    if(PyString_Check(py_obj)) return "string";
    if(PyInt_Check(py_obj)) return "int";
    if(PyFloat_Check(py_obj)) return "float";
    if(PyDict_Check(py_obj)) return "dict";
    if(PyList_Check(py_obj)) return "list";
    if(PyTuple_Check(py_obj)) return "tuple";
    if(PyFile_Check(py_obj)) return "file";
    if(PyModule_Check(py_obj)) return "module";

    //should probably do more interagation (and thinking) on these.
    if(PyCallable_Check(py_obj) &amp;&amp; PyInstance_Check(py_obj)) return "callable";
    if(PyInstance_Check(py_obj)) return "instance";
    if(PyCallable_Check(py_obj)) return "callable";
    return "unknown type";
}</pre>
</div>
<p>Since the <tt class="docutils literal"><span class="pre">inline</span></tt> is also executed within the <tt class="docutils literal"><span class="pre">try/catch</span></tt> block, you can
use CXX exceptions within your code. It is usually a bad idea to directly
<tt class="docutils literal"><span class="pre">return</span></tt> from your code, even if an error occurs. This skips the clean up
section of the extension function. In this simple example, there isn&#8217;t any
clean up code, but in more complicated examples, there may be some reference
counting that needs to be taken care of here on converted variables. To avoid
this, either uses exceptions or set <tt class="docutils literal"><span class="pre">return_val</span></tt> to NULL and use
<tt class="docutils literal"><span class="pre">if/then's</span></tt> to skip code after errors.</p>
</div>
</div>
<div class="section" id="technical-details">
<h3><a class="toc-backref" href="#id25">Technical Details</a><a class="headerlink" href="#technical-details" title="Permalink to this headline">¶</a></h3>
<p>There are several main steps to using C/C++ code within Python:</p>
<ol class="arabic simple">
<li>Type conversion</li>
<li>Generating C/C++ code</li>
<li>Compile the code to an extension module</li>
<li>Catalog (and cache) the function for future use</li>
</ol>
<p>Items 1 and 2 above are related, but most easily discussed separately. Type
conversions are customizable by the user if needed. Understanding them is
pretty important for anything beyond trivial uses of <tt class="docutils literal"><span class="pre">inline</span></tt>. Generating
the C/C++ code is handled by <tt class="docutils literal"><span class="pre">ext_function</span></tt> and <tt class="docutils literal"><span class="pre">ext_module</span></tt> classes and
. For the most part, compiling the code is handled by distutils. Some
customizations were needed, but they were relatively minor and do not require
changes to distutils itself. Cataloging is pretty simple in concept, but
surprisingly required the most code to implement (and still likely needs some
work). So, this section covers items 1 and 4 from the list. Item 2 is covered
later in the chapter covering the <tt class="docutils literal"><span class="pre">ext_tools</span></tt> module, and distutils is
covered by a completely separate document xxx.</p>
</div>
<div class="section" id="passing-variables-in-out-of-the-c-c-code">
<h3><a class="toc-backref" href="#id26">Passing Variables in/out of the C/C++ code</a><a class="headerlink" href="#passing-variables-in-out-of-the-c-c-code" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Passing variables into the C code is pretty straight forward, but
there are subtlties to how variable modifications in C are returned to
Python. see <a class="reference internal" href="#returning-values">Returning Values</a> for a more thorough discussion of this issue.</p>
</div>
</div>
<div class="section" id="type-conversions">
<h3><a class="toc-backref" href="#id27">Type Conversions</a><a class="headerlink" href="#type-conversions" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Maybe <tt class="docutils literal"><span class="pre">xxx_converter</span></tt> instead of <tt class="docutils literal"><span class="pre">xxx_specification</span></tt> is a more
descriptive name. Might change in future version?</p>
</div>
<p>By default, <tt class="docutils literal"><span class="pre">inline()</span></tt> makes the following type conversions between Python
and C++ types.</p>
<table border="1" class="docutils">
<caption>Default Data Type Conversions</caption>
<colgroup>
<col width="48%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Python</th>
<th class="head">C++</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>int</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>float</td>
<td>double</td>
</tr>
<tr class="row-even"><td>complex</td>
<td>std::complex</td>
</tr>
<tr class="row-odd"><td>string</td>
<td>py::string</td>
</tr>
<tr class="row-even"><td>list</td>
<td>py::list</td>
</tr>
<tr class="row-odd"><td>dict</td>
<td>py::dict</td>
</tr>
<tr class="row-even"><td>tuple</td>
<td>py::tuple</td>
</tr>
<tr class="row-odd"><td>file</td>
<td>FILE*</td>
</tr>
<tr class="row-even"><td>callable</td>
<td>py::object</td>
</tr>
<tr class="row-odd"><td>instance</td>
<td>py::object</td>
</tr>
<tr class="row-even"><td>numpy.ndarray</td>
<td>PyArrayObject*</td>
</tr>
<tr class="row-odd"><td>wxXXX</td>
<td>wxXXX*</td>
</tr>
</tbody>
</table>
<p>The <tt class="docutils literal"><span class="pre">Py::</span></tt> namespace is defined by the SCXX library which has C++ class
equivalents for many Python types. <tt class="docutils literal"><span class="pre">std::</span></tt> is the namespace of the standard
library in C++.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>I haven&#8217;t figured out how to handle <tt class="docutils literal"><span class="pre">long</span> <span class="pre">int</span></tt> yet (I think they
are currenlty converted to int - - check this).</li>
<li>Hopefully VTK will be added to the list soon</li>
</ul>
</div>
<p>Python to C++ conversions fill in code in several locations in the generated
<tt class="docutils literal"><span class="pre">inline</span></tt> extension function. Below is the basic template for the function.
This is actually the exact code that is generated by calling
<tt class="docutils literal"><span class="pre">weave.inline(&quot;&quot;)</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">/*</span> <span class="pre">inline</span> <span class="pre">code</span> <span class="pre">*/</span></tt> section is filled with the code passed to the
<tt class="docutils literal"><span class="pre">inline()</span></tt> function call. The <tt class="docutils literal"><span class="pre">/*argument</span> <span class="pre">conversion</span> <span class="pre">code*/</span></tt> and <tt class="docutils literal"><span class="pre">/*</span>
<span class="pre">cleanup</span> <span class="pre">code</span> <span class="pre">*/</span></tt> sections are filled with code that handles conversion from
Python to C++ types and code that deallocates memory or manipulates reference
counts before the function returns. The following sections demonstrate how
these two areas are filled in by the default conversion methods. * Note: I&#8217;m
not sure I have reference counting correct on a few of these. The only thing
I increase/decrease the ref count on is NumPy arrays. If you see an issue,
please let me know.</p>
<div class="section" id="numpy-argument-conversion">
<h4><a class="toc-backref" href="#id28">NumPy Argument Conversion</a><a class="headerlink" href="#numpy-argument-conversion" title="Permalink to this headline">¶</a></h4>
<p>Integer, floating point, and complex arguments are handled in a very similar
fashion. Consider the following inline function that has a single integer
variable passed in:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inline</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The argument conversion code inserted for <tt class="docutils literal"><span class="pre">a</span></tt> is:</p>
<div class="highlight-python"><pre>/* argument conversion code */
int a = py_to_int (get_variable("a",raw_locals,raw_globals),"a");</pre>
</div>
<p><tt class="docutils literal"><span class="pre">get_variable()</span></tt> reads the variable <tt class="docutils literal"><span class="pre">a</span></tt> from the local and global
namespaces. <tt class="docutils literal"><span class="pre">py_to_int()</span></tt> has the following form:</p>
<div class="highlight-python"><pre>static int py_to_int(PyObject* py_obj,char* name)
{
    if (!py_obj || !PyInt_Check(py_obj))
        handle_bad_type(py_obj,"int", name);
    return (int) PyInt_AsLong(py_obj);
}</pre>
</div>
<p>Similarly, the float and complex conversion routines look like:</p>
<div class="highlight-python"><pre>static double py_to_float(PyObject* py_obj,char* name)
{
    if (!py_obj || !PyFloat_Check(py_obj))
        handle_bad_type(py_obj,"float", name);
    return PyFloat_AsDouble(py_obj);
}

static std::complex py_to_complex(PyObject* py_obj,char* name)
{
    if (!py_obj || !PyComplex_Check(py_obj))
        handle_bad_type(py_obj,"complex", name);
    return std::complex(PyComplex_RealAsDouble(py_obj),
                                PyComplex_ImagAsDouble(py_obj));
}</pre>
</div>
<p>NumPy conversions do not require any clean up code.</p>
</div>
<div class="section" id="string-list-tuple-and-dictionary-conversion">
<h4><a class="toc-backref" href="#id29">String, List, Tuple, and Dictionary Conversion</a><a class="headerlink" href="#string-list-tuple-and-dictionary-conversion" title="Permalink to this headline">¶</a></h4>
<p>Strings, Lists, Tuples and Dictionary conversions are all converted to SCXX
types by default. For the following code,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inline</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The argument conversion code inserted for <tt class="docutils literal"><span class="pre">a</span></tt> is:</p>
<div class="highlight-python"><pre>/* argument conversion code */
Py::List a = py_to_list(get_variable("a",raw_locals,raw_globals),"a");</pre>
</div>
<p><tt class="docutils literal"><span class="pre">get_variable()</span></tt> reads the variable <tt class="docutils literal"><span class="pre">a</span></tt> from the local and global
namespaces. <tt class="docutils literal"><span class="pre">py_to_list()</span></tt> and its friends have the following form:</p>
<div class="highlight-python"><pre>static Py::List py_to_list(PyObject* py_obj,char* name)
{
    if (!py_obj || !PyList_Check(py_obj))
        handle_bad_type(py_obj,"list", name);
    return Py::List(py_obj);
}

static Py::String py_to_string(PyObject* py_obj,char* name)
{
    if (!PyString_Check(py_obj))
        handle_bad_type(py_obj,"string", name);
    return Py::String(py_obj);
}

static Py::Dict py_to_dict(PyObject* py_obj,char* name)
{
    if (!py_obj || !PyDict_Check(py_obj))
        handle_bad_type(py_obj,"dict", name);
    return Py::Dict(py_obj);
}

static Py::Tuple py_to_tuple(PyObject* py_obj,char* name)
{
    if (!py_obj || !PyTuple_Check(py_obj))
        handle_bad_type(py_obj,"tuple", name);
    return Py::Tuple(py_obj);
}</pre>
</div>
<p>SCXX handles reference counts on for strings, lists, tuples, and
dictionaries, so clean up code isn&#8217;t necessary.</p>
</div>
<div class="section" id="file-conversion">
<h4><a class="toc-backref" href="#id30">File Conversion</a><a class="headerlink" href="#file-conversion" title="Permalink to this headline">¶</a></h4>
<p>For the following code,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;bob&quot;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inline</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The argument conversion code is:</p>
<div class="highlight-python"><pre>/* argument conversion code */
PyObject* py_a = get_variable("a",raw_locals,raw_globals);
FILE* a = py_to_file(py_a,"a");</pre>
</div>
<p><tt class="docutils literal"><span class="pre">get_variable()</span></tt> reads the variable <tt class="docutils literal"><span class="pre">a</span></tt> from the local and global
namespaces. <tt class="docutils literal"><span class="pre">py_to_file()</span></tt> converts PyObject* to a FILE* and increments the
reference count of the PyObject*:</p>
<div class="highlight-python"><pre>FILE* py_to_file(PyObject* py_obj, char* name)
{
    if (!py_obj || !PyFile_Check(py_obj))
        handle_bad_type(py_obj,"file", name);

    Py_INCREF(py_obj);
    return PyFile_AsFile(py_obj);
}</pre>
</div>
<p>Because the PyObject* was incremented, the clean up code needs to decrement
the counter</p>
<div class="highlight-python"><pre>/* cleanup code */
Py_XDECREF(py_a);</pre>
</div>
<p>Its important to understand that file conversion only works on actual files
&#8211; i.e. ones created using the <tt class="docutils literal"><span class="pre">open()</span></tt> command in Python. It does not
support converting arbitrary objects that support the file interface into C
<tt class="docutils literal"><span class="pre">FILE*</span></tt> pointers. This can affect many things. For example, in initial
<tt class="docutils literal"><span class="pre">printf()</span></tt> examples, one might be tempted to solve the problem of C and
Python IDE&#8217;s (PythonWin, PyCrust, etc.) writing to different stdout and
stderr by using <tt class="docutils literal"><span class="pre">fprintf()</span></tt> and passing in <tt class="docutils literal"><span class="pre">sys.stdout</span></tt> and
<tt class="docutils literal"><span class="pre">sys.stderr</span></tt>. For example, instead of</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="s">&#39;printf(&quot;hello</span><span class="se">\\</span><span class="s">n&quot;);&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>You might try:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="s">&#39;fprintf(buf,&quot;hello</span><span class="se">\\</span><span class="s">n&quot;);&#39;</span><span class="p">,[</span><span class="s">&#39;buf&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>This will work as expected from a standard python interpreter, but in
PythonWin, the following occurs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="s">&#39;fprintf(buf,&quot;hello</span><span class="se">\\</span><span class="s">n&quot;);&#39;</span><span class="p">,[</span><span class="s">&#39;buf&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The traceback tells us that <tt class="docutils literal"><span class="pre">inline()</span></tt> was unable to convert &#8216;buf&#8217; to a C++
type (If instance conversion was implemented, the error would have occurred
at runtime instead). Why is this? Let&#8217;s look at what the <tt class="docutils literal"><span class="pre">buf</span></tt> object
really is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span>
<span class="go">pywin.framework.interact.InteractiveView instance at 00EAD014</span>
</pre></div>
</div>
<p>PythonWin has reassigned <tt class="docutils literal"><span class="pre">sys.stdout</span></tt> to a special object that implements
the Python file interface. This works great in Python, but since the special
object doesn&#8217;t have a FILE* pointer underlying it, <tt class="docutils literal"><span class="pre">fprintf</span></tt> doesn&#8217;t know
what to do with it (well this will be the problem when instance conversion is
implemented...).</p>
</div>
<div class="section" id="callable-instance-and-module-conversion">
<h4><a class="toc-backref" href="#id31">Callable, Instance, and Module Conversion</a><a class="headerlink" href="#callable-instance-and-module-conversion" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Need to look into how ref counts should be handled. Also, Instance and
Module conversion are not currently implemented.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">a</span><span class="p">():</span>
<span class="go">    pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inline</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Callable and instance variables are converted to PyObject*. Nothing is done
to their reference counts.</p>
<div class="highlight-python"><pre>/* argument conversion code */
PyObject* a = py_to_callable(get_variable("a",raw_locals,raw_globals),"a");</pre>
</div>
<p><tt class="docutils literal"><span class="pre">get_variable()</span></tt> reads the variable <tt class="docutils literal"><span class="pre">a</span></tt> from the local and global
namespaces. The <tt class="docutils literal"><span class="pre">py_to_callable()</span></tt> and <tt class="docutils literal"><span class="pre">py_to_instance()</span></tt> don&#8217;t currently
increment the ref count.</p>
<div class="highlight-python"><pre>PyObject* py_to_callable(PyObject* py_obj, char* name)
{
    if (!py_obj || !PyCallable_Check(py_obj))
        handle_bad_type(py_obj,"callable", name);
    return py_obj;
}

PyObject* py_to_instance(PyObject* py_obj, char* name)
{
    if (!py_obj || !PyFile_Check(py_obj))
        handle_bad_type(py_obj,"instance", name);
    return py_obj;
}</pre>
</div>
<p>There is no cleanup code for callables, modules, or instances.</p>
</div>
<div class="section" id="customizing-conversions">
<h4><a class="toc-backref" href="#id32">Customizing Conversions</a><a class="headerlink" href="#customizing-conversions" title="Permalink to this headline">¶</a></h4>
<p>Converting from Python to C++ types is handled by <tt class="docutils literal"><span class="pre">xxx_specification</span></tt>
classes.  A type specification class actually serve in two related but
different roles.  The first is in determining whether a Python variable that
needs to be converted should be represented by the given class. The second is
as a code generator that generates C++ code needed to convert from Python to
C++ types for a specific variable.</p>
<p>When</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="s">&#39;printf(&quot;</span><span class="si">%d</span><span class="s">&quot;,a);&#39;</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>is called for the first time, the code snippet has to be compiled. In this
process, the variable &#8216;a&#8217; is tested against a list of type specifications
(the default list is stored in weave/ext_tools.py). The <em>first</em> specification
in the list is used to represent the variable.</p>
<p>Examples of <tt class="docutils literal"><span class="pre">xxx_specification</span></tt> are scattered throughout numerous
&#8220;xxx_spec.py&#8221; files in the <tt class="docutils literal"><span class="pre">weave</span></tt> package. Closely related to the
<tt class="docutils literal"><span class="pre">xxx_specification</span></tt> classes are <tt class="docutils literal"><span class="pre">yyy_info</span></tt> classes. These classes contain
compiler, header, and support code information necessary for including a
certain set of capabilities (such as blitz++ or CXX support) in a compiled
module. <tt class="docutils literal"><span class="pre">xxx_specification</span></tt> classes have one or more <tt class="docutils literal"><span class="pre">yyy_info</span></tt> classes
associated with them. If you&#8217;d like to define your own set of type
specifications, the current best route is to examine some of the existing
spec and info files. Maybe looking over sequence_spec.py and cxx_info.py are
a good place to start. After defining specification classes, you&#8217;ll need to
pass them into <tt class="docutils literal"><span class="pre">inline</span></tt> using the <tt class="docutils literal"><span class="pre">type_factories</span></tt> argument. A lot of
times you may just want to change how a specific variable type is
represented. Say you&#8217;d rather have Python strings converted to
<tt class="docutils literal"><span class="pre">std::string</span></tt> or maybe <tt class="docutils literal"><span class="pre">char*</span></tt> instead of using the CXX string object,
but would like all other type conversions to have default behavior. This
requires that a new specification class that handles strings is written and
then prepended to a list of the default type specifications. Since it is
closer to the front of the list, it effectively overrides the default string
specification. The following code demonstrates how this is done: ...</p>
</div>
</div>
<div class="section" id="the-catalog">
<h3><a class="toc-backref" href="#id33">The Catalog</a><a class="headerlink" href="#the-catalog" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">catalog.py</span></tt> has a class called <tt class="docutils literal"><span class="pre">catalog</span></tt> that helps keep track of
previously compiled functions. This prevents <tt class="docutils literal"><span class="pre">inline()</span></tt> and related
functions from having to compile functions everytime they are called.
Instead, catalog will check an in memory cache to see if the function has
already been loaded into python. If it hasn&#8217;t, then it starts searching
through persisent catalogs on disk to see if it finds an entry for the given
function. By saving information about compiled functions to disk, it isn&#8217;t
necessary to re-compile functions everytime you stop and restart the
interpreter. Functions are compiled once and stored for future use.</p>
<p>When <tt class="docutils literal"><span class="pre">inline(cpp_code)</span></tt> is called the following things happen:</p>
<ol class="arabic">
<li><p class="first">A fast local cache of functions is checked for the last function
called for <tt class="docutils literal"><span class="pre">cpp_code</span></tt>. If an entry for <tt class="docutils literal"><span class="pre">cpp_code</span></tt> doesn&#8217;t exist in
the cache or the cached function call fails (perhaps because the function
doesn&#8217;t have compatible types) then the next step is to check the
catalog.</p>
</li>
<li><p class="first">The catalog class also keeps an in-memory cache with a list of all
the functions compiled for <tt class="docutils literal"><span class="pre">cpp_code</span></tt>. If <tt class="docutils literal"><span class="pre">cpp_code</span></tt> has ever been
called, then this cache will be present (loaded from disk). If the cache
isn&#8217;t present, then it is loaded from disk.</p>
<p>If the cache is present, each function in the cache is called until
one is found that was compiled for the correct argument types. If none of
the functions work, a new function is compiled with the given argument
types. This function is written to the on-disk catalog as well as into
the in-memory cache.</p>
</li>
<li><p class="first">When a lookup for <tt class="docutils literal"><span class="pre">cpp_code</span></tt> fails, the catalog looks through the
on-disk function catalogs for the entries. The PYTHONCOMPILED variable
determines where to search for these catalogs and in what order. If
PYTHONCOMPILED is not present several platform dependent locations are
searched. All functions found for <tt class="docutils literal"><span class="pre">cpp_code</span></tt> in the path are loaded
into the in-memory cache with functions found earlier in the search path
closer to the front of the call list.</p>
<p>If the function isn&#8217;t found in the on-disk catalog, then the function
is compiled, written to the first writable directory in the
PYTHONCOMPILED path, and also loaded into the in-memory cache.</p>
</li>
</ol>
<div class="section" id="function-storage">
<h4><a class="toc-backref" href="#id34">Function Storage</a><a class="headerlink" href="#function-storage" title="Permalink to this headline">¶</a></h4>
<p>Function caches are stored as dictionaries where the key is the entire C++
code string and the value is either a single function (as in the &#8220;level 1&#8221;
cache) or a list of functions (as in the main catalog cache). On disk
catalogs are stored in the same manor using standard Python shelves.</p>
<p>Early on, there was a question as to whether md5 checksums of the C++ code
strings should be used instead of the actual code strings. I think this is
the route inline Perl took. Some (admittedly quick) tests of the md5 vs. the
entire string showed that using the entire string was at least a factor of 3
or 4 faster for Python. I think this is because it is more time consuming to
compute the md5 value than it is to do look-ups of long strings in the
dictionary. Look at the examples/md5_speed.py file for the test run.</p>
</div>
<div class="section" id="catalog-search-paths-and-the-pythoncompiled-variable">
<h4><a class="toc-backref" href="#id35">Catalog search paths and the PYTHONCOMPILED variable</a><a class="headerlink" href="#catalog-search-paths-and-the-pythoncompiled-variable" title="Permalink to this headline">¶</a></h4>
<p>The default location for catalog files on Unix is is ~/.pythonXX_compiled
where XX is version of Python being used. If this directory doesn&#8217;t exist, it
is created the first time a catalog is used. The directory must be writable.
If, for any reason it isn&#8217;t, then the catalog attempts to create a directory
based on your user id in the /tmp directory. The directory permissions are
set so that only you have access to the directory. If this fails, I think
you&#8217;re out of luck. I don&#8217;t think either of these should ever fail though. On
Windows, a directory called pythonXX_compiled is created in the user&#8217;s
temporary directory.</p>
<p>The actual catalog file that lives in this directory is a Python shelf with
a platform specific name such as &#8220;nt21compiled_catalog&#8221; so that multiple OSes
can share the same file systems without trampling on each other. Along with
the catalog file, the .cpp and .so or .pyd files created by inline will live
in this directory. The catalog file simply contains keys which are the C++
code strings with values that are lists of functions. The function lists
point at functions within these compiled modules. Each function in the lists
executes the same C++ code string, but compiled for different input
variables.</p>
<p>You can use the PYTHONCOMPILED environment variable to specify alternative
locations for compiled functions. On Unix this is a colon (&#8216;:&#8217;) separated
list of directories. On windows, it is a (&#8216;;&#8217;) separated list of directories.
These directories will be searched prior to the default directory for a
compiled function catalog. Also, the first writable directory in the list is
where all new compiled function catalogs, .cpp and .so or .pyd files are
written. Relative directory paths (&#8216;.&#8217; and &#8216;..&#8217;) should work fine in the
PYTHONCOMPILED variable as should environement variables.</p>
<p>There is a &#8220;special&#8221; path variable called MODULE that can be placed in the
PYTHONCOMPILED variable. It specifies that the compiled catalog should reside
in the same directory as the module that called it. This is useful if an
admin wants to build a lot of compiled functions during the build of a
package and then install them in site-packages along with the package. User&#8217;s
who specify MODULE in their PYTHONCOMPILED variable will have access to these
compiled functions. Note, however, that if they call the function with a set
of argument types that it hasn&#8217;t previously been built for, the new function
will be stored in their default directory (or some other writable directory
in the PYTHONCOMPILED path) because the user will not have write access to
the site-packages directory.</p>
<p>An example of using the PYTHONCOMPILED path on bash follows:</p>
<div class="highlight-python"><pre>PYTHONCOMPILED=MODULE:/some/path;export PYTHONCOMPILED;</pre>
</div>
<p>If you are using python21 on linux, and the module bob.py in site-packages
has a compiled function in it, then the catalog search order when calling
that function for the first time in a python session would be:</p>
<div class="highlight-python"><pre>/usr/lib/python21/site-packages/linuxpython_compiled
/some/path/linuxpython_compiled
~/.python21_compiled/linuxpython_compiled</pre>
</div>
<p>The default location is always included in the search path.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">hmmm. see a possible problem here. I should probably make a sub-
directory such as /usr/lib/python21/site-
packages/python21_compiled/linuxpython_compiled so that library files
compiled with python21 are tried to link with python22 files in some strange
scenarios. Need to check this.</p>
</div>
<p>The in-module cache (in <tt class="docutils literal"><span class="pre">weave.inline_tools</span></tt> reduces the overhead of
calling inline functions by about a factor of 2. It can be reduced a little
more for type loop calls where the same function is called over and over
again if the cache was a single value instead of a dictionary, but the
benefit is very small (less than 5%) and the utility is quite a bit less. So,
we&#8217;ll stick with a dictionary as the cache.</p>
</div>
</div>
</div>
<div class="section" id="blitz">
<h2><a class="toc-backref" href="#id36">Blitz</a><a class="headerlink" href="#blitz" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">most of this section is lifted from old documentation. It should be
pretty accurate, but there may be a few discrepancies.</p>
</div>
<p><tt class="docutils literal"><span class="pre">weave.blitz()</span></tt> compiles NumPy Python expressions for fast execution. For
most applications, compiled expressions should provide a factor of 2-10
speed-up over NumPy arrays. Using compiled expressions is meant to be as
unobtrusive as possible and works much like pythons exec statement. As an
example, the following code fragment takes a 5 point average of the 512x512
2d image, b, and stores it in array, a:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="o">*</span>  <span class="c"># or from NumPy import *</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="mi">512</span><span class="p">,</span><span class="mi">512</span><span class="p">),</span> <span class="n">Float64</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="mi">512</span><span class="p">,</span><span class="mi">512</span><span class="p">),</span> <span class="n">Float64</span><span class="p">)</span>
<span class="c"># ...do some stuff to fill in b...</span>
<span class="c"># now average</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> \
               <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">5.</span>
</pre></div>
</div>
<p>To compile the expression, convert the expression to a string by putting
quotes around it and then use <tt class="docutils literal"><span class="pre">weave.blitz</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">weave</span>
<span class="n">expr</span> <span class="o">=</span> <span class="s">&quot;a[1:-1,1:-1] =  (b[1:-1,1:-1] + b[2:,1:-1] + b[:-2,1:-1]&quot;</span> \
                      <span class="s">&quot;+ b[1:-1,2:] + b[1:-1,:-2]) / 5.&quot;</span>
<span class="n">weave</span><span class="o">.</span><span class="n">blitz</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
<p>The first time <tt class="docutils literal"><span class="pre">weave.blitz</span></tt> is run for a given expression and set of
arguements, C++ code that accomplishes the exact same task as the Python
expression is generated and compiled to an extension module. This can take up
to a couple of minutes depending on the complexity of the function.
Subsequent calls to the function are very fast. Futher, the generated module
is saved between program executions so that the compilation is only done once
for a given expression and associated set of array types. If the given
expression is executed with a new set of array types, the code most be
compiled again. This does not overwrite the previously compiled function &#8211;
both of them are saved and available for exectution.</p>
<p>The following table compares the run times for standard NumPy code and
compiled code for the 5 point averaging.</p>
<p>Method Run Time (seconds)
Standard NumPy 0.46349
blitz (1st time compiling) 78.95526
blitz (subsequent calls) 0.05843 (factor of 8 speedup)</p>
<p>These numbers are for a 512x512 double precision image run on a 400 MHz
Celeron processor under RedHat Linux 6.2.</p>
<p>Because of the slow compile times, its probably most effective to develop
algorithms as you usually do using the capabilities of scipy or the NumPy
module. Once the algorithm is perfected, put quotes around it and execute it
using <tt class="docutils literal"><span class="pre">weave.blitz</span></tt>. This provides the standard rapid prototyping strengths
of Python and results in algorithms that run close to that of hand coded C or
Fortran.</p>
<div class="section" id="id1">
<h3><a class="toc-backref" href="#id37">Requirements</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Currently, the <tt class="docutils literal"><span class="pre">weave.blitz</span></tt> has only been tested under Linux with
gcc-2.95-3 and on Windows with Mingw32 (2.95.2). Its compiler requirements
are pretty heavy duty (see the <a class="reference external" href="http://www.oonumerics.org/blitz/">blitz++ home page</a>), so it won&#8217;t work with
just any compiler. Particularly MSVC++ isn&#8217;t up to snuff. A number of other
compilers such as KAI++ will also work, but my suspicions are that gcc will
get the most use.</p>
</div>
<div class="section" id="limitations">
<h3><a class="toc-backref" href="#id38">Limitations</a><a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p class="first">Currently, <tt class="docutils literal"><span class="pre">weave.blitz</span></tt> handles all standard mathematical operators
except for the ** power operator. The built-in trigonmetric, log,
floor/ceil, and fabs functions might work (but haven&#8217;t been tested). It
also handles all types of array indexing supported by the NumPy module.
numarray&#8217;s NumPy compatible array indexing modes are likewise supported,
but numarray&#8217;s enhanced (array based) indexing modes are not supported.</p>
<p><tt class="docutils literal"><span class="pre">weave.blitz</span></tt> does not currently support operations that use array
broadcasting, nor have any of the special purpose functions in NumPy such
as take, compress, etc. been implemented. Note that there are no obvious
reasons why most of this functionality cannot be added to scipy.weave, so
it will likely trickle into future versions. Using <tt class="docutils literal"><span class="pre">slice()</span></tt> objects
directly instead of <tt class="docutils literal"><span class="pre">start:stop:step</span></tt> is also not supported.</p>
</li>
<li><p class="first">Currently Python only works on expressions that include assignment
such as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span>
</pre></div>
</div>
<p>This means that the result array must exist before calling
<tt class="docutils literal"><span class="pre">weave.blitz</span></tt>. Future versions will allow the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">weave</span><span class="o">.</span><span class="n">blitz_eval</span><span class="p">(</span><span class="s">&quot;b + c + d&quot;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">weave.blitz</span></tt> works best when algorithms can be expressed in a
&#8220;vectorized&#8221; form. Algorithms that have a large number of if/thens and
other conditions are better hand-written in C or Fortran. Further, the
restrictions imposed by requiring vectorized expressions sometimes
preclude the use of more efficient data structures or algorithms. For
maximum speed in these cases, hand-coded C or Fortran code is the only
way to go.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">weave.blitz</span></tt> can produce different results than NumPy in certain
situations. It can happen when the array receiving the results of a
calculation is also used during the calculation. The NumPy behavior is to
carry out the entire calculation on the right hand side of an equation
and store it in a temporary array. This temprorary array is assigned to
the array on the left hand side of the equation. blitz, on the other
hand, does a &#8220;running&#8221; calculation of the array elements assigning values
from the right hand side to the elements on the left hand side
immediately after they are calculated. Here is an example, provided by
Prabhu Ramachandran, where this happens:</p>
<div class="highlight-python"><pre># 4 point average.
&gt;&gt;&gt; expr = "u[1:-1, 1:-1] = (u[0:-2, 1:-1] + u[2:, 1:-1] + \
...                "u[1:-1,0:-2] + u[1:-1, 2:])*0.25"
&gt;&gt;&gt; u = zeros((5, 5), 'd'); u[0,:] = 100
&gt;&gt;&gt; exec (expr)
&gt;&gt;&gt; u
array([[ 100.,  100.,  100.,  100.,  100.],
       [   0.,   25.,   25.,   25.,    0.],
       [   0.,    0.,    0.,    0.,    0.],
       [   0.,    0.,    0.,    0.,    0.],
       [   0.,    0.,    0.,    0.,    0.]])

&gt;&gt;&gt; u = zeros((5, 5), 'd'); u[0,:] = 100
&gt;&gt;&gt; weave.blitz (expr)
&gt;&gt;&gt; u
array([[ 100.  ,  100.       ,  100.       ,  100.       , 100. ],
       [   0.  ,   25.       ,   31.25     ,   32.8125   , 0. ],
       [   0.  ,    6.25     ,    9.375    ,   10.546875 , 0. ],
       [   0.  ,    1.5625   ,    2.734375 ,    3.3203125, 0. ],
       [   0.  ,    0.       ,    0.       ,    0.       , 0. ]])</pre>
</div>
<p>You can prevent this behavior by using a temporary array.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">);</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">temp</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="s">&quot;temp = (u[0:-2, 1:-1] + u[2:, 1:-1] + &quot;</span>\
<span class="gp">... </span>       <span class="s">&quot;u[1:-1,0:-2] + u[1:-1, 2:])*0.25;&quot;</span>\
<span class="gp">... </span>       <span class="s">&quot;u[1:-1,1:-1] = temp&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">blitz</span> <span class="p">(</span><span class="n">expr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">array([[ 100.,  100.,  100.,  100.,  100.],</span>
<span class="go">       [   0.,   25.,   25.,   25.,    0.],</span>
<span class="go">       [   0.,    0.,    0.,    0.,    0.],</span>
<span class="go">       [   0.,    0.,    0.,    0.,    0.],</span>
<span class="go">       [   0.,    0.,    0.,    0.,    0.]])</span>
</pre></div>
</div>
</li>
<li><p class="first">One other point deserves mention lest people be confused.
<tt class="docutils literal"><span class="pre">weave.blitz</span></tt> is not a general purpose Python-&gt;C compiler. It only
works for expressions that contain NumPy arrays and/or Python scalar
values. This focused scope concentrates effort on the compuationally
intensive regions of the program and sidesteps the difficult issues
associated with a general purpose Python-&gt;C compiler.</p>
</li>
</ol>
</div>
<div class="section" id="numpy-efficiency-issues-what-compilation-buys-you">
<h3><a class="toc-backref" href="#id39">NumPy efficiency issues: What compilation buys you</a><a class="headerlink" href="#numpy-efficiency-issues-what-compilation-buys-you" title="Permalink to this headline">¶</a></h3>
<p>Some might wonder why compiling NumPy expressions to C++ is beneficial since
operations on NumPy array operations are already executed within C loops. The
problem is that anything other than the simplest expression are executed in
less than optimal fashion. Consider the following NumPy expression:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span>
</pre></div>
</div>
<p>When NumPy calculates the value for the 2d array, <tt class="docutils literal"><span class="pre">a</span></tt>, it does the
following steps:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">temp1</span> <span class="o">=</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">b</span>
<span class="n">temp2</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">temp1</span> <span class="o">+</span> <span class="n">temp2</span>
</pre></div>
</div>
<p>Two things to note. Since <tt class="docutils literal"><span class="pre">c</span></tt> is an (perhaps large) array, a large
temporary array must be created to store the results of <tt class="docutils literal"><span class="pre">1.2</span> <span class="pre">*</span> <span class="pre">b</span></tt>. The same
is true for <tt class="docutils literal"><span class="pre">temp2</span></tt>. Allocation is slow. The second thing is that we have 3
loops executing, one to calculate <tt class="docutils literal"><span class="pre">temp1</span></tt>, one for <tt class="docutils literal"><span class="pre">temp2</span></tt> and one for
adding them up. A C loop for the same problem might look like:</p>
<div class="highlight-python"><pre>for(int i = 0; i &lt; M; i++)
    for(int j = 0; j &lt; N; j++)
        a[i,j] = 1.2 * b[i,j] + c[i,j] * d[i,j]</pre>
</div>
<p>Here, the 3 loops have been fused into a single loop and there is no longer a
need for a temporary array. This provides a significant speed improvement
over the above example (write me and tell me what you get).</p>
<p>So, converting NumPy expressions into C/C++ loops that fuse the loops and
eliminate temporary arrays can provide big gains. The goal, then, is to
convert NumPy expression to C/C++ loops, compile them in an extension module,
and then call the compiled extension function. The good news is that there is
an obvious correspondence between the NumPy expression above and the C loop.
The bad news is that NumPy is generally much more powerful than this simple
example illustrates and handling all possible indexing possibilities results
in loops that are less than straightforward to write. (Take a peek at NumPy
for confirmation). Luckily, there are several available tools that simplify
the process.</p>
</div>
<div class="section" id="the-tools">
<h3><a class="toc-backref" href="#id40">The Tools</a><a class="headerlink" href="#the-tools" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">weave.blitz</span></tt> relies heavily on several remarkable tools. On the Python
side, the main facilitators are Jermey Hylton&#8217;s parser module and Travis
Oliphant&#8217;s NumPy module. On the compiled language side, Todd Veldhuizen&#8217;s
blitz++ array library, written in C++ (shhhh. don&#8217;t tell David Beazley), does
the heavy lifting. Don&#8217;t assume that, because it&#8217;s C++, it&#8217;s much slower than
C or Fortran. Blitz++ uses a jaw dropping array of template techniques
(metaprogramming, template expression, etc) to convert innocent-looking and
readable C++ expressions into to code that usually executes within a few
percentage points of Fortran code for the same problem. This is good.
Unfortunately all the template raz-ma-taz is very expensive to compile, so
the 200 line extension modules often take 2 or more minutes to compile. This
isn&#8217;t so good. <tt class="docutils literal"><span class="pre">weave.blitz</span></tt> works to minimize this issue by remembering
where compiled modules live and reusing them instead of re-compiling every
time a program is re-run.</p>
<div class="section" id="parser">
<h4><a class="toc-backref" href="#id41">Parser</a><a class="headerlink" href="#parser" title="Permalink to this headline">¶</a></h4>
<p>Tearing NumPy expressions apart, examining the pieces, and then rebuilding
them as C++ (blitz) expressions requires a parser of some sort. I can imagine
someone attacking this problem with regular expressions, but it&#8217;d likely be
ugly and fragile. Amazingly, Python solves this problem for us. It actually
exposes its parsing engine to the world through the <tt class="docutils literal"><span class="pre">parser</span></tt> module. The
following fragment creates an Abstract Syntax Tree (AST) object for the
expression and then converts to a (rather unpleasant looking) deeply nested
list representation of the tree.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">parser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy.weave.misc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ast</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">suite</span><span class="p">(</span><span class="s">&quot;a = b * c + d&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ast_list</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sym_list</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">weave</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">translate_symbols</span><span class="p">(</span><span class="n">ast_list</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">sym_list</span><span class="p">)</span>
<span class="go">[&#39;file_input&#39;,</span>
<span class="go"> [&#39;stmt&#39;,</span>
<span class="go">  [&#39;simple_stmt&#39;,</span>
<span class="go">   [&#39;small_stmt&#39;,</span>
<span class="go">    [&#39;expr_stmt&#39;,</span>
<span class="go">     [&#39;testlist&#39;,</span>
<span class="go">      [&#39;test&#39;,</span>
<span class="go">       [&#39;and_test&#39;,</span>
<span class="go">        [&#39;not_test&#39;,</span>
<span class="go">         [&#39;comparison&#39;,</span>
<span class="go">          [&#39;expr&#39;,</span>
<span class="go">           [&#39;xor_expr&#39;,</span>
<span class="go">            [&#39;and_expr&#39;,</span>
<span class="go">             [&#39;shift_expr&#39;,</span>
<span class="go">              [&#39;arith_expr&#39;,</span>
<span class="go">               [&#39;term&#39;,</span>
<span class="go">                [&#39;factor&#39;, [&#39;power&#39;, [&#39;atom&#39;, [&#39;NAME&#39;, &#39;a&#39;]]]]]]]]]]]]]]],</span>
<span class="go">     [&#39;EQUAL&#39;, &#39;=&#39;],</span>
<span class="go">     [&#39;testlist&#39;,</span>
<span class="go">      [&#39;test&#39;,</span>
<span class="go">       [&#39;and_test&#39;,</span>
<span class="go">        [&#39;not_test&#39;,</span>
<span class="go">         [&#39;comparison&#39;,</span>
<span class="go">          [&#39;expr&#39;,</span>
<span class="go">           [&#39;xor_expr&#39;,</span>
<span class="go">            [&#39;and_expr&#39;,</span>
<span class="go">             [&#39;shift_expr&#39;,</span>
<span class="go">              [&#39;arith_expr&#39;,</span>
<span class="go">               [&#39;term&#39;,</span>
<span class="go">                [&#39;factor&#39;, [&#39;power&#39;, [&#39;atom&#39;, [&#39;NAME&#39;, &#39;b&#39;]]]],</span>
<span class="go">                [&#39;STAR&#39;, &#39;*&#39;],</span>
<span class="go">                [&#39;factor&#39;, [&#39;power&#39;, [&#39;atom&#39;, [&#39;NAME&#39;, &#39;c&#39;]]]]],</span>
<span class="go">               [&#39;PLUS&#39;, &#39;+&#39;],</span>
<span class="go">               [&#39;term&#39;,</span>
<span class="go">                [&#39;factor&#39;, [&#39;power&#39;, [&#39;atom&#39;, [&#39;NAME&#39;, &#39;d&#39;]]]]]]]]]]]]]]]]],</span>
<span class="go">   [&#39;NEWLINE&#39;, &#39;&#39;]]],</span>
<span class="go"> [&#39;ENDMARKER&#39;, &#39;&#39;]]</span>
</pre></div>
</div>
<p>Despite its looks, with some tools developed by Jermey H., it&#8217;s possible to
search these trees for specific patterns (sub-trees), extract the sub-tree,
manipulate them converting python specific code fragments to blitz code
fragments, and then re-insert it in the parse tree. The parser module
documentation has some details on how to do this. Traversing the new
blitzified tree, writing out the terminal symbols as you go, creates our new
blitz++ expression string.</p>
</div>
<div class="section" id="blitz-and-numpy">
<h4><a class="toc-backref" href="#id42">Blitz and NumPy</a><a class="headerlink" href="#blitz-and-numpy" title="Permalink to this headline">¶</a></h4>
<p>The other nice discovery in the project is that the data structure used for
NumPy arrays and blitz arrays is nearly identical. NumPy stores &#8220;strides&#8221; as
byte offsets and blitz stores them as element offsets, but other than that,
they are the same. Further, most of the concept and capabilities of the two
libraries are remarkably similar. It is satisfying that two completely
different implementations solved the problem with similar basic
architectures. It is also fortuitous. The work involved in converting NumPy
expressions to blitz expressions was greatly diminished. As an example,
consider the code for slicing an array in Python with a stride:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0,2,4]</span>
</pre></div>
</div>
<p>In Blitz it is as follows:</p>
<div class="highlight-python"><pre>Array&lt;2,int&gt; b(10);
Array&lt;2,int&gt; c(3);
// ...
Array&lt;2,int&gt; a = b(Range(0,3,2)) + c;</pre>
</div>
<p>Here the range object works exactly like Python slice objects with the
exception that the top index (3) is inclusive where as Python&#8217;s (4) is
exclusive. Other differences include the type declarations in C++ and
parentheses instead of brackets for indexing arrays. Currently,
<tt class="docutils literal"><span class="pre">weave.blitz</span></tt> handles the inclusive/exclusive issue by subtracting one from
upper indices during the translation. An alternative that is likely more
robust/maintainable in the long run is to write a <tt class="docutils literal"><span class="pre">PyRange</span></tt> class that
behaves like Python&#8217;s <tt class="docutils literal"><span class="pre">range</span></tt>. This is likely very easy.</p>
<p>The stock blitz also doesn&#8217;t handle negative indices in ranges. The current
implementation of the <tt class="docutils literal"><span class="pre">blitz()</span></tt> has a partial solution to this problem. It
calculates and index that starts with a &#8216;-&#8216; sign by subtracting it from the
maximum index in the array so that:</p>
<div class="highlight-python"><pre>                upper index limit
                    /-----\
b[:-1] -&gt; b(Range(0,Nb[0]-1-1))</pre>
</div>
<p>This approach fails, however, when the top index is calculated from other
values. In the following scenario, if <tt class="docutils literal"><span class="pre">i+j</span></tt> evaluates to a negative value,
the compiled code will produce incorrect results and could even core-dump.
Right now, all calculated indices are assumed to be positive.</p>
<div class="highlight-python"><pre>b[:i-j] -&gt; b(Range(0,i+j))</pre>
</div>
<p>A solution is to calculate all indices up front using if/then to handle the
+/- cases. This is a little work and results in more code, so it hasn&#8217;t been
done. I&#8217;m holding out to see if blitz++ can be modified to handle negative
indexing, but haven&#8217;t looked into how much effort is involved yet. While it
needs fixin&#8217;, I don&#8217;t think there is a ton of code where this is an issue.</p>
<p>The actual translation of the Python expressions to blitz expressions is
currently a two part process. First, all x:y:z slicing expression are removed
from the AST, converted to slice(x,y,z) and re-inserted into the tree. Any
math needed on these expressions (subtracting from the maximum index, etc.)
are also preformed here. _beg and _end are used as special variables that are
defined as blitz::fromBegin and blitz::toEnd.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,:]</span>
</pre></div>
</div>
<p>becomes a more verbose:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nb">slice</span><span class="p">(</span><span class="n">_beg</span><span class="p">,</span><span class="n">_end</span><span class="p">)]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="nb">slice</span><span class="p">(</span><span class="n">_beg</span><span class="p">,</span><span class="n">_end</span><span class="p">)]</span>
</pre></div>
</div>
<p>The second part does a simple string search/replace to convert to a blitz
expression with the following translations:</p>
<div class="highlight-python"><pre>slice(_beg,_end) -&gt; _all  # not strictly needed, but cuts down on code.
slice            -&gt; blitz::Range
[                -&gt; (
]                -&gt; )
_stp             -&gt; 1</pre>
</div>
<p><tt class="docutils literal"><span class="pre">_all</span></tt> is defined in the compiled function as <tt class="docutils literal"><span class="pre">blitz::Range.all()</span></tt>. These
translations could of course happen directly in the syntax tree. But the
string replacement is slightly easier. Note that namespaces are maintained
in the C++ code to lessen the likelihood of name clashes. Currently no effort
is made to detect name clashes. A good rule of thumb is don&#8217;t use values that
start with &#8216;_&#8217; or &#8216;py_&#8217; in compiled expressions and you&#8217;ll be fine.</p>
</div>
</div>
<div class="section" id="type-definitions-and-coersion">
<h3><a class="toc-backref" href="#id43">Type definitions and coersion</a><a class="headerlink" href="#type-definitions-and-coersion" title="Permalink to this headline">¶</a></h3>
<p>So far we&#8217;ve glossed over the dynamic vs. static typing issue between Python
and C++. In Python, the type of value that a variable holds can change
through the course of program execution. C/C++, on the other hand, forces you
to declare the type of value a variables will hold prior at compile time.
<tt class="docutils literal"><span class="pre">weave.blitz</span></tt> handles this issue by examining the types of the variables in
the expression being executed, and compiling a function for those explicit
types. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">Float32</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">Float32</span><span class="p">)</span>
<span class="n">weave</span><span class="o">.</span><span class="n">blitz</span><span class="p">(</span><span class="s">&quot;a = a + b&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>When compiling this expression to C++, <tt class="docutils literal"><span class="pre">weave.blitz</span></tt> sees that the values
for a and b in the local scope have type <tt class="docutils literal"><span class="pre">Float32</span></tt>, or &#8216;float&#8217; on a 32 bit
architecture. As a result, it compiles the function using the float type (no
attempt has been made to deal with 64 bit issues).</p>
<p>What happens if you call a compiled function with array types that are
different than the ones for which it was originally compiled? No biggie,
you&#8217;ll just have to wait on it to compile a new version for your new types.
This doesn&#8217;t overwrite the old functions, as they are still accessible. See
the catalog section in the inline() documentation to see how this is handled.
Suffice to say, the mechanism is transparent to the user and behaves like
dynamic typing with the occasional wait for compiling newly typed functions.</p>
<p>When working with combined scalar/array operations, the type of the array is
<em>always</em> used. This is similar to the savespace flag that was recently added
to NumPy. This prevents issues with the following expression perhaps
unexpectedly being calculated at a higher (more expensive) precision that can
occur in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">typecode</span> <span class="o">=</span> <span class="n">Float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="mf">2.1</span> <span class="c"># results in b being a Float64 array.</span>
</pre></div>
</div>
<p>In this example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">Float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">Float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="o">.</span><span class="n">blitz</span><span class="p">(</span><span class="s">&quot;b = a * 2.1&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>the <tt class="docutils literal"><span class="pre">2.1</span></tt> is cast down to a <tt class="docutils literal"><span class="pre">float</span></tt> before carrying out the operation. If
you really want to force the calculation to be a <tt class="docutils literal"><span class="pre">double</span></tt>, define <tt class="docutils literal"><span class="pre">a</span></tt> and
<tt class="docutils literal"><span class="pre">b</span></tt> as <tt class="docutils literal"><span class="pre">double</span></tt> arrays.</p>
<p>One other point of note. Currently, you must include both the right hand side
and left hand side (assignment side) of your equation in the compiled
expression. Also, the array being assigned to must be created prior to
calling <tt class="docutils literal"><span class="pre">weave.blitz</span></tt>. I&#8217;m pretty sure this is easily changed so that a
compiled_eval expression can be defined, but no effort has been made to
allocate new arrays (and decern their type) on the fly.</p>
</div>
<div class="section" id="cataloging-compiled-functions">
<h3><a class="toc-backref" href="#id44">Cataloging Compiled Functions</a><a class="headerlink" href="#cataloging-compiled-functions" title="Permalink to this headline">¶</a></h3>
<p>See <a class="reference internal" href="#the-catalog">The Catalog</a> section in the <tt class="docutils literal"><span class="pre">weave.inline()</span></tt>
documentation.</p>
</div>
<div class="section" id="checking-array-sizes">
<h3><a class="toc-backref" href="#id45">Checking Array Sizes</a><a class="headerlink" href="#checking-array-sizes" title="Permalink to this headline">¶</a></h3>
<p>Surprisingly, one of the big initial problems with compiled code was making
sure all the arrays in an operation were of compatible type. The following
case is trivially easy:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
</pre></div>
</div>
<p>It only requires that arrays <tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">b</span></tt>, and <tt class="docutils literal"><span class="pre">c</span></tt> have the same shape.
However, expressions like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">c</span>
</pre></div>
</div>
<p>are not so trivial. Since slicing is involved, the size of the slices, not
the input arrays, must be checked. Broadcasting complicates things further
because arrays and slices with different dimensions and shapes may be
compatible for math operations (broadcasting isn&#8217;t yet supported by
<tt class="docutils literal"><span class="pre">weave.blitz</span></tt>). Reductions have a similar effect as their results are
different shapes than their input operand. The binary operators in NumPy
compare the shapes of their two operands just before they operate on them.
This is possible because NumPy treats each operation independently. The
intermediate (temporary) arrays created during sub-operations in an
expression are tested for the correct shape before they are combined by
another operation. Because <tt class="docutils literal"><span class="pre">weave.blitz</span></tt> fuses all operations into a single
loop, this isn&#8217;t possible. The shape comparisons must be done and guaranteed
compatible before evaluating the expression.</p>
<p>The solution chosen converts input arrays to &#8220;dummy arrays&#8221; that only
represent the dimensions of the arrays, not the data. Binary operations on
dummy arrays check that input array sizes are comptible and return a dummy
array with the size correct size. Evaluating an expression of dummy arrays
traces the changing array sizes through all operations and fails if
incompatible array sizes are ever found.</p>
<p>The machinery for this is housed in <tt class="docutils literal"><span class="pre">weave.size_check</span></tt>. It basically
involves writing a new class (dummy array) and overloading its math operators
to calculate the new sizes correctly. All the code is in Python and there is
a fair amount of logic (mainly to handle indexing and slicing) so the
operation does impose some overhead. For large arrays (ie. 50x50x50), the
overhead is negligible compared to evaluating the actual expression. For
small arrays (ie. 16x16), the overhead imposed for checking the shapes with
this method can cause the <tt class="docutils literal"><span class="pre">weave.blitz</span></tt> to be slower than evaluating the
expression in Python.</p>
<p>What can be done to reduce the overhead? (1) The size checking code could be
moved into C. This would likely remove most of the overhead penalty compared
to NumPy (although there is also some calling overhead), but no effort has
been made to do this. (2) You can also call <tt class="docutils literal"><span class="pre">weave.blitz</span></tt> with
<tt class="docutils literal"><span class="pre">check_size=0</span></tt> and the size checking isn&#8217;t done. However, if the sizes
aren&#8217;t compatible, it can cause a core-dump. So, foregoing size_checking
isn&#8217;t advisable until your code is well debugged.</p>
</div>
<div class="section" id="creating-the-extension-module">
<h3><a class="toc-backref" href="#id46">Creating the Extension Module</a><a class="headerlink" href="#creating-the-extension-module" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">weave.blitz</span></tt> uses the same machinery as <tt class="docutils literal"><span class="pre">weave.inline</span></tt> to build the
extension module. The only difference is the code included in the function is
automatically generated from the NumPy array expression instead of supplied
by the user.</p>
</div>
</div>
<div class="section" id="extension-modules">
<h2><a class="toc-backref" href="#id47">Extension Modules</a><a class="headerlink" href="#extension-modules" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">weave.inline</span></tt> and <tt class="docutils literal"><span class="pre">weave.blitz</span></tt> are high level tools that generate
extension modules automatically. Under the covers, they use several classes
from <tt class="docutils literal"><span class="pre">weave.ext_tools</span></tt> to help generate the extension module. The main two
classes are <tt class="docutils literal"><span class="pre">ext_module</span></tt> and <tt class="docutils literal"><span class="pre">ext_function</span></tt> (I&#8217;d like to add
<tt class="docutils literal"><span class="pre">ext_class</span></tt> and <tt class="docutils literal"><span class="pre">ext_method</span></tt> also). These classes simplify the process of
generating extension modules by handling most of the &#8220;boiler plate&#8221; code
automatically.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">inline</span></tt> actually sub-classes <tt class="docutils literal"><span class="pre">weave.ext_tools.ext_function</span></tt> to
generate slightly different code than the standard <tt class="docutils literal"><span class="pre">ext_function</span></tt>.
The main difference is that the standard class converts function
arguments to C types, while inline always has two arguments, the
local and global dicts, and the grabs the variables that need to be
convereted to C from these.</p>
</div>
<div class="section" id="a-simple-example">
<h3><a class="toc-backref" href="#id48">A Simple Example</a><a class="headerlink" href="#a-simple-example" title="Permalink to this headline">¶</a></h3>
<p>The following simple example demonstrates how to build an extension module
within a Python function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># examples/increment_example.py</span>
<span class="kn">from</span> <span class="nn">weave</span> <span class="kn">import</span> <span class="n">ext_tools</span>

<span class="k">def</span> <span class="nf">build_increment_ext</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Build a simple extension with functions that increment numbers.</span>
<span class="sd">        The extension will be built in the local directory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="n">ext_tools</span><span class="o">.</span><span class="n">ext_module</span><span class="p">(</span><span class="s">&#39;increment_ext&#39;</span><span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># effectively a type declaration for &#39;a&#39; in the</span>
          <span class="c"># following functions.</span>

    <span class="n">ext_code</span> <span class="o">=</span> <span class="s">&quot;return_val = Py::new_reference_to(Py::Int(a+1));&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">ext_tools</span><span class="o">.</span><span class="n">ext_function</span><span class="p">(</span><span class="s">&#39;increment&#39;</span><span class="p">,</span><span class="n">ext_code</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
    <span class="n">mod</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="n">ext_code</span> <span class="o">=</span> <span class="s">&quot;return_val = Py::new_reference_to(Py::Int(a+2));&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">ext_tools</span><span class="o">.</span><span class="n">ext_function</span><span class="p">(</span><span class="s">&#39;increment_by_2&#39;</span><span class="p">,</span><span class="n">ext_code</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
    <span class="n">mod</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="n">mod</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span>
</pre></div>
</div>
<p>The function <tt class="docutils literal"><span class="pre">build_increment_ext()</span></tt> creates an extension module named
<tt class="docutils literal"><span class="pre">increment_ext</span></tt> and compiles it to a shared library (.so or .pyd) that can
be loaded into Python.. <tt class="docutils literal"><span class="pre">increment_ext</span></tt> contains two functions,
<tt class="docutils literal"><span class="pre">increment</span></tt> and <tt class="docutils literal"><span class="pre">increment_by_2</span></tt>. The first line of
<tt class="docutils literal"><span class="pre">build_increment_ext()</span></tt>,</p>
<blockquote>
<div>mod = ext_tools.ext_module(&#8216;increment_ext&#8217;)</div></blockquote>
<p>creates an <tt class="docutils literal"><span class="pre">ext_module</span></tt> instance that is ready to have <tt class="docutils literal"><span class="pre">ext_function</span></tt>
instances added to it. <tt class="docutils literal"><span class="pre">ext_function</span></tt> instances are created much with a
calling convention similar to <tt class="docutils literal"><span class="pre">weave.inline()</span></tt>. The most common call
includes a C/C++ code snippet and a list of the arguments for the function.
The following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ext_code</span> <span class="o">=</span> <span class="s">&quot;return_val = Py::new_reference_to(Py::Int(a+1));&quot;</span>
<span class="n">func</span> <span class="o">=</span> <span class="n">ext_tools</span><span class="o">.</span><span class="n">ext_function</span><span class="p">(</span><span class="s">&#39;increment&#39;</span><span class="p">,</span><span class="n">ext_code</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>creates a C/C++ extension function that is equivalent to the following Python
function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">increment</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>A second method is also added to the module and then,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mod</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span>
</pre></div>
</div>
<p>is called to build the extension module. By default, the module is created in
the current working directory. This example is available in the
<tt class="docutils literal"><span class="pre">examples/increment_example.py</span></tt> file found in the <tt class="docutils literal"><span class="pre">weave</span></tt> directory. At
the bottom of the file in the module&#8217;s &#8220;main&#8221; program, an attempt to import
<tt class="docutils literal"><span class="pre">increment_ext</span></tt> without building it is made. If this fails (the module
doesn&#8217;t exist in the PYTHONPATH), the module is built by calling
<tt class="docutils literal"><span class="pre">build_increment_ext()</span></tt>. This approach only takes the time-consuming (a few
seconds for this example) process of building the module if it hasn&#8217;t been
built before.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">increment_ext</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">build_increment_ext</span><span class="p">()</span>
        <span class="kn">import</span> <span class="nn">increment_ext</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">print</span> <span class="s">&#39;a, a+1:&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">increment_ext</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;a, a+2:&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">increment_ext</span><span class="o">.</span><span class="n">increment_by_2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If we were willing to always pay the penalty of building the C++
code for a module, we could store the SHA-256 checksum of the C++ code
along with some information about the compiler, platform, etc. Then,
<tt class="docutils literal"><span class="pre">ext_module.compile()</span></tt> could try importing the module before it
actually compiles it, check the SHA-256 checksum and other meta-data in
the imported module with the meta-data of the code it just produced
and only compile the code if the module didn&#8217;t exist or the
meta-data didn&#8217;t match. This would reduce the above code to:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">build_increment_ext</span><span class="p">()</span>

    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">print</span> <span class="s">&#39;a, a+1:&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">increment_ext</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;a, a+2:&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">increment_ext</span><span class="o">.</span><span class="n">increment_by_2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There would always be the overhead of building the C++ code, but it
would only actually compile the code once. You pay a little in overhead and
get cleaner &#8220;import&#8221; code. Needs some thought.</p>
</div>
<p>If you run <tt class="docutils literal"><span class="pre">increment_example.py</span></tt> from the command line, you get the
following:</p>
<div class="highlight-python"><pre>[eric@n0]$ python increment_example.py
a, a+1: 1 2
a, a+2: 1 3</pre>
</div>
<p>If the module didn&#8217;t exist before it was run, the module is created. If it
did exist, it is just imported and used.</p>
</div>
<div class="section" id="fibonacci-example">
<h3><a class="toc-backref" href="#id49">Fibonacci Example</a><a class="headerlink" href="#fibonacci-example" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">examples/fibonacci.py</span></tt> provides a little more complex example of how to
use <tt class="docutils literal"><span class="pre">ext_tools</span></tt>. Fibonacci numbers are a series of numbers where each
number in the series is the sum of the previous two: 1, 1, 2, 3, 5, 8, etc.
Here, the first two numbers in the series are taken to be 1. One approach to
calculating Fibonacci numbers uses recursive function calls. In Python, it
might be written as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In C, the same function would look something like this:</p>
<div class="highlight-python"><pre>int fib(int a)
{
    if(a &lt;= 2)
        return 1;
    else
        return fib(a-2) + fib(a-1);
}</pre>
</div>
<p>Recursion is much faster in C than in Python, so it would be beneficial to
use the C version for fibonacci number calculations instead of the Python
version. We need an extension function that calls this C function to do this.
This is possible by including the above code snippet as &#8220;support code&#8221; and
then calling it from the extension function. Support code snippets (usually
structure definitions, helper functions and the like) are inserted into the
extension module C/C++ file before the extension function code. Here is how
to build the C version of the fibonacci number generator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">build_fibonacci</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Builds an extension module with fibonacci calculators.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="n">ext_tools</span><span class="o">.</span><span class="n">ext_module</span><span class="p">(</span><span class="s">&#39;fibonacci_ext&#39;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># this is effectively a type declaration</span>

    <span class="c"># recursive fibonacci in C</span>
    <span class="n">fib_code</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">                   int fib1(int a)</span>
<span class="s">                   {</span>
<span class="s">                       if(a &lt;= 2)</span>
<span class="s">                           return 1;</span>
<span class="s">                       else</span>
<span class="s">                           return fib1(a-2) + fib1(a-1);</span>
<span class="s">                   }</span>
<span class="s">               &quot;&quot;&quot;</span>
    <span class="n">ext_code</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">                   int val = fib1(a);</span>
<span class="s">                   return_val = Py::new_reference_to(Py::Int(val));</span>
<span class="s">               &quot;&quot;&quot;</span>
    <span class="n">fib</span> <span class="o">=</span> <span class="n">ext_tools</span><span class="o">.</span><span class="n">ext_function</span><span class="p">(</span><span class="s">&#39;fib&#39;</span><span class="p">,</span><span class="n">ext_code</span><span class="p">,[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
    <span class="n">fib</span><span class="o">.</span><span class="n">customize</span><span class="o">.</span><span class="n">add_support_code</span><span class="p">(</span><span class="n">fib_code</span><span class="p">)</span>
    <span class="n">mod</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span><span class="n">fib</span><span class="p">)</span>

    <span class="n">mod</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span>
</pre></div>
</div>
<p>XXX More about custom_info, and what xxx_info instances are good for.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">recursion is not the fastest way to calculate fibonacci numbers, but
this approach serves nicely for this example.</p>
</div>
</div>
</div>
<div class="section" id="customizing-type-conversions-type-factories">
<h2><a class="toc-backref" href="#id50">Customizing Type Conversions &#8211; Type Factories</a><a class="headerlink" href="#customizing-type-conversions-type-factories" title="Permalink to this headline">¶</a></h2>
<p>not written</p>
</div>
<div class="section" id="things-i-wish-weave-did">
<h2><a class="toc-backref" href="#id51">Things I wish <tt class="docutils literal"><span class="pre">weave</span></tt> did</a><a class="headerlink" href="#things-i-wish-weave-did" title="Permalink to this headline">¶</a></h2>
<p>It is possible to get name clashes if you uses a variable name that is
already defined in a header automatically included (such as <tt class="docutils literal"><span class="pre">stdio.h</span></tt>) For
instance, if you try to pass in a variable named <tt class="docutils literal"><span class="pre">stdout</span></tt>, you&#8217;ll get a
cryptic error report due to the fact that <tt class="docutils literal"><span class="pre">stdio.h</span></tt> also defines the name.
<tt class="docutils literal"><span class="pre">weave</span></tt> should probably try and handle this in some way. Other things...</p>
</div>
</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2009, The Scipy community.
      </li>
      <li>
      Last updated on Oct 21, 2013.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
      </li>
    </ul>
    </div>
    </div>
    </div>

<script type="text/javascript">
        $('.dropdown-toggle').dropdown()
</script>

<script>
$(document).ready(function()
{
  //Handles menu drop down
  $('.dropdown-menu').find('form').click(function (e) {
        e.stopPropagation();
        });
  });
</script>

<script type="text/javascript">
        //handles accordion arrow-up and down in pages
        $('.accordion-group').collapse();
        $('.accordion-group').on('show hide', function(e)
                { 
                        $(e.target).siblings('.accordion-heading').find('.accordion-toggle i').toggleClass('icon-arrow-down icon-arrow-up', 200); 
                });
</script>

  </body>
</html>