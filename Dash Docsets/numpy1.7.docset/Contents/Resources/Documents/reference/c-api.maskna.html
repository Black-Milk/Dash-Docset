<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" SYSTEM "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><title>Array NA Mask API — NumPy v1.7.dev-3f685a1 Manual (DRAFT)</title><link href="../_static/scipy.css" rel="stylesheet" type="text/css"/><link href="../_static/pygments.css" rel="stylesheet" type="text/css"/><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.7.0.dev-3f685a1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script><script src="../_static/jquery.js" type="text/javascript"></script><script src="../_static/underscore.js" type="text/javascript"></script><script src="../_static/doctools.js" type="text/javascript"></script><link href="../about.html" rel="author" title="About these documents"/><link href="../index.html" rel="top" title="NumPy v1.7.dev-3f685a1 Manual (DRAFT)"/><link href="c-api.html" rel="up" title="Numpy C-API"/><link href="c-api.ufunc.html" rel="next" title="UFunc API"/><link href="c-api.iterator.html" rel="prev" title="Array Iterator API"/></head><body>
<div class="related">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a accesskey="I" href="../genindex.html" title="General Index">index</a></li>
<li class="right">
<a href="../py-modindex.html" title="Python Module Index">modules</a> |</li>
<li class="right">
<a href="../np-modindex.html" title="Python Module Index">modules</a> |</li>
<li class="right">
<a accesskey="N" href="c-api.ufunc.html" title="UFunc API">next</a> |</li>
<li class="right">
<a accesskey="P" href="c-api.iterator.html" title="Array Iterator API">previous</a> |</li>
<li><a href="../index.html">NumPy v1.7.dev-3f685a1 Manual (DRAFT)</a> »</li>
<li><a href="index.html">NumPy Reference</a> »</li>
<li><a accesskey="U" href="c-api.html">Numpy C-API</a> »</li>
</ul>
</div>
<div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body">
<div class="section" id="array-na-mask-api">
<h1>Array NA Mask API<a class="headerlink" href="#array-na-mask-api" title="Permalink to this headline">¶</a></h1>
<p class="versionadded" id="index-0">
<span class="versionmodified">New in version 1.7.</span></p>
<div class="section" id="na-masks-in-arrays">
<h2>NA Masks in Arrays<a class="headerlink" href="#na-masks-in-arrays" title="Permalink to this headline">¶</a></h2>
<p>NumPy supports the idea of NA (Not Available) missing values in its
arrays.  In the design document leading up to the implementation, two
mechanisms for this were proposed, NA masks and NA bitpatterns. NA masks
have been implemented as the first representation of these values. This
mechanism supports working with NA values similar to what the R language
provides, and when combined with views, allows one to temporarily mark
elements as NA without affecting the original data.</p>
<p>The C API has been updated with mechanisms to allow NumPy extensions
to work with these masks, and this document provides some examples and
reference for the NA mask-related functions.</p>
</div>
<div class="section" id="the-na-object">
<h2>The NA Object<a class="headerlink" href="#the-na-object" title="Permalink to this headline">¶</a></h2>
<p>The main <em>numpy</em> namespace in Python has a new object called <em>NA</em>.
This is an instance of <a class="reference internal" href="#NpyNA" title="NpyNA"><tt class="xref c c-type docutils literal"><span class="pre">NpyNA</span></tt></a>, which is a Python object
representing an NA value. This object is analogous to the NumPy
scalars, and is returned by <a class="reference internal" href="c-api.array.html#PyArray_Return" title="PyArray_Return"><tt class="xref c c-func docutils literal"><span class="pre">PyArray_Return</span></tt></a> instead of
a scalar where appropriate.</p>
<p>The global <em>numpy.NA</em> object is accessible from C as <a class="reference internal" href="#Npy_NA" title="Npy_NA"><tt class="xref c c-data docutils literal"><span class="pre">Npy_NA</span></tt></a>.
This is an NA value with no data type or multi-NA payload. Use it
just as you would Py_None, except use <a class="reference internal" href="#NpyNA_Check" title="NpyNA_Check"><tt class="xref c c-func docutils literal"><span class="pre">NpyNA_Check</span></tt></a> to
see if an object is an <a class="reference internal" href="#NpyNA" title="NpyNA"><tt class="xref c c-type docutils literal"><span class="pre">NpyNA</span></tt></a>, because <a class="reference internal" href="#Npy_NA" title="Npy_NA"><tt class="xref c c-data docutils literal"><span class="pre">Npy_NA</span></tt></a> isn’t
the only instance of NA possible.</p>
<p>If you want to see whether a general PyObject* is NA, you should
use the API function <a class="reference internal" href="#NpyNA_FromObject" title="NpyNA_FromObject"><tt class="xref c c-func docutils literal"><span class="pre">NpyNA_FromObject</span></tt></a> with <em>suppress_error</em>
set to true. If this returns NULL, the object is not an NA, and if
it returns an NpyNA instance, the object is NA and you can then
access its <em>dtype</em> and <em>payload</em> fields as needed.</p>
<p>To make new <a class="reference internal" href="#NpyNA" title="NpyNA"><tt class="xref c c-type docutils literal"><span class="pre">NpyNA</span></tt></a> objects, use
<a class="reference internal" href="#NpyNA_FromDTypeAndPayload" title="NpyNA_FromDTypeAndPayload"><tt class="xref c c-func docutils literal"><span class="pre">NpyNA_FromDTypeAndPayload</span></tt></a>. The functions
<a class="reference internal" href="#NpyNA_GetDType" title="NpyNA_GetDType"><tt class="xref c c-func docutils literal"><span class="pre">NpyNA_GetDType</span></tt></a>, <a class="reference internal" href="#NpyNA_IsMultiNA" title="NpyNA_IsMultiNA"><tt class="xref c c-func docutils literal"><span class="pre">NpyNA_IsMultiNA</span></tt></a>, and
<a class="reference internal" href="#NpyNA_GetPayload" title="NpyNA_GetPayload"><tt class="xref c c-func docutils literal"><span class="pre">NpyNA_GetPayload</span></tt></a> provide access to the data members.</p>
</div>
<div class="section" id="working-with-na-masked-arrays">
<h2>Working With NA-Masked Arrays<a class="headerlink" href="#working-with-na-masked-arrays" title="Permalink to this headline">¶</a></h2>
<p>The starting point for many C-API functions which manipulate NumPy
arrays is the function <a class="reference internal" href="c-api.array.html#PyArray_FromAny" title="PyArray_FromAny"><tt class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></tt></a>. This function converts
a general PyObject* object into a NumPy ndarray, based on options
specified in the flags. To avoid surprises, this function does
not allow NA-masked arrays to pass through by default.</p>
<p>To allow third-party code to work with NA-masked arrays which contain
no NAs, <a class="reference internal" href="c-api.array.html#PyArray_FromAny" title="PyArray_FromAny"><tt class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></tt></a> will make a copy of the array into
a new array without an NA-mask, and return that. This allows for
proper interoperability in cases where it’s possible until functions
are updated to provide optimal code paths for NA-masked arrays.</p>
<p>To update a function with NA-mask support, add the flag
<a class="reference internal" href="c-api.array.html#NPY_ARRAY_ALLOWNA" title="NPY_ARRAY_ALLOWNA"><tt class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALLOWNA</span></tt></a> when calling <a class="reference internal" href="c-api.array.html#PyArray_FromAny" title="PyArray_FromAny"><tt class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></tt></a>.
This allows NA-masked arrays to pass through untouched, and will
convert PyObject lists containing NA values into NA-masked arrays
instead of the alternative of switching to object arrays.</p>
<p>To check whether an array has an NA-mask, use the function
<a class="reference internal" href="c-api.array.html#PyArray_HASMASKNA" title="PyArray_HASMASKNA"><tt class="xref c c-func docutils literal"><span class="pre">PyArray_HASMASKNA</span></tt></a>, which checks the appropriate flag.
There are a number of things that one will typically want to do
when encountering an NA-masked array. We’ll go through a few
of these cases.</p>
<div class="section" id="forbidding-any-na-values">
<h3>Forbidding Any NA Values<a class="headerlink" href="#forbidding-any-na-values" title="Permalink to this headline">¶</a></h3>
<p>The simplest case is to forbid any NA values. Note that it is better
to still be aware of the NA mask and explicitly test for NA values
than to leave out the <a class="reference internal" href="c-api.array.html#NPY_ARRAY_ALLOWNA" title="NPY_ARRAY_ALLOWNA"><tt class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALLOWNA</span></tt></a>, because it is possible
to avoid the extra copy that <a class="reference internal" href="c-api.array.html#PyArray_FromAny" title="PyArray_FromAny"><tt class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></tt></a> will make. The
check for NAs will go something like this:</p>
<div class="highlight-python"><pre>PyArrayObject *arr = ...;
int containsna;

/* ContainsNA checks HASMASKNA() for you */
containsna = PyArray_ContainsNA(arr, NULL, NULL);
/* Error case */
if (containsna &lt; 0) {
    return NULL;
}
/* If it found an NA */
else if (containsna) {
    PyErr_SetString(PyExc_ValueError,
            "this operation does not support arrays with NA values");
    return NULL;
}</pre>
</div>
<p>After this check, you can be certain that the array doesn’t contain any
NA values, and can proceed accordingly. For example, if you iterate
over the elements of the array, you may pass the flag
<a class="reference internal" href="c-api.iterator.html#NPY_ITER_IGNORE_MASKNA" title="NPY_ITER_IGNORE_MASKNA"><tt class="xref c c-data docutils literal"><span class="pre">NPY_ITER_IGNORE_MASKNA</span></tt></a> to iterate over the data without
touching the NA-mask at all.</p>
</div>
<div class="section" id="manipulating-na-values">
<h3>Manipulating NA Values<a class="headerlink" href="#manipulating-na-values" title="Permalink to this headline">¶</a></h3>
<p>The semantics of the NA-mask demand that whenever an array element
is hidden by the NA-mask, no computations are permitted to modify
the data backing that element. The <a class="reference internal" href="c-api.iterator.html#NpyIter" title="NpyIter"><tt class="xref c c-type docutils literal"><span class="pre">NpyIter</span></tt></a> provides
a number of flags to assist with visiting both the array data
and the mask data simultaneously, and preserving the masking semantics
even when buffering is required.</p>
<p>The main flag for iterating over NA-masked arrays is
<a class="reference internal" href="c-api.iterator.html#NPY_ITER_USE_MASKNA" title="NPY_ITER_USE_MASKNA"><tt class="xref c c-data docutils literal"><span class="pre">NPY_ITER_USE_MASKNA</span></tt></a>. For each iterator operand which has this
flag specified, a new operand is added to the end of the iterator operand
list, and is set to iterate over the original operand’s NA-mask. Operands
which do not have an NA mask are permitted as well when they are flagged
as read-only. The new operand in this case points to a single exposed
mask value and all its strides are zero. The latter feature is useful
when combining multiple read-only inputs, where some of them have masks.</p>
</div>
<div class="section" id="accumulating-na-values">
<h3>Accumulating NA Values<a class="headerlink" href="#accumulating-na-values" title="Permalink to this headline">¶</a></h3>
<p>More complex operations, like the NumPy ufunc reduce functions, need
to take extra care to follow the masking semantics. If we accumulate
the NA mask and the data values together, we could discover half way
through that the output is NA, and that we have violated the contract
to never change the underlying output value when it is being assigned
NA.</p>
<p>The solution to this problem is to first accumulate the NA-mask as necessary
to produce the output’s NA-mask, then accumulate the data values without
touching NA-masked values in the output. The parameter <em>preservena</em> in
functions like <tt class="xref c c-func docutils literal"><span class="pre">PyArray_AssignArray</span></tt> can assist when initializing
values in such an algorithm.</p>
</div>
</div>
<div class="section" id="example-na-masked-operation-in-c">
<h2>Example NA-Masked Operation in C<a class="headerlink" href="#example-na-masked-operation-in-c" title="Permalink to this headline">¶</a></h2>
<p>As an example, let’s implement a simple binary NA-masked operation
for the double dtype. We’ll make a divide operation which turns
divide by zero into NA instead of Inf or NaN.</p>
<p>To start, we define the function prototype and some basic
<a class="reference internal" href="c-api.iterator.html#NpyIter" title="NpyIter"><tt class="xref c c-type docutils literal"><span class="pre">NpyIter</span></tt></a> boilerplate setup. We’ll make a function which
supports an optional <em>out</em> parameter, which may be NULL.:</p>
<div class="highlight-python"><pre>static PyArrayObject*
SpecialDivide(PyArrayObject* a, PyArrayObject* b, PyArrayObject *out)
{
    NpyIter *iter = NULL;
    PyArrayObject *op[3];
    PyArray_Descr *dtypes[3];
    npy_uint32 flags, op_flags[3];

    /* Iterator construction parameters */
    op[0] = a;
    op[1] = b;
    op[2] = out;

    dtypes[0] = PyArray_DescrFromType(NPY_DOUBLE);
    if (dtypes[0] == NULL) {
        return NULL;
    }
    dtypes[1] = dtypes[0];
    dtypes[2] = dtypes[0];

    flags = NPY_ITER_BUFFERED |
            NPY_ITER_EXTERNAL_LOOP |
            NPY_ITER_GROWINNER |
            NPY_ITER_REFS_OK |
            NPY_ITER_ZEROSIZE_OK;

    /* Every operand gets the flag NPY_ITER_USE_MASKNA */
    op_flags[0] = NPY_ITER_READONLY |
                  NPY_ITER_ALIGNED |
                  NPY_ITER_USE_MASKNA;
    op_flags[1] = op_flags[0];
    op_flags[2] = NPY_ITER_WRITEONLY |
                  NPY_ITER_ALIGNED |
                  NPY_ITER_USE_MASKNA |
                  NPY_ITER_NO_BROADCAST |
                  NPY_ITER_ALLOCATE;

    iter = NpyIter_MultiNew(3, op, flags, NPY_KEEPORDER,
                            NPY_SAME_KIND_CASTING, op_flags, dtypes);
    /* Don't need the dtype reference anymore */
    Py_DECREF(dtypes[0]);
    if (iter == NULL) {
        return NULL;
    }</pre>
</div>
<p>At this point, the input operands have been validated according to
the casting rule, the shapes of the arrays have been broadcast together,
and any buffering necessary has been prepared. This means we can
dive into the inner loop of this function.:</p>
<div class="highlight-python"><pre>...
    if (NpyIter_GetIterSize(iter) &gt; 0) {
        NpyIter_IterNextFunc *iternext;
        char **dataptr;
        npy_intp *stridesptr, *countptr;

        /* Variables needed for looping */
        iternext = NpyIter_GetIterNext(iter, NULL);
        if (iternext == NULL) {
            NpyIter_Deallocate(iter);
            return NULL;
        }
        dataptr = NpyIter_GetDataPtrArray(iter);
        stridesptr = NpyIter_GetInnerStrideArray(iter);
        countptr = NpyIter_GetInnerLoopSizePtr(iter);</pre>
</div>
<p>The loop gets a bit messy when dealing with NA-masks, because it
doubles the number of operands being processed in the iterator. Here
we are naming things clearly so that the content of the innermost loop
can be easy to work with.:</p>
<div class="highlight-python"><pre>...
        do {
            /* Data pointers and strides needed for innermost loop */
            char *data_a = dataptr[0], *data_b = dataptr[1];
            char *data_out = dataptr[2];
            char *maskna_a = dataptr[3], *maskna_b = dataptr[4];
            char *maskna_out = dataptr[5];
            npy_intp stride_a = stridesptr[0], stride_b = stridesptr[1];
            npy_intp stride_out = strides[2];
            npy_intp maskna_stride_a = stridesptr[3];
            npy_intp maskna_stride_b = stridesptr[4];
            npy_intp maskna_stride_out = stridesptr[5];
            npy_intp i, count = *countptr;

            for (i = 0; i &lt; count; ++i) {</pre>
</div>
<p>Here is the code for performing one special division. We use
the functions <a class="reference internal" href="#NpyMaskValue_IsExposed" title="NpyMaskValue_IsExposed"><tt class="xref c c-func docutils literal"><span class="pre">NpyMaskValue_IsExposed</span></tt></a> and
<a class="reference internal" href="#NpyMaskValue_Create" title="NpyMaskValue_Create"><tt class="xref c c-func docutils literal"><span class="pre">NpyMaskValue_Create</span></tt></a> to work with the masks, in order to be
as general as possible. These are inline functions, and the compiler
optimizer should be able to produce the same result as if you performed
these operations directly inline here.:</p>
<div class="highlight-python"><pre>...
                /* If neither of the inputs are NA */
                if (NpyMaskValue_IsExposed((npy_mask)*maskna_a) &amp;&amp;
                            NpyMaskValue_IsExposed((npy_mask)*maskna_b)) {
                    double a_val = *(double *)data_a;
                    double b_val = *(double *)data_b;
                    /* Do the divide if 'b' isn't zero */
                    if (b_val != 0.0) {
                        *(double *)data_out = a_val / b_val;
                        /* Need to also set this element to exposed */
                        *maskna_out = NpyMaskValue_Create(1, 0);
                    }
                    /* Otherwise output an NA without touching its data */
                    else {
                        *maskna_out = NpyMaskValue_Create(0, 0);
                    }
                }
                /* Turn the output into NA without touching its data */
                else {
                    *maskna_out = NpyMaskValue_Create(0, 0);
                }

                data_a += stride_a;
                data_b += stride_b;
                data_out += stride_out;
                maskna_a += maskna_stride_a;
                maskna_b += maskna_stride_b;
                maskna_out += maskna_stride_out;
            }
        } while (iternext(iter));
    }</pre>
</div>
<p>A little bit more boilerplate for returning the result from the iterator,
and the function is done.:</p>
<div class="highlight-python"><pre>...
    if (out == NULL) {
        out = NpyIter_GetOperandArray(iter)[2];
    }
    Py_INCREF(out);
    NpyIter_Deallocate(iter);

    return out;
}</pre>
</div>
<p>To run this example, you can create a simple module with a C-file spdiv_mod.c
consisting of:</p>
<div class="highlight-python"><pre>#include &lt;Python.h&gt;
#include &lt;numpy/arrayobject.h&gt;

/* INSERT SpecialDivide source code here */

static PyObject *
spdiv(PyObject *self, PyObject *args, PyObject *kwds)
{
    PyArrayObject *a, *b, *out = NULL;
    static char *kwlist[] = {"a", "b", "out", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O&amp;O&amp;|O&amp;", kwlist,
                            &amp;PyArray_AllowNAConverter, &amp;a,
                            &amp;PyArray_AllowNAConverter, &amp;b,
                            &amp;PyArray_OutputAllowNAConverter, &amp;out)) {
        return NULL;
    }

    /*
     * The usual NumPy way is to only use PyArray_Return when
     * the 'out' parameter is not provided.
     */
    if (out == NULL) {
        return PyArray_Return(SpecialDivide(a, b, out));
    }
    else {
        return (PyObject *)SpecialDivide(a, b, out);
    }
}

static PyMethodDef SpDivMethods[] = {
    {"spdiv", (PyCFunction)spdiv, METH_VARARGS | METH_KEYWORDS, NULL},
    {NULL, NULL, 0, NULL}
};


PyMODINIT_FUNC initspdiv_mod(void)
{
    PyObject *m;

    m = Py_InitModule("spdiv_mod", SpDivMethods);
    if (m == NULL) {
        return;
    }

    /* Make sure NumPy is initialized */
    import_array();
}</pre>
</div>
<p>Create a setup.py file like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="k">def</span> <span class="nf">configuration</span><span class="p">(</span><span class="n">parent_package</span><span class="o">=</span><span class="s">''</span><span class="p">,</span><span class="n">top_path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">numpy.distutils.misc_util</span> <span class="kn">import</span> <span class="n">Configuration</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configuration</span><span class="p">(</span><span class="s">'.'</span><span class="p">,</span><span class="n">parent_package</span><span class="p">,</span><span class="n">top_path</span><span class="p">)</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_extension</span><span class="p">(</span><span class="s">'spdiv_mod'</span><span class="p">,[</span><span class="s">'spdiv_mod.c'</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">config</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">numpy.distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
    <span class="n">setup</span><span class="p">(</span><span class="n">configuration</span><span class="o">=</span><span class="n">configuration</span><span class="p">)</span>
</pre></div>
</div>
<p>With these two files in a directory by itself, run:</p>
<div class="highlight-python"><pre>$ python setup.py build_ext --inplace</pre>
</div>
<p>and the file spdiv_mod.so (or .dll) will be placed in the same directory.
Now you can try out this sample, to see how it behaves.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">spdiv_mod</span> <span class="kn">import</span> <span class="n">spdiv</span>
</pre></div>
</div>
<p>Because we used <a class="reference internal" href="c-api.array.html#PyArray_Return" title="PyArray_Return"><tt class="xref c c-func docutils literal"><span class="pre">PyArray_Return</span></tt></a> when wrapping SpecialDivide,
it returns scalars like any typical NumPy function does:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">spdiv</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spdiv</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">NA(dtype='float64')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spdiv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="go">NA(dtype='float64')</span>
</pre></div>
</div>
<p>Here we can see how NAs propagate, and how 0 in the output turns into NA
as desired.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spdiv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([  NA,   NA,   NA,  1.5,  4. ,   NA])</span>
</pre></div>
</div>
<p>Finally, we can see the masking behavior by creating a masked
view of an array. The ones in <em>c_orig</em> are preserved whereever
NA got assigned.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">c_orig</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">maskna</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spdiv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
<span class="go">array([  NA,   NA,   NA,  1.5,  4. ,   NA])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_orig</span>
<span class="go">array([ 1. ,  1. ,  1. ,  1.5,  4. ,  1. ])</span>
</pre></div>
</div>
</div>
<div class="section" id="na-object-data-type">
<h2>NA Object Data Type<a class="headerlink" href="#na-object-data-type" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="NpyNA">
<tt class="descname">NpyNA</tt><a class="headerlink" href="#NpyNA" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the C object corresponding to objects of type
numpy.NAType. The fields themselves are hidden from consumers of the
API, you must use the functions provided to create new NA objects
and get their properties.</p>
<p>This object contains two fields, a <a class="reference internal" href="c-api.types-and-structures.html#PyArray_Descr" title="PyArray_Descr"><tt class="xref c c-type docutils literal"><span class="pre">PyArray_Descr</span> <span class="pre">*</span></tt></a> dtype
which is either NULL or indicates the data type the NA represents,
and a payload which is there for the future addition of multi-NA support.</p>
</dd></dl>
<dl class="var">
<dt id="Npy_NA">
<tt class="descname">Npy_NA</tt><a class="headerlink" href="#Npy_NA" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a global singleton, similar to Py_None, which is the
<em>numpy.NA</em> object. Note that unlike Py_None, multiple NAs may be
created, for instance with different multi-NA payloads or with
different dtypes. If you want to return an NA with no payload
or dtype, return a new reference to Npy_NA.</p>
</dd></dl>
</div>
<div class="section" id="na-object-functions">
<h2>NA Object Functions<a class="headerlink" href="#na-object-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<a name="//apple_ref/cpp/func/NpyNA_Check"></a><dt id="NpyNA_Check">
<tt class="descname">NpyNA_Check</tt><big>(</big>obj<big>)</big><a class="headerlink" href="#NpyNA_Check" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates to true if <em>obj</em> is an instance of <a class="reference internal" href="#NpyNA" title="NpyNA"><tt class="xref c c-type docutils literal"><span class="pre">NpyNA</span></tt></a>.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/NpyNA_GetDType"></a><dt id="NpyNA_GetDType">
<a class="reference internal" href="c-api.types-and-structures.html#PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>* <tt class="descname">NpyNA_GetDType</tt><big>(</big><a class="reference internal" href="#NpyNA" title="NpyNA">NpyNA</a>*<em> na</em><big>)</big><a class="headerlink" href="#NpyNA_GetDType" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <em>dtype</em> field of the NA object, which is NULL when
the NA has no dtype.  Does not raise an error.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/NpyNA_IsMultiNA"></a><dt id="NpyNA_IsMultiNA">
<a class="reference internal" href="c-api.dtype.html#npy_bool" title="npy_bool">npy_bool</a> <tt class="descname">NpyNA_IsMultiNA</tt><big>(</big><a class="reference internal" href="#NpyNA" title="NpyNA">NpyNA</a>*<em> na</em><big>)</big><a class="headerlink" href="#NpyNA_IsMultiNA" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the NA has a multi-NA payload, false otherwise.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/NpyNA_GetPayload"></a><dt id="NpyNA_GetPayload">
int <tt class="descname">NpyNA_GetPayload</tt><big>(</big><a class="reference internal" href="#NpyNA" title="NpyNA">NpyNA</a>*<em> na</em><big>)</big><a class="headerlink" href="#NpyNA_GetPayload" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the multi-NA payload of the NA, or 0 if <em>na</em> doesn’t have
a multi-NA payload.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/NpyNA_FromObject"></a><dt id="NpyNA_FromObject">
<a class="reference internal" href="#NpyNA" title="NpyNA">NpyNA</a>* <tt class="descname">NpyNA_FromObject</tt><big>(</big><a class="reference external" href="http://docs.python.org/dev/c-api/structures.html#PyObject" title="(in Python v3.3)">PyObject</a>*<em> obj</em>, int<em> suppress_error</em><big>)</big><a class="headerlink" href="#NpyNA_FromObject" title="Permalink to this definition">¶</a></dt>
<dd><p>If <em>obj</em> represents an object which is NA, for example if it
is an <a class="reference internal" href="#NpyNA" title="NpyNA"><tt class="xref c c-type docutils literal"><span class="pre">NpyNA</span></tt></a>, or a zero-dimensional NA-masked array with
its value hidden by the mask, returns a new reference to an
<a class="reference internal" href="#NpyNA" title="NpyNA"><tt class="xref c c-type docutils literal"><span class="pre">NpyNA</span></tt></a> object representing <em>obj</em>. Otherwise returns
NULL.</p>
<p>If <em>suppress_error</em> is true, this function doesn’t raise an exception
when the input isn’t NA and it returns NULL, otherwise it does.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/NpyNA_FromDTypeAndPayload"></a><dt id="NpyNA_FromDTypeAndPayload">
<a class="reference internal" href="#NpyNA" title="NpyNA">NpyNA</a>* <tt class="descname">NpyNA_FromDTypeAndPayload</tt><big>(</big><a class="reference internal" href="c-api.types-and-structures.html#PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a><em> *dtype</em>, int<em> multina</em>, int<em> payload</em><big>)</big><a class="headerlink" href="#NpyNA_FromDTypeAndPayload" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a new <a class="reference internal" href="#NpyNA" title="NpyNA"><tt class="xref c c-type docutils literal"><span class="pre">NpyNA</span></tt></a> instance with the specified <em>dtype</em>
and <em>payload</em>. For an NA with no dtype, provide NULL in <em>dtype</em>.</p>
<p>Until multi-NA is implemented, just pass 0 for both <em>multina</em>
and <em>payload</em>.</p>
</dd></dl>
</div>
<div class="section" id="na-mask-functions">
<h2>NA Mask Functions<a class="headerlink" href="#na-mask-functions" title="Permalink to this headline">¶</a></h2>
<p>A mask dtype can be one of three different possibilities. It can
be <a class="reference internal" href="c-api.dtype.html#NPY_BOOL" title="NPY_BOOL"><tt class="xref c c-data docutils literal"><span class="pre">NPY_BOOL</span></tt></a>, <a class="reference internal" href="c-api.dtype.html#NPY_MASK" title="NPY_MASK"><tt class="xref c c-data docutils literal"><span class="pre">NPY_MASK</span></tt></a>, or a struct dtype whose
fields are all mask dtypes.</p>
<p>A mask of <a class="reference internal" href="c-api.dtype.html#NPY_BOOL" title="NPY_BOOL"><tt class="xref c c-data docutils literal"><span class="pre">NPY_BOOL</span></tt></a> can just indicate True, with underlying
value 1, for an element that is exposed, and False, with underlying
value 0, for an element that is hidden.</p>
<p>A mask of <a class="reference internal" href="c-api.dtype.html#NPY_MASK" title="NPY_MASK"><tt class="xref c c-data docutils literal"><span class="pre">NPY_MASK</span></tt></a> can additionally carry a payload which
is a value from 0 to 127. This allows for missing data implementations
based on such masks to support multiple reasons for data being missing.</p>
<p>A mask of a struct dtype can only pair up with another struct dtype
with the same field names. In this way, each field of the mask controls
the masking for the corresponding field in the associated data array.</p>
<p>Inline functions to work with masks are as follows.</p>
<dl class="function">
<a name="//apple_ref/cpp/func/NpyMaskValue_IsExposed"></a><dt id="NpyMaskValue_IsExposed">
<a class="reference internal" href="c-api.dtype.html#npy_bool" title="npy_bool">npy_bool</a> <tt class="descname">NpyMaskValue_IsExposed</tt><big>(</big>npy_mask<em> mask</em><big>)</big><a class="headerlink" href="#NpyMaskValue_IsExposed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the data element corresponding to the mask element
can be modified, false if not.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/NpyMaskValue_GetPayload"></a><dt id="NpyMaskValue_GetPayload">
npy_uint8 <tt class="descname">NpyMaskValue_GetPayload</tt><big>(</big>npy_mask<em> mask</em><big>)</big><a class="headerlink" href="#NpyMaskValue_GetPayload" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the payload contained in the mask. The return value
is between 0 and 127.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/NpyMaskValue_Create"></a><dt id="NpyMaskValue_Create">
npy_mask <tt class="descname">NpyMaskValue_Create</tt><big>(</big><a class="reference internal" href="c-api.dtype.html#npy_bool" title="npy_bool">npy_bool</a><em> exposed</em>, npy_int8<em> payload</em><big>)</big><a class="headerlink" href="#NpyMaskValue_Create" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a mask from a flag indicating whether the element is exposed
or not and a payload value.</p>
</dd></dl>
</div>
<div class="section" id="na-mask-array-functions">
<h2>NA Mask Array Functions<a class="headerlink" href="#na-mask-array-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<a name="//apple_ref/cpp/func/PyArray_AllocateMaskNA"></a><dt id="PyArray_AllocateMaskNA">
int <tt class="descname">PyArray_AllocateMaskNA</tt><big>(</big><a class="reference internal" href="c-api.types-and-structures.html#PyArrayObject" title="PyArrayObject">PyArrayObject</a><em> *arr</em>, <a class="reference internal" href="c-api.dtype.html#npy_bool" title="npy_bool">npy_bool</a><em> ownmaskna</em>, <a class="reference internal" href="c-api.dtype.html#npy_bool" title="npy_bool">npy_bool</a><em> multina</em>, npy_mask<em> defaultmask</em><big>)</big><a class="headerlink" href="#PyArray_AllocateMaskNA" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates an NA mask for the array <em>arr</em> if necessary. If <em>ownmaskna</em>
if false, it only allocates an NA mask if none exists, but if
<em>ownmaskna</em> is true, it also allocates one if the NA mask is a view
into another array’s NA mask. Here are the two most common usage
patterns:</p>
<div class="highlight-python"><pre>/* Use this to make sure 'arr' has an NA mask */
if (PyArray_AllocateMaskNA(arr, 0, 0, 1) &lt; 0) {
    return NULL;
}

/* Use this to make sure 'arr' owns an NA mask */
if (PyArray_AllocateMaskNA(arr, 1, 0, 1) &lt; 0) {
    return NULL;
}</pre>
</div>
<p>The parameter <em>multina</em> is provided for future expansion, when
mult-NA support is added to NumPy. This will affect the dtype of
the NA mask, which currently must be always NPY_BOOL, but will be
NPY_MASK for arrays multi-NA when this is implemented.</p>
<p>When a new NA mask is allocated, and the mask needs to be filled,
it uses the value <em>defaultmask</em>. In nearly all cases, this should be set
to 1, indicating that the elements are exposed. If a mask is allocated
just because of <em>ownmaskna</em>, the existing mask values are copied
into the newly allocated mask.</p>
<p>This function returns 0 for success, -1 for failure.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/PyArray_HasNASupport"></a><dt id="PyArray_HasNASupport">
<a class="reference internal" href="c-api.dtype.html#npy_bool" title="npy_bool">npy_bool</a> <tt class="descname">PyArray_HasNASupport</tt><big>(</big><a class="reference internal" href="c-api.types-and-structures.html#PyArrayObject" title="PyArrayObject">PyArrayObject</a><em> *arr</em><big>)</big><a class="headerlink" href="#PyArray_HasNASupport" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <em>arr</em> is an array which supports NA. This function
exists because the design for adding NA proposed two mechanisms
for NAs in NumPy, NA masks and NA bitpatterns. Currently, just
NA masks have been implemented, but when NA bitpatterns are implemented
this would return true for arrays with an NA bitpattern dtype as well.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/PyArray_ContainsNA"></a><dt id="PyArray_ContainsNA">
int <tt class="descname">PyArray_ContainsNA</tt><big>(</big><a class="reference internal" href="c-api.types-and-structures.html#PyArrayObject" title="PyArrayObject">PyArrayObject</a><em> *arr</em>, <a class="reference internal" href="c-api.types-and-structures.html#PyArrayObject" title="PyArrayObject">PyArrayObject</a><em> *wheremask</em>, <a class="reference internal" href="c-api.dtype.html#npy_bool" title="npy_bool">npy_bool</a><em> *whichna</em><big>)</big><a class="headerlink" href="#PyArray_ContainsNA" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the array <em>arr</em> contains any NA values.</p>
<p>If <em>wheremask</em> is non-NULL, it must be an NPY_BOOL mask which can
broadcast onto <em>arr</em>. Whereever the where mask is True, <em>arr</em>
is checked for NA, and whereever it is False, the <em>arr</em> value is
ignored.</p>
<p>The parameter <em>whichna</em> is provided for future expansion to multi-NA
support. When implemented, this parameter will be a 128 element
array of npy_bool, with the value True for the NA values that are
being looked for.</p>
<p>This function returns 1 when the array contains NA values, 0 when
it does not, and -1 when a error has occurred.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/PyArray_AssignNA"></a><dt id="PyArray_AssignNA">
int <tt class="descname">PyArray_AssignNA</tt><big>(</big><a class="reference internal" href="c-api.types-and-structures.html#PyArrayObject" title="PyArrayObject">PyArrayObject</a><em> *arr</em>, <a class="reference internal" href="#NpyNA" title="NpyNA">NpyNA</a><em> *na</em>, <a class="reference internal" href="c-api.types-and-structures.html#PyArrayObject" title="PyArrayObject">PyArrayObject</a><em> *wheremask</em>, <a class="reference internal" href="c-api.dtype.html#npy_bool" title="npy_bool">npy_bool</a><em> preservena</em>, <a class="reference internal" href="c-api.dtype.html#npy_bool" title="npy_bool">npy_bool</a><em> *preservewhichna</em><big>)</big><a class="headerlink" href="#PyArray_AssignNA" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns the given <em>na</em> value to elements of <em>arr</em>.</p>
<p>If <em>wheremask</em> is non-NULL, it must be an NPY_BOOL array broadcastable
onto <em>arr</em>, and only elements of <em>arr</em> with a corresponding value
of True in <em>wheremask</em> will have <em>na</em> assigned.</p>
<p>The parameters <em>preservena</em> and <em>preservewhichna</em> are provided for
future expansion to multi-NA support. With a single NA value, one
NA cannot be distinguished from another, so preserving NA values
does not make sense. With multiple NA values, preserving NA values
becomes an important concept because that implies not overwriting the
multi-NA payloads. The parameter <em>preservewhichna</em> will be a 128 element
array of npy_bool, indicating which NA payloads to preserve.</p>
<p>This function returns 0 for success, -1 for failure.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/PyArray_AssignMaskNA"></a><dt id="PyArray_AssignMaskNA">
int <tt class="descname">PyArray_AssignMaskNA</tt><big>(</big><a class="reference internal" href="c-api.types-and-structures.html#PyArrayObject" title="PyArrayObject">PyArrayObject</a><em> *arr</em>, npy_mask<em> maskvalue</em>, <a class="reference internal" href="c-api.types-and-structures.html#PyArrayObject" title="PyArrayObject">PyArrayObject</a><em> *wheremask</em>, <a class="reference internal" href="c-api.dtype.html#npy_bool" title="npy_bool">npy_bool</a><em> preservena</em>, <a class="reference internal" href="c-api.dtype.html#npy_bool" title="npy_bool">npy_bool</a><em> *preservewhichna</em><big>)</big><a class="headerlink" href="#PyArray_AssignMaskNA" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns the given NA mask <em>maskvalue</em> to elements of <em>arr</em>.</p>
<p>If <em>wheremask</em> is non-NULL, it must be an NPY_BOOL array broadcastable
onto <em>arr</em>, and only elements of <em>arr</em> with a corresponding value
of True in <em>wheremask</em> will have the NA <em>maskvalue</em> assigned.</p>
<p>The parameters <em>preservena</em> and <em>preservewhichna</em> are provided for
future expansion to multi-NA support. With a single NA value, one
NA cannot be distinguished from another, so preserving NA values
does not make sense. With multiple NA values, preserving NA values
becomes an important concept because that implies not overwriting the
multi-NA payloads. The parameter <em>preservewhichna</em> will be a 128 element
array of npy_bool, indicating which NA payloads to preserve.</p>
<p>This function returns 0 for success, -1 for failure.</p>
</dd></dl>
</div>
</div>
</div>
</div>
</div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<p class="logo"><a href="../contents.html">
<img alt="Logo" class="logo" src="../_static/scipyshiny_small.png"/>
</a></p>
<h3><a href="../contents.html">Table Of Contents</a></h3>
<ul>
<li><a class="reference internal" href="#">Array NA Mask API</a><ul>
<li><a class="reference internal" href="#na-masks-in-arrays">NA Masks in Arrays</a></li>
<li><a class="reference internal" href="#the-na-object">The NA Object</a></li>
<li><a class="reference internal" href="#working-with-na-masked-arrays">Working With NA-Masked Arrays</a><ul>
<li><a class="reference internal" href="#forbidding-any-na-values">Forbidding Any NA Values</a></li>
<li><a class="reference internal" href="#manipulating-na-values">Manipulating NA Values</a></li>
<li><a class="reference internal" href="#accumulating-na-values">Accumulating NA Values</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-na-masked-operation-in-c">Example NA-Masked Operation in C</a></li>
<li><a class="reference internal" href="#na-object-data-type">NA Object Data Type</a></li>
<li><a class="reference internal" href="#na-object-functions">NA Object Functions</a></li>
<li><a class="reference internal" href="#na-mask-functions">NA Mask Functions</a></li>
<li><a class="reference internal" href="#na-mask-array-functions">NA Mask Array Functions</a></li>
</ul>
</li>
</ul>
<h4>Previous topic</h4>
<p class="topless"><a href="c-api.iterator.html" title="previous chapter">Array Iterator API</a></p>
<h4>Next topic</h4>
<p class="topless"><a href="c-api.ufunc.html" title="next chapter">UFunc API</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
<li><a href="../_sources/reference/c-api.maskna.txt" rel="nofollow">Show Source</a></li>
</ul>
<ul class="this-page-menu">
<li><a href="/numpy/docs/numpy-docs/reference/c-api.maskna.rst">Edit page</a></li>
</ul>
<div id="searchbox" style="display: none">
<h3>Quick search</h3>
<form action="../search.html" class="search" method="get">
<input name="q" size="18" type="text"/>
<input type="submit" value="Go"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
<p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
</div>
</div>
<div class="clearer"></div>
</div>
<div class="related">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a href="../genindex.html" title="General Index">index</a></li>
<li class="right">
<a href="../py-modindex.html" title="Python Module Index">modules</a> |</li>
<li class="right">
<a href="../np-modindex.html" title="Python Module Index">modules</a> |</li>
<li class="right">
<a href="c-api.ufunc.html" title="UFunc API">next</a> |</li>
<li class="right">
<a href="c-api.iterator.html" title="Array Iterator API">previous</a> |</li>
<li><a href="../index.html">NumPy v1.7.dev-3f685a1 Manual (DRAFT)</a> »</li>
<li><a href="index.html">NumPy Reference</a> »</li>
<li><a href="c-api.html">Numpy C-API</a> »</li>
</ul>
</div>
<div class="footer">
        © Copyright 2008-2009, The Scipy community.
      Last updated on Feb 24, 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
<div style="display:none;"><a name="#"></a><h3 class="tasks">TOC</h3><ul class="tooltip"><li class="tooltip"><a href="#">Array NA Mask API</a></li><li class="tooltip"><a href="#na-masks-in-arrays">NA Masks in Arrays</a></li><li class="tooltip"><a href="#the-na-object">The NA Object</a></li><li class="tooltip"><a href="#working-with-na-masked-arrays">Working With NA-Masked Arrays</a></li><li class="tooltip"><a href="#forbidding-any-na-values">Forbidding Any NA Values</a></li><li class="tooltip"><a href="#manipulating-na-values">Manipulating NA Values</a></li><li class="tooltip"><a href="#accumulating-na-values">Accumulating NA Values</a></li><li class="tooltip"><a href="#example-na-masked-operation-in-c">Example NA-Masked Operation in C</a></li><li class="tooltip"><a href="#na-object-data-type">NA Object Data Type</a></li><li class="tooltip"><a href="#na-object-functions">NA Object Functions</a></li><li class="tooltip"><a href="#na-mask-functions">NA Mask Functions</a></li><li class="tooltip"><a href="#na-mask-array-functions">NA Mask Array Functions</a></li></ul></div></body></html>