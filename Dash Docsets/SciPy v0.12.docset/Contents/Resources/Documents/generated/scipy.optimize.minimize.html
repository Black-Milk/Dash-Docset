<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><title>scipy.optimize.minimize — SciPy v0.12 Reference Guide (DRAFT)</title><link href="../_static/scipy.css" rel="stylesheet" type="text/css"/><link href="../_static/pygments.css" rel="stylesheet" type="text/css"/><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.12.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script><script src="../_static/jquery.js" type="text/javascript"></script><script src="../_static/underscore.js" type="text/javascript"></script><script src="../_static/doctools.js" type="text/javascript"></script><link href="../index.html" rel="top" title="SciPy v0.12 Reference Guide (DRAFT)"/><link href="../optimize.html" rel="up" title="Optimization and root finding (scipy.optimize)"/><link href="scipy.optimize.fmin.html" rel="next" title="scipy.optimize.fmin"/><link href="../optimize.nonlin.html" rel="prev" title="Nonlinear solvers"/></head><body>
<div class="related">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a accesskey="I" href="../genindex.html" title="General Index">index</a></li>
<li class="right">
<a href="../py-modindex.html" title="Python Module Index">modules</a> |</li>
<li class="right">
<a href="../np-modindex.html" title="Python Module Index">modules</a> |</li>
<li class="right">
<a accesskey="N" href="scipy.optimize.fmin.html" title="scipy.optimize.fmin">next</a> |</li>
<li class="right">
<a accesskey="P" href="../optimize.nonlin.html" title="Nonlinear solvers">previous</a> |</li>
<li><a href="../index.html">SciPy v0.12 Reference Guide (DRAFT)</a> »</li>
<li><a accesskey="U" href="../optimize.html">Optimization and root finding (<tt class="docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal"><span class="pre">scipy.optimize</span></tt>)</a> »</li>
</ul>
</div>
<div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body">
<div class="section" id="scipy-optimize-minimize">
<h1>scipy.optimize.minimize<a class="headerlink" href="#scipy-optimize-minimize" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="scipy.optimize.minimize"><a name="//apple_ref/cpp/func/scipy.optimize.minimize"></a>
<tt class="descclassname">scipy.optimize.</tt><tt class="descname">minimize</tt><big>(</big><em>fun</em>, <em>x0</em>, <em>args=()</em>, <em>method='BFGS'</em>, <em>jac=None</em>, <em>hess=None</em>, <em>hessp=None</em>, <em>bounds=None</em>, <em>constraints=()</em>, <em>tol=None</em>, <em>callback=None</em>, <em>options=None</em><big>)</big><a class="reference external" href="http://github.com/scipy/scipy/blob/v0.12.0/scipy/optimize/_minimize.py#L34"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scipy.optimize.minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimization of scalar function of one or more variables.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.11.0.</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>fun</strong> : callable</p>
<blockquote>
<div><p>Objective function.</p>
</div></blockquote>
<p><strong>x0</strong> : ndarray</p>
<blockquote>
<div><p>Initial guess.</p>
</div></blockquote>
<p><strong>args</strong> : tuple, optional</p>
<blockquote>
<div><p>Extra arguments passed to the objective function and its
derivatives (Jacobian, Hessian).</p>
</div></blockquote>
<p><strong>method</strong> : str, optional</p>
<blockquote>
<div><p>Type of solver.  Should be one of</p>
<blockquote>
<div><ul class="simple">
<li>‘Nelder-Mead’</li>
<li>‘Powell’</li>
<li>‘CG’</li>
<li>‘BFGS’</li>
<li>‘Newton-CG’</li>
<li>‘Anneal’</li>
<li>‘L-BFGS-B’</li>
<li>‘TNC’</li>
<li>‘COBYLA’</li>
<li>‘SLSQP’</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>jac</strong> : bool or callable, optional</p>
<blockquote>
<div><p>Jacobian of objective function. Only for CG, BFGS, Newton-CG.
If <em class="xref py py-obj">jac</em> is a Boolean and is True, <em class="xref py py-obj">fun</em> is assumed to return the
value of Jacobian along with the objective function. If False, the
Jacobian will be estimated numerically.
<em class="xref py py-obj">jac</em> can also be a callable returning the Jacobian of the
objective. In this case, it must accept the same arguments as <em class="xref py py-obj">fun</em>.</p>
</div></blockquote>
<p><strong>hess, hessp</strong> : callable, optional</p>
<blockquote>
<div><p>Hessian of objective function or Hessian of objective function
times an arbitrary vector p.  Only for Newton-CG.
Only one of <em class="xref py py-obj">hessp</em> or <em class="xref py py-obj">hess</em> needs to be given.  If <em class="xref py py-obj">hess</em> is
provided, then <em class="xref py py-obj">hessp</em> will be ignored.  If neither <em class="xref py py-obj">hess</em> nor
<em class="xref py py-obj">hessp</em> is provided, then the hessian product will be approximated
using finite differences on <em class="xref py py-obj">jac</em>. <em class="xref py py-obj">hessp</em> must compute the Hessian
times an arbitrary vector.</p>
</div></blockquote>
<p><strong>bounds</strong> : sequence, optional</p>
<blockquote>
<div><p>Bounds for variables (only for L-BFGS-B, TNC, COBYLA and SLSQP).
<tt class="docutils literal"><span class="pre">(min,</span> <span class="pre">max)</span></tt> pairs for each element in <tt class="docutils literal"><span class="pre">x</span></tt>, defining
the bounds on that parameter. Use None for one of <tt class="docutils literal"><span class="pre">min</span></tt> or
<tt class="docutils literal"><span class="pre">max</span></tt> when there is no bound in that direction.</p>
</div></blockquote>
<p><strong>constraints</strong> : dict or sequence of dict, optional</p>
<blockquote>
<div><p>Constraints definition (only for COBYLA and SLSQP).
Each constraint is defined in a dictionary with fields:</p>
<blockquote>
<div><dl class="docutils">
<dt>type <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Constraint type: ‘eq’ for equality, ‘ineq’ for inequality.</p>
</dd>
<dt>fun <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">The function defining the constraint.</p>
</dd>
<dt>jac <span class="classifier-delimiter">:</span> <span class="classifier">callable, optional</span></dt>
<dd><p class="first last">The Jacobian of <em class="xref py py-obj">fun</em> (only for SLSQP).</p>
</dd>
<dt>args <span class="classifier-delimiter">:</span> <span class="classifier">sequence, optional</span></dt>
<dd><p class="first last">Extra arguments to be passed to the function and Jacobian.</p>
</dd>
</dl>
</div></blockquote>
<p>Equality constraint means that the constraint function result is to
be zero whereas inequality means that it is to be non-negative.
Note that COBYLA only supports inequality constraints.</p>
</div></blockquote>
<p><strong>tol</strong> : float, optional</p>
<blockquote>
<div><p>Tolerance for termination. For detailed control, use solver-specific
options.</p>
</div></blockquote>
<p><strong>options</strong> : dict, optional</p>
<blockquote>
<div><p>A dictionary of solver options. All methods accept the following
generic options:</p>
<blockquote>
<div><dl class="docutils">
<dt>maxiter <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of iterations to perform.</p>
</dd>
<dt>disp <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Set to True to print convergence messages.</p>
</dd>
</dl>
</div></blockquote>
<p>For method-specific options, see <em class="xref py py-obj">show_options(‘minimize’, method)</em>.</p>
</div></blockquote>
<p><strong>callback</strong> : callable, optional</p>
<blockquote>
<div><p>Called after each iteration, as <tt class="docutils literal"><span class="pre">callback(xk)</span></tt>, where <tt class="docutils literal"><span class="pre">xk</span></tt> is the
current parameter vector.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>res</strong> : Result</p>
<blockquote class="last">
<div><p>The optimization result represented as a <tt class="docutils literal"><span class="pre">Result</span></tt> object.
Important attributes are: <tt class="docutils literal"><span class="pre">x</span></tt> the solution array, <tt class="docutils literal"><span class="pre">success</span></tt> a
Boolean flag indicating if the optimizer exited successfully and
<tt class="docutils literal"><span class="pre">message</span></tt> which describes the cause of the termination. See
<tt class="xref py py-obj docutils literal"><span class="pre">Result</span></tt> for a description of other attributes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar" title="scipy.optimize.minimize_scalar"><tt class="xref py py-obj docutils literal"><span class="pre">minimize_scalar</span></tt></a></dt>
<dd>Interface to minimization algorithms for scalar univariate functions.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This section describes the available solvers that can be selected by the
‘method’ parameter. The default method is <em>BFGS</em>.</p>
<p><strong>Unconstrained minimization</strong></p>
<p>Method <em>Nelder-Mead</em> uses the Simplex algorithm <a class="reference internal" href="#r79">[R79]</a>, <a class="reference internal" href="#r80">[R80]</a>. This
algorithm has been successful in many applications but other algorithms
using the first and/or second derivatives information might be preferred
for their better performances and robustness in general.</p>
<p>Method <em>Powell</em> is a modification of Powell’s method <a class="reference internal" href="#r81">[R81]</a>, <a class="reference internal" href="#r82">[R82]</a> which
is a conjugate direction method. It performs sequential one-dimensional
minimizations along each vector of the directions set (<em class="xref py py-obj">direc</em> field in
<em class="xref py py-obj">options</em> and <em class="xref py py-obj">info</em>), which is updated at each iteration of the main
minimization loop. The function need not be differentiable, and no
derivatives are taken.</p>
<p>Method <em>CG</em> uses a nonlinear conjugate gradient algorithm by Polak and
Ribiere, a variant of the Fletcher-Reeves method described in <a class="reference internal" href="#r83">[R83]</a> pp.
120-122. Only the first derivatives are used.</p>
<p>Method <em>BFGS</em> uses the quasi-Newton method of Broyden, Fletcher,
Goldfarb, and Shanno (BFGS) <a class="reference internal" href="#r83">[R83]</a> pp. 136. It uses the first derivatives
only. BFGS has proven good performance even for non-smooth
optimizations</p>
<p>Method <em>Newton-CG</em> uses a Newton-CG algorithm <a class="reference internal" href="#r83">[R83]</a> pp. 168 (also known
as the truncated Newton method). It uses a CG method to the compute the
search direction. See also <em>TNC</em> method for a box-constrained
minimization with a similar algorithm.</p>
<p>Method <em>Anneal</em> uses simulated annealing, which is a probabilistic
metaheuristic algorithm for global optimization. It uses no derivative
information from the function being optimized.</p>
<p><strong>Constrained minimization</strong></p>
<p>Method <em>L-BFGS-B</em> uses the L-BFGS-B algorithm <a class="reference internal" href="#r84">[R84]</a>, <a class="reference internal" href="#r85">[R85]</a> for bound
constrained minimization.</p>
<p>Method <em>TNC</em> uses a truncated Newton algorithm <a class="reference internal" href="#r83">[R83]</a>, <a class="reference internal" href="#r86">[R86]</a> to minimize a
function with variables subject to bounds. This algorithm is uses
gradient information; it is also called Newton Conjugate-Gradient. It
differs from the <em>Newton-CG</em> method described above as it wraps a C
implementation and allows each variable to be given upper and lower
bounds.</p>
<p>Method <em>COBYLA</em> uses the Constrained Optimization BY Linear
Approximation (COBYLA) method <a class="reference internal" href="#r87">[R87]</a>, <a class="footnote-reference" href="#id16" id="id13">[10]</a>, <a class="footnote-reference" href="#id17" id="id14">[11]</a>. The algorithm is
based on linear approximations to the objective function and each
constraint. The method wraps a FORTRAN implementation of the algorithm.</p>
<p>Method <em>SLSQP</em> uses Sequential Least SQuares Programming to minimize a
function of several variables with any combination of bounds, equality
and inequality constraints. The method wraps the SLSQP Optimization
subroutine originally implemented by Dieter Kraft <a class="footnote-reference" href="#id18" id="id15">[12]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r79" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label">[R79]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id19">2</a>)</em> Nelder, J A, and R Mead. 1965. A Simplex Method for Function
Minimization. The Computer Journal 7: 308-13.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r80" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label">[R80]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id20">2</a>)</em> Wright M H. 1996. Direct search methods: Once scorned, now
respectable, in Numerical Analysis 1995: Proceedings of the 1995
Dundee Biennial Conference in Numerical Analysis (Eds. D F
Griffiths and G A Watson). Addison Wesley Longman, Harlow, UK.
191-208.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r81" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label">[R81]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id21">2</a>)</em> Powell, M J D. 1964. An efficient method for finding the minimum of
a function of several variables without calculating derivatives. The
Computer Journal 7: 155-162.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r82" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label">[R82]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id22">2</a>)</em> Press W, S A Teukolsky, W T Vetterling and B P Flannery.
Numerical Recipes (any edition), Cambridge University Press.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r83" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label">[R83]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id6">2</a>, <a class="fn-backref" href="#id7">3</a>, <a class="fn-backref" href="#id10">4</a>, <a class="fn-backref" href="#id23">5</a>, <a class="fn-backref" href="#id31">6</a>)</em> Nocedal, J, and S J Wright. 2006. Numerical Optimization.
Springer New York.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r84" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label">[R84]</td><td><em>(<a class="fn-backref" href="#id8">1</a>, <a class="fn-backref" href="#id24">2</a>)</em> Byrd, R H and P Lu and J. Nocedal. 1995. A Limited Memory
Algorithm for Bound Constrained Optimization. SIAM Journal on
Scientific and Statistical Computing 16 (5): 1190-1208.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r85" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label">[R85]</td><td><em>(<a class="fn-backref" href="#id9">1</a>, <a class="fn-backref" href="#id25">2</a>)</em> Zhu, C and R H Byrd and J Nocedal. 1997. L-BFGS-B: Algorithm
778: L-BFGS-B, FORTRAN routines for large scale bound constrained
optimization. ACM Transactions on Mathematical Software 23 (4):
550-560.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r86" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label">[R86]</td><td><em>(<a class="fn-backref" href="#id11">1</a>, <a class="fn-backref" href="#id26">2</a>)</em> Nash, S G. Newton-Type Minimization Via the Lanczos Method.
1984. SIAM Journal of Numerical Analysis 21: 770-778.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r87" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label">[R87]</td><td><em>(<a class="fn-backref" href="#id12">1</a>, <a class="fn-backref" href="#id27">2</a>)</em> Powell, M J D. A direct search optimization method that models
the objective and constraint functions by linear interpolation.
1994. Advances in Optimization and Numerical Analysis, eds. S. Gomez
and J-P Hennart, Kluwer Academic (Dordrecht), 51-67.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label">[10]</td><td><em>(<a class="fn-backref" href="#id13">1</a>, <a class="fn-backref" href="#id28">2</a>)</em> Powell M J D. Direct search algorithms for optimization
calculations. 1998. Acta Numerica 7: 287-336.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label">[11]</td><td><em>(<a class="fn-backref" href="#id14">1</a>, <a class="fn-backref" href="#id29">2</a>)</em> Powell M J D. A view of algorithms for optimization without
derivatives. 2007.Cambridge University Technical Report DAMTP
2007/NA03</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label">[12]</td><td><em>(<a class="fn-backref" href="#id15">1</a>, <a class="fn-backref" href="#id30">2</a>)</em> Kraft, D. A software package for sequential quadratic
programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace
Center – Institute for Flight Mechanics, Koln, Germany.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Let us consider the problem of minimizing the Rosenbrock function. This
function (and its respective derivatives) is implemented in <a class="reference internal" href="scipy.optimize.rosen.html#scipy.optimize.rosen" title="scipy.optimize.rosen"><tt class="xref py py-obj docutils literal"><span class="pre">rosen</span></tt></a>
(resp. <a class="reference internal" href="scipy.optimize.rosen_der.html#scipy.optimize.rosen_der" title="scipy.optimize.rosen_der"><tt class="xref py py-obj docutils literal"><span class="pre">rosen_der</span></tt></a>, <a class="reference internal" href="scipy.optimize.rosen_hess.html#scipy.optimize.rosen_hess" title="scipy.optimize.rosen_hess"><tt class="xref py py-obj docutils literal"><span class="pre">rosen_hess</span></tt></a>) in the <a class="reference internal" href="../optimize.html#module-scipy.optimize" title="scipy.optimize"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.optimize</span></tt></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span><span class="p">,</span> <span class="n">rosen</span><span class="p">,</span> <span class="n">rosen_der</span>
</pre></div>
</div>
<p>A simple application of the <em>Nelder-Mead</em> method is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">'Nelder-Mead'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">[ 1.  1.  1.  1.  1.]</span>
</pre></div>
</div>
<p>Now using the <em>BFGS</em> algorithm, using the first derivative and a few
options:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">'BFGS'</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">'gtol'</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="s">'disp'</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 0.000000</span>
<span class="go">         Iterations: 52</span>
<span class="go">         Function evaluations: 64</span>
<span class="go">         Gradient evaluations: 64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">[ 1.  1.  1.  1.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">res</span><span class="o">.</span><span class="n">message</span>
<span class="go">Optimization terminated successfully.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">hess</span>
<span class="go">[[ 0.00749589  0.01255155  0.02396251  0.04750988  0.09495377]</span>
<span class="go"> [ 0.01255155  0.02510441  0.04794055  0.09502834  0.18996269]</span>
<span class="go"> [ 0.02396251  0.04794055  0.09631614  0.19092151  0.38165151]</span>
<span class="go"> [ 0.04750988  0.09502834  0.19092151  0.38341252  0.7664427 ]</span>
<span class="go"> [ 0.09495377  0.18996269  0.38165151  0.7664427   1.53713523]]</span>
</pre></div>
</div>
<p>Next, consider a minimization problem with several constraints (namely
Example 16.4 from <a class="reference internal" href="#r83">[R83]</a>). The objective function is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>There are three constraints defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cons</span> <span class="o">=</span> <span class="p">({</span><span class="s">'type'</span><span class="p">:</span> <span class="s">'ineq'</span><span class="p">,</span> <span class="s">'fun'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>  <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s">'type'</span><span class="p">:</span> <span class="s">'ineq'</span><span class="p">,</span> <span class="s">'fun'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">6</span><span class="p">},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s">'type'</span><span class="p">:</span> <span class="s">'ineq'</span><span class="p">,</span> <span class="s">'fun'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">})</span>
</pre></div>
</div>
<p>And variables must be positive, hence the following bounds:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bnds</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
</pre></div>
</div>
<p>The optimization problem is solved using the SLSQP method as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s">'SLSQP'</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bnds</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">)</span>
</pre></div>
</div>
<p>It should converge to the theoretical solution (1.4 ,1.7).</p>
</dd></dl>
</div>
</div>
</div>
</div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<p class="logo"><a href="../index.html">
<img alt="Logo" class="logo" src="../_static/scipyshiny_small.png"/>
</a></p>
<h4>Previous topic</h4>
<p class="topless"><a href="../optimize.nonlin.html" title="previous chapter">Nonlinear solvers</a></p>
<h4>Next topic</h4>
<p class="topless"><a href="scipy.optimize.fmin.html" title="next chapter">scipy.optimize.fmin</a></p>
<div id="searchbox" style="display: none">
<h3>Quick search</h3>
<form action="../search.html" class="search" method="get">
<input name="q" type="text"/>
<input type="submit" value="Go"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
<p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
</div>
</div>
<div class="clearer"></div>
</div>
<div class="related">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a href="../genindex.html" title="General Index">index</a></li>
<li class="right">
<a href="../py-modindex.html" title="Python Module Index">modules</a> |</li>
<li class="right">
<a href="../np-modindex.html" title="Python Module Index">modules</a> |</li>
<li class="right">
<a href="scipy.optimize.fmin.html" title="scipy.optimize.fmin">next</a> |</li>
<li class="right">
<a href="../optimize.nonlin.html" title="Nonlinear solvers">previous</a> |</li>
<li><a href="../index.html">SciPy v0.12 Reference Guide (DRAFT)</a> »</li>
<li><a href="../optimize.html">Optimization and root finding (<tt class="docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal"><span class="pre">scipy.optimize</span></tt>)</a> »</li>
</ul>
</div>
<div class="footer">
        © Copyright 2008-2009, The Scipy community.
      Last updated on May 01, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
</body></html>