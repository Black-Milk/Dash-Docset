
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
  
    <title>Working With Text Data &mdash; scikit-learn 0.14.1 documentation</title>
  <!-- htmltitle is before nature.css - we use this hack to load bootstrap first -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="../../_static/css/bootstrap.min.css" media="screen" />
  <link rel="stylesheet" href="../../_static/css/bootstrap-responsive.css"/>

    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.14.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/js/copybutton.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="top" title="scikit-learn 0.14.1 documentation" href="../../index.html" />
    <link rel="up" title="scikit-learn Tutorials" href="../index.html" />
    <link rel="next" title="&lt;no title&gt;" href="../../user_guide.html" />
    <link rel="prev" title="Finding help" href="../statistical_inference/finding_help.html" />
  
   
       <script type="text/javascript" src="../../_static/sidebar.js"></script>
   
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="../../_static/js/bootstrap.min.js" type="text/javascript"></script>
  <link rel="canonical" href="http://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html" />

  <script type="text/javascript">
    $("div.buttonNext, div.buttonPrevious").hover(
       function () {
           $(this).css('background-color', '#FF9C34');
       },
       function () {
           $(this).css('background-color', '#A7D6E2');
       }
    );
    var bodywrapper = $('.bodywrapper');
    var sidebarbutton = $('#sidebarbutton');
    sidebarbutton.css({'height': '900px'});
  </script>

  </head>
  <body>

<div class="header-wrapper">
    <div class="header">
        <p class="logo"><a href="../../index.html">
            <img src="../../_static/scikit-learn-logo-small.png" alt="Logo"/>
        </a>
        </p><div class="navbar">
            <ul>
                <li><a href="../../../stable/index.html">Home</a></li>
                <li><a href="../../../stable/install.html">Installation</a></li>
                <li class="btn-li"><div class="btn-group">
		      <a href="../../documentation.html">Documentation</a>
		      <a class="btn dropdown-toggle" data-toggle="dropdown">
			     <span class="caret"></span>
		      </a>
		      <ul class="dropdown-menu">
			<li class="link-title">Scikit-learn 0.14 (stable)</li>
			<li><a href="../index.html">Tutorials</a></li>
			<li><a href="../../user_guide.html">User guide</a></li>
			<li><a href="../../modules/classes.html">API</a></li>
			<li class="divider"></li>
		        <li><a href="http://scikit-learn.org/dev/documentation.html">Development</a></li>
		        <li><a href="http://scikit-learn.org/0.13/">Scikit-learn 0.13</a></li>
		        <li><a href="http://scikit-learn.org/0.12/">Scikit-learn 0.12</a></li>
		        <li><a href="http://scikit-learn.org/0.11/">Scikit-learn 0.11</a></li>
		        <li><a href="../../documentation.html">More versions...</a></li>
		      </ul>
		    </div>
		</li>
            <li><a href="../../auto_examples/index.html">Examples</a></li>
            </ul>

            <div class="search_form">
                <div id="cse" style="width: 100%;"></div>
            </div>
        </div> <!-- end navbar --></div>
</div>


<!-- Github "fork me" ribbon -->
<a href="https://github.com/scikit-learn/scikit-learn">
  <img class="fork-me"
       style="position: absolute; top: 0; right: 0; border: 0;"
       src="../../_static/img/forkme.png"
       alt="Fork me on GitHub" />
</a>

<div class="content-wrapper">
    <div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
        <div class="rel">
    

  <!-- rellinks[1:] is an ugly hack to avoid link to module
  index -->
        <div class="rellink">
        <a href="../statistical_inference/finding_help.html"
        accesskey="P">Previous
        <br/>
        <span class="smallrellink">
        Finding help
        </span>
            <span class="hiddenrellink">
            Finding help
            </span>
        </a>
        </div>
            <div class="spacer">
            &nbsp;
            </div>
        <div class="rellink">
        <a href="../../user_guide.html"
        accesskey="N">Next
        <br/>
        <span class="smallrellink">
        <no title>
        </span>
            <span class="hiddenrellink">
            <no title>
            </span>
        </a>
        </div>
            <div class="spacer">
            &nbsp;
            </div>
        <div class="rellink">
        <a href="../../np-modindex.html"
        >Modules
        <br/>
        <span class="smallrellink">
        Python Module In...
        </span>
            <span class="hiddenrellink">
            Python Module Index
            </span>
        </a>
        </div>
            <div class="spacer">
            &nbsp;
            </div>
        <div class="rellink">
        <a href="../../py-modindex.html"
        >Modules
        <br/>
        <span class="smallrellink">
        Python Module In...
        </span>
            <span class="hiddenrellink">
            Python Module Index
            </span>
        </a>
        </div>

    <!-- Ad a link to the 'up' page -->
        <div class="spacer">
        &nbsp;
        </div>
        <div class="rellink">
        <a href="../index.html">
        Up
        <br/>
        <span class="smallrellink">
        scikit-learn Tut...
        </span>
            <span class="hiddenrellink">
            scikit-learn Tutorials
            </span>
            
        </a>
        </div>
    </div>
    
      <p class="doc-version">This documentation is for scikit-learn <strong>version 0.14.1</strong> &mdash; <a href="http://scikit-learn.org/stable/support.html#documentation-resources">Other versions</a></p>
    <p class="citing">If you use the software, please consider <a href="../../about.html#citing-scikit-learn">citing scikit-learn</a>.</p>
    <ul>
<li><a class="reference internal" href="#">Working With Text Data</a><ul>
<li><a class="reference internal" href="#tutorial-setup">Tutorial setup</a></li>
<li><a class="reference internal" href="#loading-the-20-newgroups-dataset">Loading the 20 newgroups dataset</a></li>
<li><a class="reference internal" href="#extracting-features-from-text-files">Extracting features from text files</a><ul>
<li><a class="reference internal" href="#bags-of-words">Bags of words</a></li>
<li><a class="reference internal" href="#tokenizing-text-with-scikit-learn">Tokenizing text with <tt class="docutils literal"><span class="pre">scikit-learn</span></tt></a></li>
<li><a class="reference internal" href="#from-occurrences-to-frequencies">From occurrences to frequencies</a></li>
</ul>
</li>
<li><a class="reference internal" href="#training-a-classifier">Training a classifier</a></li>
<li><a class="reference internal" href="#building-a-pipeline">Building a pipeline</a></li>
<li><a class="reference internal" href="#evaluation-of-the-performance-on-the-test-set">Evaluation of the performance on the test set</a></li>
<li><a class="reference internal" href="#parameter-tuning-using-grid-search">Parameter tuning using grid search</a></li>
<li><a class="reference internal" href="#exercise-1-language-identification">Exercise 1: Language identification</a></li>
<li><a class="reference internal" href="#exercise-2-sentiment-analysis-on-movie-reviews">Exercise 2: Sentiment Analysis on movie reviews</a></li>
<li><a class="reference internal" href="#exercise-3-cli-text-classification-utility">Exercise 3: CLI text classification utility</a></li>
<li><a class="reference internal" href="#where-to-from-here">Where to from here</a></li>
</ul>
</li>
</ul>

    </div>
</div>



      <div class="content">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="working-with-text-data">
<span id="text-data-tutorial"></span><h1>Working With Text Data<a class="headerlink" href="#working-with-text-data" title="Permalink to this headline">¶</a></h1>
<p>The goal of this guide is to explore some of the main <tt class="docutils literal"><span class="pre">scikit-learn</span></tt>
tools on a single practical task: analysing a collection of text
documents (newsgroups posts) on twenty different topics.</p>
<p>In this section we will see how to:</p>
<blockquote>
<div><ul class="simple">
<li>load the file contents and the categories</li>
<li>extract feature vectors suitable for machine learning</li>
<li>train a linear model to perform categorization</li>
<li>use a grid search strategy to find a good configuration of both
the feature extraction components and the classifier</li>
</ul>
</div></blockquote>
<div class="section" id="tutorial-setup">
<h2>Tutorial setup<a class="headerlink" href="#tutorial-setup" title="Permalink to this headline">¶</a></h2>
<p>To get started with this tutorial, you firstly must have the
<em>scikit-learn</em> and all of its requiered dependencies installed.</p>
<p>Please refer to the <a class="reference external" href="http://scikit-learn.sourceforge.net/install.html">scikit-learn install</a> page for more information
and for per-system instructions.</p>
<p>The source of this tutorial can be found within your
scikit-learn folder:</p>
<div class="highlight-python"><div class="highlight"><pre>scikit-learn/doc/tutorial/text_analytics/
</pre></div>
</div>
<p>The tutorial folder, should contain the following folders:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">*.rst</span> <span class="pre">files</span></tt> - the source of the tutorial document written with sphinx</li>
<li><tt class="docutils literal"><span class="pre">data</span></tt> - folder to put the datasets used during the tutorial</li>
<li><tt class="docutils literal"><span class="pre">skeletons</span></tt> - sample incomplete scripts for the exercices</li>
<li><tt class="docutils literal"><span class="pre">solutions</span></tt> - solutions of the exercices</li>
</ul>
</div></blockquote>
<p>You can already copy the skeletons into a new folder somewhere
on your hard-drive named <tt class="docutils literal"><span class="pre">sklearn_tut_workspace</span></tt> where you
will edit your own files for the exercices while keeping
the original skeletons intact:</p>
<div class="highlight-python"><div class="highlight"><pre>% cp -r skeletons work_directory/sklearn_tut_workspace
</pre></div>
</div>
<p>Machine Learning algorithms need data. Go to each <tt class="docutils literal"><span class="pre">$TUTORIAL_HOME/data</span></tt>
sub-folder and run the <tt class="docutils literal"><span class="pre">fetch_data.py</span></tt> script from there (after
having read them first).</p>
<p>For instance:</p>
<div class="highlight-python"><div class="highlight"><pre>% cd $TUTORIAL_HOME/data/languages
% less fetch_data.py
% python fetch_data.py
</pre></div>
</div>
</div>
<div class="section" id="loading-the-20-newgroups-dataset">
<h2>Loading the 20 newgroups dataset<a class="headerlink" href="#loading-the-20-newgroups-dataset" title="Permalink to this headline">¶</a></h2>
<p>The dataset is called &#8220;Twenty Newsgroups&#8221;. Here is the official
description, quoted from the <a class="reference external" href="http://people.csail.mit.edu/jrennie/20Newsgroups/">website</a>:</p>
<blockquote>
<div>The 20 Newsgroups data set is a collection of approximately 20,000
newsgroup documents, partitioned (nearly) evenly across 20 different
newsgroups. To the best of our knowledge, it was originally collected
by Ken Lang, probably for his paper &#8220;Newsweeder: Learning to filter
netnews,&#8221; though he does not explicitly mention this collection.
The 20 newsgroups collection has become a popular data set for
experiments in text applications of machine learning techniques,
such as text classification and text clustering.</div></blockquote>
<p>In the following we will use the built-in dataset loader for 20 newsgroups
from scikit-learn. Alternatively, it is possible to download the dataset
manually from the web-site and use the <a class="reference internal" href="../../modules/generated/sklearn.datasets.load_files.html#sklearn.datasets.load_files" title="sklearn.datasets.load_files"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.datasets.load_files</span></tt></a>
function by pointing it to the <tt class="docutils literal"><span class="pre">20news-bydate-train</span></tt> subfolder of the
uncompressed archive folder.</p>
<p>In order to get faster execution times for this first example we will
work on a partial dataset with only 4 categories out of the 20 available
in the dataset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">categories</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;alt.atheism&#39;</span><span class="p">,</span> <span class="s">&#39;soc.religion.christian&#39;</span><span class="p">,</span>
<span class="gp">... </span>              <span class="s">&#39;comp.graphics&#39;</span><span class="p">,</span> <span class="s">&#39;sci.med&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>We can now load the list of files matching those categories as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">fetch_20newsgroups</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">twenty_train</span> <span class="o">=</span> <span class="n">fetch_20newsgroups</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s">&#39;train&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">categories</span><span class="o">=</span><span class="n">categories</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
<p>The returned dataset is a <tt class="docutils literal"><span class="pre">scikit-learn</span></tt> &#8220;bunch&#8221;: a simple holder
object with fields that can be both accessed as python <tt class="docutils literal"><span class="pre">dict</span></tt>
keys or <tt class="docutils literal"><span class="pre">object</span></tt> attributes for convenience, for instance the
<tt class="docutils literal"><span class="pre">target_names</span></tt> holds the list of the requested category names:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">twenty_train</span><span class="o">.</span><span class="n">target_names</span>
<span class="go">[&#39;alt.atheism&#39;, &#39;comp.graphics&#39;, &#39;sci.med&#39;, &#39;soc.religion.christian&#39;]</span>
</pre></div>
</div>
<p>The files themselves are loaded in memory in the <tt class="docutils literal"><span class="pre">data</span></tt> attribute. For
reference the filenames are also available:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">twenty_train</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="go">2257</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">twenty_train</span><span class="o">.</span><span class="n">filenames</span><span class="p">)</span>
<span class="go">2257</span>
</pre></div>
</div>
<p>Let&#8217;s print the first lines of the first loaded file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">twenty_train</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">From: sd345@city.ac.uk (Michael Collier)</span>
<span class="go">Subject: Converting images to HP LaserJet III?</span>
<span class="go">Nntp-Posting-Host: hampton</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">twenty_train</span><span class="o">.</span><span class="n">target_names</span><span class="p">[</span><span class="n">twenty_train</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="go">comp.graphics</span>
</pre></div>
</div>
<p>Supervised learning algorithms will require a category label for each
document in the training set. In this case the category is the name of the
newsgroup which also happens to be the name of the folder holding the
individual documents.</p>
<p>For speed and space efficiency reasons <tt class="docutils literal"><span class="pre">scikit-learn</span></tt> loads the
target attribute as an array of integers that corresponds to the
index of the category name in the <tt class="docutils literal"><span class="pre">target_names</span></tt> list. The category
integer id of each sample is stored in the <tt class="docutils literal"><span class="pre">target</span></tt> attribute:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">twenty_train</span><span class="o">.</span><span class="n">target</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>
<span class="go">array([1, 1, 3, 3, 3, 3, 3, 2, 2, 2])</span>
</pre></div>
</div>
<p>It is possible to get back the category names as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">twenty_train</span><span class="o">.</span><span class="n">target</span><span class="p">[:</span><span class="mi">10</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">twenty_train</span><span class="o">.</span><span class="n">target_names</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">comp.graphics</span>
<span class="go">comp.graphics</span>
<span class="go">soc.religion.christian</span>
<span class="go">soc.religion.christian</span>
<span class="go">soc.religion.christian</span>
<span class="go">soc.religion.christian</span>
<span class="go">soc.religion.christian</span>
<span class="go">sci.med</span>
<span class="go">sci.med</span>
<span class="go">sci.med</span>
</pre></div>
</div>
<p>You can notice that the samples have been shuffled randomly (with
a fixed RNG seed): this is useful if you select only the first
samples to quickly train a model and get a first idea of the results
before re-training on the complete dataset later.</p>
</div>
<div class="section" id="extracting-features-from-text-files">
<h2>Extracting features from text files<a class="headerlink" href="#extracting-features-from-text-files" title="Permalink to this headline">¶</a></h2>
<p>In order to perform machine learning on text documents, we first need to
turn the text content into numerical feature vectors.</p>
<div class="section" id="bags-of-words">
<h3>Bags of words<a class="headerlink" href="#bags-of-words" title="Permalink to this headline">¶</a></h3>
<p>The most intuitive way to do so is the bags of words representation:</p>
<blockquote>
<div><ol class="arabic simple">
<li>assign a fixed integer id to each word occurring in any document
of the training set (for instance by building a dictionary
from words to integer indices).</li>
<li>for each document <tt class="docutils literal"><span class="pre">#i</span></tt>, count the number of occurrences of each
word <tt class="docutils literal"><span class="pre">w</span></tt> and store it in <tt class="docutils literal"><span class="pre">X[i,</span> <span class="pre">j]</span></tt> as the value of feature
<tt class="docutils literal"><span class="pre">#j</span></tt> where <tt class="docutils literal"><span class="pre">j</span></tt> is the index of word <tt class="docutils literal"><span class="pre">w</span></tt> in the dictionary</li>
</ol>
</div></blockquote>
<p>The bags of words representation implies that <tt class="docutils literal"><span class="pre">n_features</span></tt> is
the number of distinct words in the corpus: this number is typically
larger that 100,000.</p>
<p>If <tt class="docutils literal"><span class="pre">n_samples</span> <span class="pre">==</span> <span class="pre">10000</span></tt>, storing <tt class="docutils literal"><span class="pre">X</span></tt> as a numpy array of type
float32 would require 10000 x 100000 x 4 bytes = <strong>4GB in RAM</strong> which
is barely manageable on today&#8217;s computers.</p>
<p>Fortunately, <strong>most values in X will be zeros</strong> since for a given
document less than a couple thousands of distinct words will be
used. For this reason we say that bags of words are typically
<strong>high-dimensional sparse datasets</strong>. We can save a lot of memory by
only storing the non-zero parts of the feature vectors in memory.</p>
<p><tt class="docutils literal"><span class="pre">scipy.sparse</span></tt> matrices are data structures that do exactly this,
and <tt class="docutils literal"><span class="pre">scikit-learn</span></tt> has built-in support for these structures.</p>
</div>
<div class="section" id="tokenizing-text-with-scikit-learn">
<h3>Tokenizing text with <tt class="docutils literal"><span class="pre">scikit-learn</span></tt><a class="headerlink" href="#tokenizing-text-with-scikit-learn" title="Permalink to this headline">¶</a></h3>
<p>Text preprocessing, tokenizing and filtering of stopwords are included in a high level component that is able to build a
dictionary of features and transform documents to feature vectors:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">CountVectorizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count_vect</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_counts</span> <span class="o">=</span> <span class="n">count_vect</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">twenty_train</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_counts</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2257, 35788)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../modules/generated/sklearn.feature_extraction.text.CountVectorizer.html#sklearn.feature_extraction.text.CountVectorizer" title="sklearn.feature_extraction.text.CountVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">CountVectorizer</span></tt></a> supports counts of N-grams of words or consequective characters.
Once fitted, the vectorizer has built a dictionary of feature indices:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">count_vect</span><span class="o">.</span><span class="n">vocabulary_</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">u&#39;algorithm&#39;</span><span class="p">)</span>
<span class="go">4690</span>
</pre></div>
</div>
<p>The index value of a word in the vocabulary is linked to its frequency
in the whole training corpus.</p>
</div>
<div class="section" id="from-occurrences-to-frequencies">
<h3>From occurrences to frequencies<a class="headerlink" href="#from-occurrences-to-frequencies" title="Permalink to this headline">¶</a></h3>
<p>Occurrence count is a good start but there is an issue: longer
documents will have higher average count values than shorter documents,
even though they might talk about the same topics.</p>
<p>To avoid these potential discrepancies it suffices to divide the
number of occurrences of each word in a document by the total number
of words in the document: these new features are called <tt class="docutils literal"><span class="pre">tf</span></tt> for Term
Frequencies.</p>
<p>Another refinement on top of tf is to downscale weights for words
that occur in many documents in the corpus and are therefore less
informative than those that occur only in a smaller portion of the
corpus.</p>
<p>This downscaling is called <a class="reference external" href="http://en.wikipedia.org/wiki/Tf–idf">tf–idf</a> for &#8220;Term Frequency times
Inverse Document Frequency&#8221;.</p>
<p>Both <strong>tf</strong> and <strong>tf–idf</strong> can be computed as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">TfidfTransformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tf_transformer</span> <span class="o">=</span> <span class="n">TfidfTransformer</span><span class="p">(</span><span class="n">use_idf</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_counts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_tf</span> <span class="o">=</span> <span class="n">tf_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_train_counts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_tf</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2257, 35788)</span>
</pre></div>
</div>
<p>In the above example-code, we firstly use the <tt class="docutils literal"><span class="pre">fit(..)</span></tt> method to fit our
estimator to the data and secondly the <tt class="docutils literal"><span class="pre">transform(..)</span></tt> method to transform
our count-matrix to a tf-idf representation.
These two steps can be combined to achieve the same end result faster
by skipping redundant processing. This is done through using the
<tt class="docutils literal"><span class="pre">fit_transform(..)</span></tt> method as shown below, and as mentioned in the note
in the previous section:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tfidf_transformer</span> <span class="o">=</span> <span class="n">TfidfTransformer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_tfidf</span> <span class="o">=</span> <span class="n">tfidf_transformer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train_counts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_tfidf</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2257, 35788)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="training-a-classifier">
<h2>Training a classifier<a class="headerlink" href="#training-a-classifier" title="Permalink to this headline">¶</a></h2>
<p>Now that we have our features, we can train a classifier to try to predict
the category of a post. Let&#8217;s start with a <a class="reference internal" href="../../modules/naive_bayes.html#naive-bayes"><em>naïve Bayes</em></a>
classifier, which
provides a nice baseline for this task. <tt class="docutils literal"><span class="pre">scikit-learn</span></tt> includes several
variants of this classifier; the one most suitable for word counts is the
multinomial variant:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.naive_bayes</span> <span class="kn">import</span> <span class="n">MultinomialNB</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">MultinomialNB</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_tfidf</span><span class="p">,</span> <span class="n">twenty_train</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
</pre></div>
</div>
<p>To try to predict the outcome on a new document we need to extract
the features using almost the same feature extracting chain as before.
The difference is that we call <tt class="docutils literal"><span class="pre">transform</span></tt> instead of <tt class="docutils literal"><span class="pre">fit_transform</span></tt>
on the transformers, since they have already been fit to the training set:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">docs_new</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;God is love&#39;</span><span class="p">,</span> <span class="s">&#39;OpenGL on the GPU is fast&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_new_counts</span> <span class="o">=</span> <span class="n">count_vect</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">docs_new</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_new_tfidf</span> <span class="o">=</span> <span class="n">tfidf_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_new_counts</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">predicted</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new_tfidf</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">doc</span><span class="p">,</span> <span class="n">category</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">docs_new</span><span class="p">,</span> <span class="n">predicted</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%r</span><span class="s"> =&gt; </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">twenty_train</span><span class="o">.</span><span class="n">target_names</span><span class="p">[</span><span class="n">category</span><span class="p">]))</span>
<span class="gp">...</span>
<span class="go">&#39;God is love&#39; =&gt; soc.religion.christian</span>
<span class="go">&#39;OpenGL on the GPU is fast&#39; =&gt; comp.graphics</span>
</pre></div>
</div>
</div>
<div class="section" id="building-a-pipeline">
<h2>Building a pipeline<a class="headerlink" href="#building-a-pipeline" title="Permalink to this headline">¶</a></h2>
<p>In order to make the vectorizer =&gt; transformer =&gt; classifier easier
to work with, <tt class="docutils literal"><span class="pre">scikit-learn</span></tt> provides a <tt class="docutils literal"><span class="pre">Pipeline</span></tt> class that behaves
like a compound classifier:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text_clf</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">([(</span><span class="s">&#39;vect&#39;</span><span class="p">,</span> <span class="n">CountVectorizer</span><span class="p">()),</span>
<span class="gp">... </span>                     <span class="p">(</span><span class="s">&#39;tfidf&#39;</span><span class="p">,</span> <span class="n">TfidfTransformer</span><span class="p">()),</span>
<span class="gp">... </span>                     <span class="p">(</span><span class="s">&#39;clf&#39;</span><span class="p">,</span> <span class="n">MultinomialNB</span><span class="p">()),</span>
<span class="gp">... </span><span class="p">])</span>
</pre></div>
</div>
<p>The names <tt class="docutils literal"><span class="pre">vect</span></tt>, <tt class="docutils literal"><span class="pre">tfidf</span></tt> and <tt class="docutils literal"><span class="pre">clf</span></tt> (classifier) are arbitrary.
We shall see their use in the section on grid search, below.
We can now train the model with a single command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">text_clf</span> <span class="o">=</span> <span class="n">text_clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">twenty_train</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">twenty_train</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="evaluation-of-the-performance-on-the-test-set">
<h2>Evaluation of the performance on the test set<a class="headerlink" href="#evaluation-of-the-performance-on-the-test-set" title="Permalink to this headline">¶</a></h2>
<p>Evaluating the predictive accuracy of the model is equally easy:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">twenty_test</span> <span class="o">=</span> <span class="n">fetch_20newsgroups</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s">&#39;test&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">categories</span><span class="o">=</span><span class="n">categories</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">docs_test</span> <span class="o">=</span> <span class="n">twenty_test</span><span class="o">.</span><span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">predicted</span> <span class="o">=</span> <span class="n">text_clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">docs_test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">predicted</span> <span class="o">==</span> <span class="n">twenty_test</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>            
<span class="go">0.834...</span>
</pre></div>
</div>
<p>I.e., we achieved 83.4% accuracy. Let&#8217;s see if we can do better with a
linear <a class="reference internal" href="../../modules/svm.html#svm"><em>support vector machine (SVM)</em></a>,
which is widely regarded as one of
the best text classification algorithms (although it&#8217;s also a bit slower
than naïve Bayes). We can change the learner by just plugging a different
classifier object into our pipeline:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">SGDClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text_clf</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">([(</span><span class="s">&#39;vect&#39;</span><span class="p">,</span> <span class="n">CountVectorizer</span><span class="p">()),</span>
<span class="gp">... </span>                     <span class="p">(</span><span class="s">&#39;tfidf&#39;</span><span class="p">,</span> <span class="n">TfidfTransformer</span><span class="p">()),</span>
<span class="gp">... </span>                     <span class="p">(</span><span class="s">&#39;clf&#39;</span><span class="p">,</span> <span class="n">SGDClassifier</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="s">&#39;hinge&#39;</span><span class="p">,</span> <span class="n">penalty</span><span class="o">=</span><span class="s">&#39;l2&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">alpha</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">)),</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">text_clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">twenty_train</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">twenty_train</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">predicted</span> <span class="o">=</span> <span class="n">text_clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">docs_test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">predicted</span> <span class="o">==</span> <span class="n">twenty_test</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>            
<span class="go">0.912...</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">scikit-learn</span></tt> further provides utilities for more detailed performance
analysis of the results:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">classification_report</span><span class="p">(</span><span class="n">twenty_test</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">predicted</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">target_names</span><span class="o">=</span><span class="n">twenty_test</span><span class="o">.</span><span class="n">target_names</span><span class="p">))</span>
<span class="gp">... </span>                                        
<span class="go">                        precision    recall  f1-score   support</span>

<span class="go">           alt.atheism       0.94      0.82      0.87       319</span>
<span class="go">         comp.graphics       0.88      0.98      0.92       389</span>
<span class="go">               sci.med       0.95      0.89      0.92       396</span>
<span class="go">soc.religion.christian       0.90      0.95      0.92       398</span>

<span class="go">           avg / total       0.92      0.91      0.91      1502</span>


<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">twenty_test</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">predicted</span><span class="p">)</span>
<span class="go">array([[261,  10,  12,  36],</span>
<span class="go">       [  5, 380,   2,   2],</span>
<span class="go">       [  7,  32, 353,   4],</span>
<span class="go">       [  6,  11,   4, 377]])</span>
</pre></div>
</div>
<p>As expected the confusion matrix shows that posts from the newsgroups
on atheism and christian are more often confused for one another than
with computer graphics.</p>
</div>
<div class="section" id="parameter-tuning-using-grid-search">
<h2>Parameter tuning using grid search<a class="headerlink" href="#parameter-tuning-using-grid-search" title="Permalink to this headline">¶</a></h2>
<p>We&#8217;ve already encountered some parameters such as <tt class="docutils literal"><span class="pre">use_idf</span></tt> in the
<tt class="docutils literal"><span class="pre">TfidfTransformer</span></tt>. Classifiers tend to have many parameters as well;
e.g., <tt class="docutils literal"><span class="pre">MultinomialNB</span></tt> includes a smoothing parameter <tt class="docutils literal"><span class="pre">alpha</span></tt> and
<tt class="docutils literal"><span class="pre">SGDClassifier</span></tt> has a penalty parameter <tt class="docutils literal"><span class="pre">alpha</span></tt> and configurable loss
and penalty terms in the objective function (see the module documentation,
or use the Python <tt class="docutils literal"><span class="pre">help</span></tt> function, to get a description of these).</p>
<p>Instead of tweaking the parameters of the various components of the
chain, it is possible to run an exhaustive search of the best
parameters on a grid of possible values. We try out all classifiers
on either words or bigrams, with or without idf, and with a penalty
parameter of either 100 or 1000 for the linear SVM:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.grid_search</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;vect__ngram_range&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
<span class="gp">... </span>              <span class="s">&#39;tfidf__use_idf&#39;</span><span class="p">:</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span>
<span class="gp">... </span>              <span class="s">&#39;clf__alpha&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">),</span>
<span class="gp">... </span><span class="p">}</span>
</pre></div>
</div>
<p>Obviously, such an exhaustive search can be expensive. If we have multiple
CPU cores at our disposal, we can tell the grid searcher to try these eight
parameter combinations in parallel with the <tt class="docutils literal"><span class="pre">n_jobs</span></tt> parameter. If we give
this parameter a value of <tt class="docutils literal"><span class="pre">-1</span></tt>, grid search will detect how many cores
are installed and uses them all:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">gs_clf</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">text_clf</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The grid search instance behaves like a normal <tt class="docutils literal"><span class="pre">scikit-learn</span></tt>
model. Let&#8217;s perform the search on a smaller subset of the training data
to speed up the computation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">gs_clf</span> <span class="o">=</span> <span class="n">gs_clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">twenty_train</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="mi">400</span><span class="p">],</span> <span class="n">twenty_train</span><span class="o">.</span><span class="n">target</span><span class="p">[:</span><span class="mi">400</span><span class="p">])</span>
</pre></div>
</div>
<p>The result of calling <tt class="docutils literal"><span class="pre">fit</span></tt> on a <tt class="docutils literal"><span class="pre">GridSearchCV</span></tt> object is a classifier
that we can use to <tt class="docutils literal"><span class="pre">predict</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">twenty_train</span><span class="o">.</span><span class="n">target_names</span><span class="p">[</span><span class="n">gs_clf</span><span class="o">.</span><span class="n">predict</span><span class="p">([</span><span class="s">&#39;God is love&#39;</span><span class="p">])]</span>
<span class="go">&#39;soc.religion.christian&#39;</span>
</pre></div>
</div>
<p>but otherwise, it&#8217;s a pretty large and clumsy object. We can, however, get the
optimal parameters out by inspecting the object&#8217;s <tt class="docutils literal"><span class="pre">grid_scores_</span></tt> attribute,
which is a list of parameters/score pairs. To get the best scoring attributes,
we can do:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">best_parameters</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">gs_clf</span><span class="o">.</span><span class="n">grid_scores_</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">best_parameters</span><span class="p">[</span><span class="n">param_name</span><span class="p">]))</span>
<span class="gp">...</span>
<span class="go">clf__alpha: 0.001</span>
<span class="go">tfidf__use_idf: True</span>
<span class="go">vect__ngram_range: (1, 1)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span>                                              
<span class="go">0.902...</span>
</pre></div>
</div>
<p>To do the exercises, copy the content of the &#8216;skeletons&#8217; folder as
a new folder named &#8216;workspace&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre>% cp -r skeletons workspace
</pre></div>
</div>
<p>You can then edit the content of the workspace without fear of loosing
the original exercise instructions.</p>
<p>Then fire an ipython shell and run the work-in-progress script with:</p>
<div class="highlight-python"><div class="highlight"><pre>[1] %run workspace/exercise_XX_script.py arg1 arg2 arg3
</pre></div>
</div>
<p>If an exception is triggered, use <tt class="docutils literal"><span class="pre">%debug</span></tt> to fire-up a post
mortem ipdb session.</p>
<p>Refine the implementation and iterate until the exercise is solved.</p>
<p><strong>For each exercise, the skeleton file provides all the necessary import
statements, boilerplate code to load the data and sample code to evaluate
the predictive accurracy of the model.</strong></p>
</div>
<div class="section" id="exercise-1-language-identification">
<h2>Exercise 1: Language identification<a class="headerlink" href="#exercise-1-language-identification" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Write a text classification pipeline using a custom preprocessor and
<tt class="docutils literal"><span class="pre">CharNGramAnalyzer</span></tt> using data from Wikipedia articles as training set.</li>
<li>Evaluate the performance on some held out test set.</li>
</ul>
<p>ipython command line:</p>
<div class="highlight-python"><div class="highlight"><pre>%run workspace/exercise_01_language_train_model.py data/languages/paragraphs/
</pre></div>
</div>
</div>
<div class="section" id="exercise-2-sentiment-analysis-on-movie-reviews">
<h2>Exercise 2: Sentiment Analysis on movie reviews<a class="headerlink" href="#exercise-2-sentiment-analysis-on-movie-reviews" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Write a text classification pipeline to classify movie reviews as either
positive or negative.</li>
<li>Find a good set of parameters using grid search.</li>
<li>Evaluate the performance on a held out test set.</li>
</ul>
<p>ipython command line:</p>
<div class="highlight-python"><div class="highlight"><pre>%run workspace/exercise_02_sentiment.py data/movie_reviews/txt_sentoken/
</pre></div>
</div>
</div>
<div class="section" id="exercise-3-cli-text-classification-utility">
<h2>Exercise 3: CLI text classification utility<a class="headerlink" href="#exercise-3-cli-text-classification-utility" title="Permalink to this headline">¶</a></h2>
<p>Using the results of the previous exercises and the <tt class="docutils literal"><span class="pre">cPickle</span></tt>
module of the standard library, write a command line utility that
detects the language of some text provided on <tt class="docutils literal"><span class="pre">stdin</span></tt> and estimate
the polarity (positive or negative) if the text is written in
English.</p>
<p>Bonus point if the utility is able to give a confidence level for its
predictions.</p>
</div>
<div class="section" id="where-to-from-here">
<h2>Where to from here<a class="headerlink" href="#where-to-from-here" title="Permalink to this headline">¶</a></h2>
<p>Here are a few suggestions to help further your scikit-learn intuition
upon the completion of this tutorial:</p>
<ul class="simple">
<li>Try playing around with the <tt class="docutils literal"><span class="pre">analyzer</span></tt> and <tt class="docutils literal"><span class="pre">token</span> <span class="pre">normalisation</span></tt> under
<a class="reference internal" href="../../modules/generated/sklearn.feature_extraction.text.CountVectorizer.html#sklearn.feature_extraction.text.CountVectorizer" title="sklearn.feature_extraction.text.CountVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">CountVectorizer</span></tt></a></li>
<li>If you don&#8217;t have labels, try using
<a class="reference internal" href="../../auto_examples/document_clustering.html#example-document-clustering-py"><em>Clustering</em></a>
on your problem.</li>
<li>If you have multiple labels per document, e.g categories, have a look
at the <a class="reference internal" href="../../modules/multiclass.html#multiclass"><em>Multiclass and multilabel section</em></a></li>
<li>Try using <a class="reference internal" href="../../modules/decomposition.html#lsa"><em>Truncated SVD</em></a> for
<a class="reference external" href="http://en.wikipedia.org/wiki/Latent_semantic_analysis">latent semantic analysis</a>.</li>
<li>Have a look at using
<a class="reference internal" href="../../auto_examples/applications/plot_out_of_core_classification.html#example-applications-plot-out-of-core-classification-py"><em>Out-of-core Classification</em></a> to
learn from data that would not fit into the computer main memory.</li>
<li>Have a look at the <a class="reference internal" href="../../modules/feature_extraction.html#hashing-vectorizer"><em>Hashing Vectorizer</em></a>
as a memory efficient alternative to <a class="reference internal" href="../../modules/generated/sklearn.feature_extraction.text.CountVectorizer.html#sklearn.feature_extraction.text.CountVectorizer" title="sklearn.feature_extraction.text.CountVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">CountVectorizer</span></tt></a>.</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer">
        &copy; 2010 - 2014, scikit-learn developers (BSD License).
      <a href="../../_sources/tutorial/text_analytics/working_with_text_data.txt" rel="nofollow">Show this page source</a>
    </div>
     <div class="rel">
    
    <div class="buttonPrevious">
      <a href="../statistical_inference/finding_help.html">Previous
      </a>
    </div>
    <div class="buttonNext">
      <a href="../../user_guide.html">Next
      </a>
    </div>
    <div class="buttonPrevious">
      <a href="../../np-modindex.html">Previous
      </a>
    </div>
    <div class="buttonNext">
      <a href="../../py-modindex.html">Next
      </a>
    </div>
    
     </div>

    
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-22606712-2']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    

    <script src="http://www.google.com/jsapi" type="text/javascript"></script>
    <script type="text/javascript"> google.load('search', '1',
        {language : 'en'}); google.setOnLoadCallback(function() {
            var customSearchControl = new
            google.search.CustomSearchControl('016639176250731907682:tjtqbvtvij0');
            customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
            var options = new google.search.DrawOptions();
            options.setAutoComplete(true);
            customSearchControl.draw('cse', options); }, true);
    </script>
  </body>
</html>