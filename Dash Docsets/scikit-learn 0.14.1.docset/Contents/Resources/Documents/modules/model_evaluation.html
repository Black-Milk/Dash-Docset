
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
  
    <title>3.5. Model evaluation: quantifying the quality of predictions &mdash; scikit-learn 0.14.1 documentation</title>
  <!-- htmltitle is before nature.css - we use this hack to load bootstrap first -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="../_static/css/bootstrap.min.css" media="screen" />
  <link rel="stylesheet" href="../_static/css/bootstrap-responsive.css"/>

    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.14.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="top" title="scikit-learn 0.14.1 documentation" href="../index.html" />
    <link rel="up" title="3. Model selection and evaluation" href="../model_selection.html" />
    <link rel="next" title="3.6. Validation curves: plotting scores to evaluate models" href="learning_curve.html" />
    <link rel="prev" title="3.3. Pipeline: chaining estimators" href="pipeline.html" />
  
   
       <script type="text/javascript" src="../_static/sidebar.js"></script>
   
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="../_static/js/bootstrap.min.js" type="text/javascript"></script>
  <link rel="canonical" href="http://scikit-learn.org/stable/modules/model_evaluation.html" />

  <script type="text/javascript">
    $("div.buttonNext, div.buttonPrevious").hover(
       function () {
           $(this).css('background-color', '#FF9C34');
       },
       function () {
           $(this).css('background-color', '#A7D6E2');
       }
    );
    var bodywrapper = $('.bodywrapper');
    var sidebarbutton = $('#sidebarbutton');
    sidebarbutton.css({'height': '900px'});
  </script>

  </head>
  <body>

<div class="header-wrapper">
    <div class="header">
        <p class="logo"><a href="../index.html">
            <img src="../_static/scikit-learn-logo-small.png" alt="Logo"/>
        </a>
        </p><div class="navbar">
            <ul>
                <li><a href="../../stable/index.html">Home</a></li>
                <li><a href="../../stable/install.html">Installation</a></li>
                <li class="btn-li"><div class="btn-group">
		      <a href="../documentation.html">Documentation</a>
		      <a class="btn dropdown-toggle" data-toggle="dropdown">
			     <span class="caret"></span>
		      </a>
		      <ul class="dropdown-menu">
			<li class="link-title">Scikit-learn 0.14 (stable)</li>
			<li><a href="../tutorial/index.html">Tutorials</a></li>
			<li><a href="../user_guide.html">User guide</a></li>
			<li><a href="classes.html">API</a></li>
			<li class="divider"></li>
		        <li><a href="http://scikit-learn.org/dev/documentation.html">Development</a></li>
		        <li><a href="http://scikit-learn.org/0.13/">Scikit-learn 0.13</a></li>
		        <li><a href="http://scikit-learn.org/0.12/">Scikit-learn 0.12</a></li>
		        <li><a href="http://scikit-learn.org/0.11/">Scikit-learn 0.11</a></li>
		        <li><a href="../documentation.html">More versions...</a></li>
		      </ul>
		    </div>
		</li>
            <li><a href="../auto_examples/index.html">Examples</a></li>
            </ul>

            <div class="search_form">
                <div id="cse" style="width: 100%;"></div>
            </div>
        </div> <!-- end navbar --></div>
</div>


<!-- Github "fork me" ribbon -->
<a href="https://github.com/scikit-learn/scikit-learn">
  <img class="fork-me"
       style="position: absolute; top: 0; right: 0; border: 0;"
       src="../_static/img/forkme.png"
       alt="Fork me on GitHub" />
</a>

<div class="content-wrapper">
    <div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
        <div class="rel">
    

  <!-- rellinks[1:] is an ugly hack to avoid link to module
  index -->
        <div class="rellink">
        <a href="pipeline.html"
        accesskey="P">Previous
        <br/>
        <span class="smallrellink">
        3.3. Pipeline: c...
        </span>
            <span class="hiddenrellink">
            3.3. Pipeline: chaining estimators
            </span>
        </a>
        </div>
            <div class="spacer">
            &nbsp;
            </div>
        <div class="rellink">
        <a href="learning_curve.html"
        accesskey="N">Next
        <br/>
        <span class="smallrellink">
        3.6. Validation ...
        </span>
            <span class="hiddenrellink">
            3.6. Validation curves: plotting scores to evaluate models
            </span>
        </a>
        </div>
            <div class="spacer">
            &nbsp;
            </div>
        <div class="rellink">
        <a href="../np-modindex.html"
        >Modules
        <br/>
        <span class="smallrellink">
        Python Module In...
        </span>
            <span class="hiddenrellink">
            Python Module Index
            </span>
        </a>
        </div>
            <div class="spacer">
            &nbsp;
            </div>
        <div class="rellink">
        <a href="../py-modindex.html"
        >Modules
        <br/>
        <span class="smallrellink">
        Python Module In...
        </span>
            <span class="hiddenrellink">
            Python Module Index
            </span>
        </a>
        </div>

    <!-- Ad a link to the 'up' page -->
        <div class="spacer">
        &nbsp;
        </div>
        <div class="rellink">
        <a href="../model_selection.html">
        Up
        <br/>
        <span class="smallrellink">
        3. Model selecti...
        </span>
            <span class="hiddenrellink">
            3. Model selection and evaluation
            </span>
            
        </a>
        </div>
    </div>
    
      <p class="doc-version">This documentation is for scikit-learn <strong>version 0.14.1</strong> &mdash; <a href="http://scikit-learn.org/stable/support.html#documentation-resources">Other versions</a></p>
    <p class="citing">If you use the software, please consider <a href="../about.html#citing-scikit-learn">citing scikit-learn</a>.</p>
    <ul>
<li><a class="reference internal" href="#">3.5. Model evaluation: quantifying the quality of predictions</a><ul>
<li><a class="reference internal" href="#the-scoring-parameter-defining-model-evaluation-rules">3.5.1. The <cite>scoring</cite> parameter: defining model evaluation rules</a><ul>
<li><a class="reference internal" href="#common-cases-predefined-values">3.5.1.1. Common cases: predefined values</a></li>
<li><a class="reference internal" href="#defining-your-scoring-strategy-from-score-functions">3.5.1.2. Defining your scoring strategy from score functions</a></li>
<li><a class="reference internal" href="#implementing-your-own-scoring-object">3.5.1.3. Implementing your own scoring object</a></li>
</ul>
</li>
<li><a class="reference internal" href="#function-for-prediction-error-metrics">3.5.2. Function for prediction-error metrics</a><ul>
<li><a class="reference internal" href="#classification-metrics">3.5.2.1. Classification metrics</a><ul>
<li><a class="reference internal" href="#accuracy-score">3.5.2.1.1. Accuracy score</a></li>
<li><a class="reference internal" href="#confusion-matrix">3.5.2.1.2. Confusion matrix</a></li>
<li><a class="reference internal" href="#classification-report">3.5.2.1.3. Classification report</a></li>
<li><a class="reference internal" href="#hamming-loss">3.5.2.1.4. Hamming loss</a></li>
<li><a class="reference internal" href="#jaccard-similarity-coefficient-score">3.5.2.1.5. Jaccard similarity coefficient score</a></li>
<li><a class="reference internal" href="#precision-recall-and-f-measures">3.5.2.1.6. Precision, recall and F-measures</a><ul>
<li><a class="reference internal" href="#binary-classification">3.5.2.1.6.1. Binary classification</a></li>
<li><a class="reference internal" href="#multiclass-and-multilabel-classification">3.5.2.1.6.2. Multiclass and multilabel classification</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hinge-loss">3.5.2.1.7. Hinge loss</a></li>
<li><a class="reference internal" href="#log-loss">3.5.2.1.8. Log loss</a></li>
<li><a class="reference internal" href="#matthews-correlation-coefficient">3.5.2.1.9. Matthews correlation coefficient</a></li>
<li><a class="reference internal" href="#receiver-operating-characteristic-roc">3.5.2.1.10. Receiver operating characteristic (ROC)</a></li>
<li><a class="reference internal" href="#zero-one-loss">3.5.2.1.11. Zero one loss</a></li>
</ul>
</li>
<li><a class="reference internal" href="#regression-metrics">3.5.2.2. Regression metrics</a><ul>
<li><a class="reference internal" href="#explained-variance-score">3.5.2.2.1. Explained variance score</a></li>
<li><a class="reference internal" href="#mean-absolute-error">3.5.2.2.2. Mean absolute error</a></li>
<li><a class="reference internal" href="#mean-squared-error">3.5.2.2.3. Mean squared error</a></li>
<li><a class="reference internal" href="#r2-score-the-coefficient-of-determination">3.5.2.2.4. R² score, the coefficient of determination</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#clustering-metrics">3.5.3. Clustering metrics</a></li>
<li><a class="reference internal" href="#biclustering-metrics">3.5.4. Biclustering metrics</a><ul>
<li><a class="reference internal" href="#id8">3.5.4.1. Clustering metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dummy-estimators">3.5.5. Dummy estimators</a></li>
</ul>
</li>
</ul>

    </div>
</div>



      <div class="content">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="model-evaluation-quantifying-the-quality-of-predictions">
<span id="model-evaluation"></span><h1>3.5. Model evaluation: quantifying the quality of predictions<a class="headerlink" href="#model-evaluation-quantifying-the-quality-of-predictions" title="Permalink to this headline">¶</a></h1>
<p>There are 3 different approaches to evaluate the quality of predictions of a
model:</p>
<ul class="simple">
<li><strong>Estimator score method</strong>: Estimators have a <tt class="docutils literal"><span class="pre">score</span></tt> method providing a
default evaluation criterion for the problem they are designed to solve.
This is not discussed on this page, but in each estimator&#8217;s documentation.</li>
<li><strong>Scoring parameter</strong>: Model-evaluation tools using
<a class="reference internal" href="cross_validation.html#cross-validation"><em>cross-validation</em></a> (such as
<a class="reference internal" href="generated/sklearn.cross_validation.cross_val_score.html#sklearn.cross_validation.cross_val_score" title="sklearn.cross_validation.cross_val_score"><tt class="xref py py-func docutils literal"><span class="pre">cross_validation.cross_val_score</span></tt></a> and
<a class="reference internal" href="generated/sklearn.grid_search.GridSearchCV.html#sklearn.grid_search.GridSearchCV" title="sklearn.grid_search.GridSearchCV"><tt class="xref py py-class docutils literal"><span class="pre">grid_search.GridSearchCV</span></tt></a>) rely on an internal <em>scoring</em> strategy.
This is discussed on section <a class="reference internal" href="#scoring-parameter"><em>The scoring parameter: defining model evaluation rules</em></a>.</li>
<li><strong>Metric functions</strong>: The <tt class="xref py py-mod docutils literal"><span class="pre">metrics</span></tt> module implements functions
assessing prediction errors for specific purposes. This is discussed in
the section <a class="reference internal" href="#prediction-error-metrics"><em>Function for prediction-error metrics</em></a>.</li>
</ul>
<p>Finally, <a class="reference internal" href="#dummy-estimators"><em>Dummy estimators</em></a> are useful to get a baseline
value of those metrics for random predictions.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">For &#8220;pairwise&#8221; metrics, between <em>samples</em> and not estimators or
predictions, see the <a class="reference internal" href="metrics.html#metrics"><em>Pairwise metrics, Affinities and Kernels</em></a> section.</p>
</div>
<div class="section" id="the-scoring-parameter-defining-model-evaluation-rules">
<span id="scoring-parameter"></span><h2>3.5.1. The <cite>scoring</cite> parameter: defining model evaluation rules<a class="headerlink" href="#the-scoring-parameter-defining-model-evaluation-rules" title="Permalink to this headline">¶</a></h2>
<p>Model selection and evaluation using tools, such as
<a class="reference internal" href="generated/sklearn.grid_search.GridSearchCV.html#sklearn.grid_search.GridSearchCV" title="sklearn.grid_search.GridSearchCV"><tt class="xref py py-class docutils literal"><span class="pre">grid_search.GridSearchCV</span></tt></a> and
<a class="reference internal" href="generated/sklearn.cross_validation.cross_val_score.html#sklearn.cross_validation.cross_val_score" title="sklearn.cross_validation.cross_val_score"><tt class="xref py py-func docutils literal"><span class="pre">cross_validation.cross_val_score</span></tt></a>, take a <cite>scoring</cite> parameter that
controls what metric they apply to estimators evaluated.</p>
<div class="section" id="common-cases-predefined-values">
<h3>3.5.1.1. Common cases: predefined values<a class="headerlink" href="#common-cases-predefined-values" title="Permalink to this headline">¶</a></h3>
<p>For the most common usecases, you can simply provide a string as the
<tt class="docutils literal"><span class="pre">scoring</span></tt> parameter. Possible values are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Scoring</th>
<th class="head">Function</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>Classification</strong></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>&#8216;accuracy&#8217;</td>
<td><a class="reference internal" href="generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.metrics.accuracy_score</span></tt></a></td>
</tr>
<tr class="row-even"><td>&#8216;average_precision&#8217;</td>
<td><a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.metrics.average_precision_score</span></tt></a></td>
</tr>
<tr class="row-odd"><td>&#8216;f1&#8217;</td>
<td><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.metrics.f1_score</span></tt></a></td>
</tr>
<tr class="row-even"><td>&#8216;precision&#8217;</td>
<td><a class="reference internal" href="generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.metrics.precision_score</span></tt></a></td>
</tr>
<tr class="row-odd"><td>&#8216;recall&#8217;</td>
<td><a class="reference internal" href="generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.metrics.recall_score</span></tt></a></td>
</tr>
<tr class="row-even"><td>&#8216;roc_auc&#8217;</td>
<td><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.metrics.roc_auc_score</span></tt></a></td>
</tr>
<tr class="row-odd"><td><strong>Clustering</strong></td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>&#8216;adjusted_rand_score&#8217;</td>
<td><a class="reference internal" href="generated/sklearn.metrics.adjusted_rand_score.html#sklearn.metrics.adjusted_rand_score" title="sklearn.metrics.adjusted_rand_score"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.metrics.adjusted_rand_score</span></tt></a></td>
</tr>
<tr class="row-odd"><td><strong>Regression</strong></td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>&#8216;mean_absolute_error&#8217;</td>
<td><a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error.html#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.metrics.mean_absolute_error</span></tt></a></td>
</tr>
<tr class="row-odd"><td>&#8216;mean_squared_error&#8217;</td>
<td><a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.metrics.mean_squared_error</span></tt></a></td>
</tr>
<tr class="row-even"><td>&#8216;r2&#8217;</td>
<td><a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.metrics.r2_score</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Setting the <tt class="docutils literal"><span class="pre">scoring</span></tt> parameter to a wrong value should give you a list
of acceptable values:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">svm</span><span class="p">,</span> <span class="n">cross_validation</span><span class="p">,</span> <span class="n">datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iris</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_iris</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">SVC</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cross_validation</span><span class="o">.</span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s">&#39;wrong_choice&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">ValueError</span>: <span class="n">&#39;wrong_choice&#39; is not a valid scoring value. Valid options are [&#39;accuracy&#39;, &#39;adjusted_rand_score&#39;, &#39;average_precision&#39;, &#39;f1&#39;, &#39;log_loss&#39;, &#39;mean_absolute_error&#39;, &#39;mean_squared_error&#39;, &#39;precision&#39;, &#39;r2&#39;, &#39;recall&#39;, &#39;roc_auc&#39;]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The corresponding scorer objects are stored in the dictionary
<tt class="docutils literal"><span class="pre">sklearn.metrics.SCORERS</span></tt>.</p>
</div>
<p>The above choices correspond to error-metric functions that can be applied to
predicted values. These are detailed below, in the next sections.</p>
</div>
<div class="section" id="defining-your-scoring-strategy-from-score-functions">
<span id="scoring"></span><h3>3.5.1.2. Defining your scoring strategy from score functions<a class="headerlink" href="#defining-your-scoring-strategy-from-score-functions" title="Permalink to this headline">¶</a></h3>
<p>The scoring parameter can be a callable that takes model predictions and
ground truth.</p>
<p>However, if you want to use a scoring function that takes additional parameters, such as
<a class="reference internal" href="generated/sklearn.metrics.fbeta_score.html#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><tt class="xref py py-func docutils literal"><span class="pre">fbeta_score</span></tt></a>, you need to generate an appropriate scoring object.  The
simplest way to generate a callable object for scoring is by using
<a class="reference internal" href="generated/sklearn.metrics.make_scorer.html#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><tt class="xref py py-func docutils literal"><span class="pre">make_scorer</span></tt></a>.
That function converts score functions (discussed below in <a class="reference internal" href="#prediction-error-metrics"><em>Function for prediction-error metrics</em></a>) into callables that can be
used for model evaluation.</p>
<p>One typical use case is to wrap an existing scoring function from the library
with non default value for its parameters such as the <tt class="docutils literal"><span class="pre">beta</span></tt> parameter for the
<a class="reference internal" href="generated/sklearn.metrics.fbeta_score.html#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><tt class="xref py py-func docutils literal"><span class="pre">fbeta_score</span></tt></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">fbeta_score</span><span class="p">,</span> <span class="n">make_scorer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ftwo_scorer</span> <span class="o">=</span> <span class="n">make_scorer</span><span class="p">(</span><span class="n">fbeta_score</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.grid_search</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">LinearSVC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">LinearSVC</span><span class="p">(),</span> <span class="n">param_grid</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">]},</span> <span class="n">scoring</span><span class="o">=</span><span class="n">ftwo_scorer</span><span class="p">)</span>
</pre></div>
</div>
<p>The second use case is to build a completely new and custom scorer object
from a simple python function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_custom_loss_func</span><span class="p">(</span><span class="n">ground_truth</span><span class="p">,</span> <span class="n">predictions</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ground_truth</span> <span class="o">-</span> <span class="n">predictions</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">diff</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_custom_scorer</span> <span class="o">=</span> <span class="n">make_scorer</span><span class="p">(</span><span class="n">my_custom_loss_func</span><span class="p">,</span> <span class="n">greater_is_better</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">LinearSVC</span><span class="p">(),</span> <span class="n">param_grid</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">]},</span> <span class="n">scoring</span><span class="o">=</span><span class="n">my_custom_scorer</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="generated/sklearn.metrics.make_scorer.html#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><tt class="xref py py-func docutils literal"><span class="pre">make_scorer</span></tt></a> takes as parameters:</p>
<ul class="simple">
<li>the function you want to use</li>
<li>whether it is a score (<tt class="docutils literal"><span class="pre">greater_is_better=True</span></tt>) or a loss
(<tt class="docutils literal"><span class="pre">greater_is_better=False</span></tt>),</li>
<li>whether the function you provided takes predictions as input
(<tt class="docutils literal"><span class="pre">needs_threshold=False</span></tt>) or needs confidence scores (<tt class="docutils literal"><span class="pre">needs_threshold=True</span></tt>)</li>
<li>any additional parameters, such as <tt class="docutils literal"><span class="pre">beta</span></tt> in an <a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><tt class="xref py py-func docutils literal"><span class="pre">f1_score</span></tt></a>.</li>
</ul>
</div>
<div class="section" id="implementing-your-own-scoring-object">
<h3>3.5.1.3. Implementing your own scoring object<a class="headerlink" href="#implementing-your-own-scoring-object" title="Permalink to this headline">¶</a></h3>
<p>You can generate even more flexible model scores by constructing your own
scoring object from scratch, without using the <a class="reference internal" href="generated/sklearn.metrics.make_scorer.html#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><tt class="xref py py-func docutils literal"><span class="pre">make_scorer</span></tt></a> factory.
For a callable to be a scorer, it needs to meet the protocol specified by
the following two rules:</p>
<ul class="simple">
<li>It can be called with parameters <tt class="docutils literal"><span class="pre">(estimator,</span> <span class="pre">X,</span> <span class="pre">y)</span></tt>, where <tt class="docutils literal"><span class="pre">estimator</span></tt>
is the model that should be evaluated, <tt class="docutils literal"><span class="pre">X</span></tt> is validation data, and <tt class="docutils literal"><span class="pre">y</span></tt> is
the ground truth target for <tt class="docutils literal"><span class="pre">X</span></tt> (in the supervised case) or <tt class="docutils literal"><span class="pre">None</span></tt> (in the
unsupervised case).</li>
<li>It returns a floating point number that quantifies the quality of
<tt class="docutils literal"><span class="pre">estimator</span></tt>&#8216;s predictions on <tt class="docutils literal"><span class="pre">X</span></tt> which reference to <tt class="docutils literal"><span class="pre">y</span></tt>.
Again, higher numbers are better.</li>
</ul>
</div>
</div>
<div class="section" id="function-for-prediction-error-metrics">
<span id="prediction-error-metrics"></span><h2>3.5.2. Function for prediction-error metrics<a class="headerlink" href="#function-for-prediction-error-metrics" title="Permalink to this headline">¶</a></h2>
<p>The module <tt class="xref py py-mod docutils literal"><span class="pre">sklearn.metric</span></tt> also exposes a set of simple functions
measuring a prediction error given ground truth and prediction:</p>
<ul class="simple">
<li>functions ending with <tt class="docutils literal"><span class="pre">_score</span></tt> return a value to
maximize (the higher the better).</li>
<li>functions ending with <tt class="docutils literal"><span class="pre">_error</span></tt> or <tt class="docutils literal"><span class="pre">_loss</span></tt> return a
value to minimize (the lower the better).</li>
</ul>
<div class="section" id="classification-metrics">
<span id="id1"></span><h3>3.5.2.1. Classification metrics<a class="headerlink" href="#classification-metrics" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="classes.html#module-sklearn.metrics" title="sklearn.metrics"><tt class="xref py py-mod docutils literal"><span class="pre">sklearn.metrics</span></tt></a> implements several losses, scores and utility
functions to measure classification performance.
Some metrics might require probability estimates of the positive class,
confidence values or binary decisions values.</p>
<p>Some of these are restricted to the binary classification case:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/sklearn.metrics.hinge_loss.html#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><tt class="xref py py-obj docutils literal"><span class="pre">hinge_loss</span></tt></a>(y_true,&nbsp;pred_decision[,&nbsp;...])</td>
<td>Average hinge loss (non-regularized)  Assuming labels in y_true are encoded with +1 and -1, when a prediction mistake is made, <tt class="docutils literal"><span class="pre">margin</span> <span class="pre">=</span> <span class="pre">y_true</span> <span class="pre">*</span> <span class="pre">pred_decision</span></tt> is always negative (since the signs disagree), implying <tt class="docutils literal"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">margin</span></tt> is always greater than 1.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/sklearn.metrics.matthews_corrcoef.html#sklearn.metrics.matthews_corrcoef" title="sklearn.metrics.matthews_corrcoef"><tt class="xref py py-obj docutils literal"><span class="pre">matthews_corrcoef</span></tt></a>(y_true,&nbsp;y_pred)</td>
<td>Compute the Matthews correlation coefficient (MCC) for binary classes  The Matthews correlation coefficient is used in machine learning as a measure of the quality of binary (two-class) classifications.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><tt class="xref py py-obj docutils literal"><span class="pre">precision_recall_curve</span></tt></a>(y_true,&nbsp;probas_pred)</td>
<td>Compute precision-recall pairs for different probability thresholds  Note: this implementation is restricted to the binary classification task.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/sklearn.metrics.roc_curve.html#sklearn.metrics.roc_curve" title="sklearn.metrics.roc_curve"><tt class="xref py py-obj docutils literal"><span class="pre">roc_curve</span></tt></a>(y_true,&nbsp;y_score[,&nbsp;pos_label])</td>
<td>Compute Receiver operating characteristic (ROC)  Note: this implementation is restricted to the binary classification task.</td>
</tr>
</tbody>
</table>
<p>Others also work in the multiclass case:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/sklearn.metrics.confusion_matrix.html#sklearn.metrics.confusion_matrix" title="sklearn.metrics.confusion_matrix"><tt class="xref py py-obj docutils literal"><span class="pre">confusion_matrix</span></tt></a>(y_true,&nbsp;y_pred[,&nbsp;labels])</td>
<td>Compute confusion matrix to evaluate the accuracy of a classification  By definition a confusion matrix <img class="math" src="../_images/math/2bcc65482aa8e15cd4c9e9f2542451fb4e971a91.png" alt="C"/> is such that <img class="math" src="../_images/math/def967005305b517d635567d0537f11fe13a8b2a.png" alt="C_{i, j}"/> is equal to the number of observations known to be in group <img class="math" src="../_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> but predicted to be in group <img class="math" src="../_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/>.</td>
</tr>
</tbody>
</table>
<p>And some also work in the multilabel case:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><tt class="xref py py-obj docutils literal"><span class="pre">accuracy_score</span></tt></a>(y_true,&nbsp;y_pred[,&nbsp;normalize])</td>
<td>Accuracy classification score.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/sklearn.metrics.classification_report.html#sklearn.metrics.classification_report" title="sklearn.metrics.classification_report"><tt class="xref py py-obj docutils literal"><span class="pre">classification_report</span></tt></a>(y_true,&nbsp;y_pred[,&nbsp;...])</td>
<td>Build a text report showing the main classification metrics   :Parameters:      <strong>y_true</strong> : array-like or list of labels or label indicator matrix          Ground truth (correct) target values.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><tt class="xref py py-obj docutils literal"><span class="pre">f1_score</span></tt></a>(y_true,&nbsp;y_pred[,&nbsp;labels,&nbsp;...])</td>
<td>Compute the F1 score, also known as balanced F-score or F-measure  The F1 score can be interpreted as a weighted average of the precision and recall, where an F1 score reaches its best value at 1 and worst score at 0.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/sklearn.metrics.fbeta_score.html#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><tt class="xref py py-obj docutils literal"><span class="pre">fbeta_score</span></tt></a>(y_true,&nbsp;y_pred,&nbsp;beta[,&nbsp;labels,&nbsp;...])</td>
<td>Compute the F-beta score  The F-beta score is the weighted harmonic mean of precision and recall, reaching its optimal value at 1 and its worst value at 0.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/sklearn.metrics.hamming_loss.html#sklearn.metrics.hamming_loss" title="sklearn.metrics.hamming_loss"><tt class="xref py py-obj docutils literal"><span class="pre">hamming_loss</span></tt></a>(y_true,&nbsp;y_pred[,&nbsp;classes])</td>
<td>Compute the average Hamming loss.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/sklearn.metrics.jaccard_similarity_score.html#sklearn.metrics.jaccard_similarity_score" title="sklearn.metrics.jaccard_similarity_score"><tt class="xref py py-obj docutils literal"><span class="pre">jaccard_similarity_score</span></tt></a>(y_true,&nbsp;y_pred[,&nbsp;...])</td>
<td>Jaccard similarity coefficient score  The Jaccard index [1], or Jaccard similarity coefficient, defined as the size of the intersection divided by the size of the union of two label sets, is used to compare set of predicted labels for a sample to the corresponding set of labels in <tt class="docutils literal"><span class="pre">y_true</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/sklearn.metrics.log_loss.html#sklearn.metrics.log_loss" title="sklearn.metrics.log_loss"><tt class="xref py py-obj docutils literal"><span class="pre">log_loss</span></tt></a>(y_true,&nbsp;y_pred[,&nbsp;eps,&nbsp;normalize])</td>
<td>Log loss, aka logistic loss or cross-entropy loss.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/sklearn.metrics.precision_recall_fscore_support.html#sklearn.metrics.precision_recall_fscore_support" title="sklearn.metrics.precision_recall_fscore_support"><tt class="xref py py-obj docutils literal"><span class="pre">precision_recall_fscore_support</span></tt></a>(y_true,&nbsp;y_pred)</td>
<td>Compute precision, recall, F-measure and support for each class  The precision is the ratio <tt class="docutils literal"><span class="pre">tp</span> <span class="pre">/</span> <span class="pre">(tp</span> <span class="pre">+</span> <span class="pre">fp)</span></tt> where <tt class="docutils literal"><span class="pre">tp</span></tt> is the number of true positives and <tt class="docutils literal"><span class="pre">fp</span></tt> the number of false positives.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><tt class="xref py py-obj docutils literal"><span class="pre">precision_score</span></tt></a>(y_true,&nbsp;y_pred[,&nbsp;labels,&nbsp;...])</td>
<td>Compute the precision  The precision is the ratio <tt class="docutils literal"><span class="pre">tp</span> <span class="pre">/</span> <span class="pre">(tp</span> <span class="pre">+</span> <span class="pre">fp)</span></tt> where <tt class="docutils literal"><span class="pre">tp</span></tt> is the number of true positives and <tt class="docutils literal"><span class="pre">fp</span></tt> the number of false positives.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><tt class="xref py py-obj docutils literal"><span class="pre">recall_score</span></tt></a>(y_true,&nbsp;y_pred[,&nbsp;labels,&nbsp;...])</td>
<td>Compute the recall  The recall is the ratio <tt class="docutils literal"><span class="pre">tp</span> <span class="pre">/</span> <span class="pre">(tp</span> <span class="pre">+</span> <span class="pre">fn)</span></tt> where <tt class="docutils literal"><span class="pre">tp</span></tt> is the number of true positives and <tt class="docutils literal"><span class="pre">fn</span></tt> the number of false negatives.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/sklearn.metrics.zero_one_loss.html#sklearn.metrics.zero_one_loss" title="sklearn.metrics.zero_one_loss"><tt class="xref py py-obj docutils literal"><span class="pre">zero_one_loss</span></tt></a>(y_true,&nbsp;y_pred[,&nbsp;normalize])</td>
<td>Zero-one classification loss.</td>
</tr>
</tbody>
</table>
<p>And some work with binary and multilabel indicator format:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><tt class="xref py py-obj docutils literal"><span class="pre">average_precision_score</span></tt></a>(y_true,&nbsp;y_score)</td>
<td>Compute average precision (AP) from prediction scores  This score corresponds to the area under the precision-recall curve.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><tt class="xref py py-obj docutils literal"><span class="pre">roc_auc_score</span></tt></a>(y_true,&nbsp;y_score)</td>
<td>Compute Area Under the Curve (AUC) from prediction scores  Note: this implementation is restricted to the binary classification task.</td>
</tr>
</tbody>
</table>
<p>In the following sub-sections, we will describe each of those functions.</p>
<div class="section" id="accuracy-score">
<h4>3.5.2.1.1. Accuracy score<a class="headerlink" href="#accuracy-score" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><tt class="xref py py-func docutils literal"><span class="pre">accuracy_score</span></tt></a> function computes the
<a class="reference external" href="http://en.wikipedia.org/wiki/Accuracy_and_precision">accuracy</a>, the fraction
(default) or the number of correct predictions.</p>
<p>In multilabel classification, the function returns the subset accuracy: if
the entire set of predicted labels for a sample strictly match with the true
set of labels, then the subset accuracy is 1.0, otherwise it is 0.0.</p>
<p>If <img class="math" src="../_images/math/e8eb12f9407362d0fc035a12094fcc7797dcb69a.png" alt="\hat{y}_i"/> is the predicted value of
the <img class="math" src="../_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/>-th sample and <img class="math" src="../_images/math/410a65f64e2a609a2a7f544ed72f0982b719807a.png" alt="y_i"/> is the corresponding true value,
then the fraction of correct predictions over <img class="math" src="../_images/math/8bd3f4f4b38e127b70e57ee0d8a8f6c3f9a67560.png" alt="n_\text{samples}"/> is
defined as</p>
<div class="math">
<p><img src="../_images/math/27e20bf0b2786124f8df6383493b347e6ce8586d.png" alt="\texttt{accuracy}(y, \hat{y}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples}-1} 1(\hat{y}_i = y_i)"/></p>
</div><p>where <img class="math" src="../_images/math/6205f47dc46df64205ff4ed08f0e63aed02741ea.png" alt="1(x)"/> is the <a class="reference external" href="http://en.wikipedia.org/wiki/Indicator_function">indicator function</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>In the multilabel case with binary indicator format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="go">0.5</span>
</pre></div>
</div>
<p>and with a list of labels format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">accuracy_score</span><span class="p">([(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">()])</span>
<span class="go">0.0</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">Example:</p>
<ul class="simple">
<li>See <a class="reference internal" href="../auto_examples/plot_permutation_test_for_classification.html#example-plot-permutation-test-for-classification-py"><em>Test with permutations the significance of a classification score</em></a>
for an example of accuracy score usage using permutations of
the dataset.</li>
</ul>
</div>
</div>
<div class="section" id="confusion-matrix">
<h4>3.5.2.1.2. Confusion matrix<a class="headerlink" href="#confusion-matrix" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="generated/sklearn.metrics.confusion_matrix.html#sklearn.metrics.confusion_matrix" title="sklearn.metrics.confusion_matrix"><tt class="xref py py-func docutils literal"><span class="pre">confusion_matrix</span></tt></a> function computes the <a class="reference external" href="http://en.wikipedia.org/wiki/Confusion_matrix">confusion matrix</a> to evaluate
the accuracy on a classification problem.</p>
<p>By definition, a confusion matrix <img class="math" src="../_images/math/2bcc65482aa8e15cd4c9e9f2542451fb4e971a91.png" alt="C"/> is such that <img class="math" src="../_images/math/def967005305b517d635567d0537f11fe13a8b2a.png" alt="C_{i, j}"/> is
equal to the number of observations known to be in group <img class="math" src="../_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> but
predicted to be in group <img class="math" src="../_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/>. Here an example of such confusion matrix:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">confusion_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">array([[2, 0, 0],</span>
<span class="go">       [0, 0, 1],</span>
<span class="go">       [1, 0, 2]])</span>
</pre></div>
</div>
<p>Here a visual representation of such confusion matrix (this figure comes
from the <a class="reference internal" href="../auto_examples/plot_confusion_matrix.html#example-plot-confusion-matrix-py"><em>Confusion matrix</em></a> example):</p>
<a class="reference external image-reference" href="../auto_examples/plot_confusion_matrix.html"><img alt="../_images/plot_confusion_matrix_11.png" class="align-center" src="../_images/plot_confusion_matrix_11.png" style="width: 450.0px; height: 450.0px;" /></a>
<div class="topic">
<p class="topic-title first">Example:</p>
<ul class="simple">
<li>See <a class="reference internal" href="../auto_examples/plot_confusion_matrix.html#example-plot-confusion-matrix-py"><em>Confusion matrix</em></a>
for an example of confusion matrix usage to evaluate the quality of the
output of a classifier.</li>
<li>See <a class="reference internal" href="../auto_examples/plot_digits_classification.html#example-plot-digits-classification-py"><em>Recognizing hand-written digits</em></a>
for an example of confusion matrix usage in the classification of
hand-written digits.</li>
<li>See <a class="reference internal" href="../auto_examples/document_classification_20newsgroups.html#example-document-classification-20newsgroups-py"><em>Classification of text documents using sparse features</em></a>
for an example of confusion matrix usage in the classification of text
documents.</li>
</ul>
</div>
</div>
<div class="section" id="classification-report">
<h4>3.5.2.1.3. Classification report<a class="headerlink" href="#classification-report" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="generated/sklearn.metrics.classification_report.html#sklearn.metrics.classification_report" title="sklearn.metrics.classification_report"><tt class="xref py py-func docutils literal"><span class="pre">classification_report</span></tt></a> function builds a text report showing the
main classification metrics. Here a small example with custom <tt class="docutils literal"><span class="pre">target_names</span></tt>
and inferred labels:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;class 0&#39;</span><span class="p">,</span> <span class="s">&#39;class 1&#39;</span><span class="p">,</span> <span class="s">&#39;class 2&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">target_names</span><span class="o">=</span><span class="n">target_names</span><span class="p">))</span>
<span class="go">             precision    recall  f1-score   support</span>

<span class="go">    class 0       0.67      1.00      0.80         2</span>
<span class="go">    class 1       0.00      0.00      0.00         1</span>
<span class="go">    class 2       1.00      1.00      1.00         2</span>

<span class="go">avg / total       0.67      0.80      0.72         5</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">Example:</p>
<ul class="simple">
<li>See <a class="reference internal" href="../auto_examples/plot_digits_classification.html#example-plot-digits-classification-py"><em>Recognizing hand-written digits</em></a>
for an example of classification report usage in the classification of the
hand-written digits.</li>
<li>See <a class="reference internal" href="../auto_examples/document_classification_20newsgroups.html#example-document-classification-20newsgroups-py"><em>Classification of text documents using sparse features</em></a>
for an example of classification report usage in the classification of text
documents.</li>
<li>See <a class="reference internal" href="../auto_examples/grid_search_digits.html#example-grid-search-digits-py"><em>Parameter estimation using grid search with a nested cross-validation</em></a>
for an example of classification report usage in parameter estimation using
grid search with a nested cross-validation.</li>
</ul>
</div>
</div>
<div class="section" id="hamming-loss">
<h4>3.5.2.1.4. Hamming loss<a class="headerlink" href="#hamming-loss" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="generated/sklearn.metrics.hamming_loss.html#sklearn.metrics.hamming_loss" title="sklearn.metrics.hamming_loss"><tt class="xref py py-func docutils literal"><span class="pre">hamming_loss</span></tt></a> computes the average Hamming loss or <a class="reference external" href="http://en.wikipedia.org/wiki/Hamming_distance">Hamming
distance</a> between two sets
of samples.</p>
<p>If <img class="math" src="../_images/math/5006ffbc5dcfb197dae87d662a077f941e570203.png" alt="\hat{y}_j"/> is the predicted value for the <img class="math" src="../_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/>-th labels of
a given sample, <img class="math" src="../_images/math/7e5afa68eb01a86e3fc93b26c2608df5bd10159b.png" alt="y_j"/> is the corresponding true value and
<img class="math" src="../_images/math/a058f7fd60c9f0b5be678d2de8bef4c2587d93b4.png" alt="n_\text{labels}"/> is the number of class or labels, then the
Hamming loss <img class="math" src="../_images/math/e840adff6b2c292512f5c2eb67ad2c9c401366b5.png" alt="L_{Hamming}"/> between two samples is defined as:</p>
<div class="math">
<p><img src="../_images/math/eaa83ad913d07b540296aa7850a0756648059da7.png" alt="L_{Hamming}(y, \hat{y}) = \frac{1}{n_\text{labels}} \sum_{j=0}^{n_\text{labels} - 1} 1(\hat{y}_j \not= y_j)"/></p>
</div><p>where <img class="math" src="../_images/math/6205f47dc46df64205ff4ed08f0e63aed02741ea.png" alt="1(x)"/> is the <a class="reference external" href="http://en.wikipedia.org/wiki/Indicator_function">indicator function</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">hamming_loss</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hamming_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.25</span>
</pre></div>
</div>
<p>In the multilabel case with binary indicator format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">hamming_loss</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="go">0.75</span>
</pre></div>
</div>
<p>and with a list of labels format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">hamming_loss</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">()])</span>  
<span class="go">0.166...</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In multiclass classification, the Hamming loss correspond to the Hamming
distance between <tt class="docutils literal"><span class="pre">y_true</span></tt> and <tt class="docutils literal"><span class="pre">y_pred</span></tt> which is equivalent to the
<a class="reference internal" href="#zero-one-loss"><em>Zero one loss</em></a> function.</p>
<p>In multilabel classification, the Hamming loss is different from the
zero-one loss. The zero-one loss penalizes any predictions that don&#8217;t
exactly match the true required set of labels,
while Hamming loss will penalize the individual labels.
So, predicting a subset or superset of the true labels
will give a Hamming loss strictly between zero and one.</p>
<p class="last">The Hamming loss is upperbounded by the zero-one loss. When normalized
over samples, the Hamming loss is always between zero and one.</p>
</div>
</div>
<div class="section" id="jaccard-similarity-coefficient-score">
<h4>3.5.2.1.5. Jaccard similarity coefficient score<a class="headerlink" href="#jaccard-similarity-coefficient-score" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="generated/sklearn.metrics.jaccard_similarity_score.html#sklearn.metrics.jaccard_similarity_score" title="sklearn.metrics.jaccard_similarity_score"><tt class="xref py py-func docutils literal"><span class="pre">jaccard_similarity_score</span></tt></a> function computes the average (default)
or sum of <a class="reference external" href="http://en.wikipedia.org/wiki/Jaccard_index">Jaccard similarity coefficients</a>, also called Jaccard index,
between pairs of label sets.</p>
<p>The Jaccard similarity coefficient of the <img class="math" src="../_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/>-th samples
with a ground truth label set <img class="math" src="../_images/math/410a65f64e2a609a2a7f544ed72f0982b719807a.png" alt="y_i"/> and a predicted label set
<img class="math" src="../_images/math/e8eb12f9407362d0fc035a12094fcc7797dcb69a.png" alt="\hat{y}_i"/>  is defined as</p>
<div class="math">
<p><img src="../_images/math/4f53fbf22e40f593a72f3f7788bccc7f17b1136c.png" alt="J(y_i, \hat{y}_i) = \frac{|y_i \cap \hat{y}_i|}{|y_i \cup \hat{y}_i|}."/></p>
</div><p>In binary and multiclass classification, the Jaccard similarity coefficient
score is equal to the classification accuracy.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">jaccard_similarity_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jaccard_similarity_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jaccard_similarity_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>In the multilabel case with binary indicator format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">jaccard_similarity_score</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="go">0.75</span>
</pre></div>
</div>
<p>and with a list of labels format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">jaccard_similarity_score</span><span class="p">([(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">()])</span>
<span class="go">0.25</span>
</pre></div>
</div>
</div>
<div class="section" id="precision-recall-and-f-measures">
<span id="precision-recall-f-measure-metrics"></span><h4>3.5.2.1.6. Precision, recall and F-measures<a class="headerlink" href="#precision-recall-and-f-measures" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Precision_and_recall#Precision">precision</a>
is intuitively the ability of the classifier not to label as
positive a sample that is negative.</p>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Precision_and_recall#Recall">recall</a> is
intuitively the ability of the classifier to find all the positive samples.</p>
<p>The  <a class="reference external" href="http://en.wikipedia.org/wiki/F1_score">F-measure</a>
(<img class="math" src="../_images/math/f83bbb89a735c6e2de5fed05a31ac683d1c20699.png" alt="F_\beta"/> and <img class="math" src="../_images/math/86b53a99470bfe410dd9108afdb7a4464f2461fb.png" alt="F_1"/> measures) can be interpreted as a weighted
harmonic mean of the precision and recall. A
<img class="math" src="../_images/math/f83bbb89a735c6e2de5fed05a31ac683d1c20699.png" alt="F_\beta"/> measure reaches its best value at 1 and worst score at 0.
With <img class="math" src="../_images/math/62d80c06c441f97f096c5a6b5f48e6714cb071df.png" alt="\beta = 1"/>, the <img class="math" src="../_images/math/f83bbb89a735c6e2de5fed05a31ac683d1c20699.png" alt="F_\beta"/> measure leads to the
<img class="math" src="../_images/math/86b53a99470bfe410dd9108afdb7a4464f2461fb.png" alt="F_1"/> measure, wheres the recall and the precision are equally important.</p>
<p>The <a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><tt class="xref py py-func docutils literal"><span class="pre">precision_recall_curve</span></tt></a> computes a precision-recall curve
from the ground truth label and a score given by the classifier
by varying a decision threshold.</p>
<p>The <a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><tt class="xref py py-func docutils literal"><span class="pre">average_precision_score</span></tt></a> function computes the average precision
(AP) from prediction scores. This score corresponds to the area under the
precision-recall curve.</p>
<p>Several functions allow you to analyze the precision, recall and F-measures
score:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><tt class="xref py py-obj docutils literal"><span class="pre">average_precision_score</span></tt></a>(y_true,&nbsp;y_score)</td>
<td>Compute average precision (AP) from prediction scores  This score corresponds to the area under the precision-recall curve.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><tt class="xref py py-obj docutils literal"><span class="pre">f1_score</span></tt></a>(y_true,&nbsp;y_pred[,&nbsp;labels,&nbsp;...])</td>
<td>Compute the F1 score, also known as balanced F-score or F-measure  The F1 score can be interpreted as a weighted average of the precision and recall, where an F1 score reaches its best value at 1 and worst score at 0.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/sklearn.metrics.fbeta_score.html#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><tt class="xref py py-obj docutils literal"><span class="pre">fbeta_score</span></tt></a>(y_true,&nbsp;y_pred,&nbsp;beta[,&nbsp;labels,&nbsp;...])</td>
<td>Compute the F-beta score  The F-beta score is the weighted harmonic mean of precision and recall, reaching its optimal value at 1 and its worst value at 0.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><tt class="xref py py-obj docutils literal"><span class="pre">precision_recall_curve</span></tt></a>(y_true,&nbsp;probas_pred)</td>
<td>Compute precision-recall pairs for different probability thresholds  Note: this implementation is restricted to the binary classification task.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/sklearn.metrics.precision_recall_fscore_support.html#sklearn.metrics.precision_recall_fscore_support" title="sklearn.metrics.precision_recall_fscore_support"><tt class="xref py py-obj docutils literal"><span class="pre">precision_recall_fscore_support</span></tt></a>(y_true,&nbsp;y_pred)</td>
<td>Compute precision, recall, F-measure and support for each class  The precision is the ratio <tt class="docutils literal"><span class="pre">tp</span> <span class="pre">/</span> <span class="pre">(tp</span> <span class="pre">+</span> <span class="pre">fp)</span></tt> where <tt class="docutils literal"><span class="pre">tp</span></tt> is the number of true positives and <tt class="docutils literal"><span class="pre">fp</span></tt> the number of false positives.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><tt class="xref py py-obj docutils literal"><span class="pre">precision_score</span></tt></a>(y_true,&nbsp;y_pred[,&nbsp;labels,&nbsp;...])</td>
<td>Compute the precision  The precision is the ratio <tt class="docutils literal"><span class="pre">tp</span> <span class="pre">/</span> <span class="pre">(tp</span> <span class="pre">+</span> <span class="pre">fp)</span></tt> where <tt class="docutils literal"><span class="pre">tp</span></tt> is the number of true positives and <tt class="docutils literal"><span class="pre">fp</span></tt> the number of false positives.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><tt class="xref py py-obj docutils literal"><span class="pre">recall_score</span></tt></a>(y_true,&nbsp;y_pred[,&nbsp;labels,&nbsp;...])</td>
<td>Compute the recall  The recall is the ratio <tt class="docutils literal"><span class="pre">tp</span> <span class="pre">/</span> <span class="pre">(tp</span> <span class="pre">+</span> <span class="pre">fn)</span></tt> where <tt class="docutils literal"><span class="pre">tp</span></tt> is the number of true positives and <tt class="docutils literal"><span class="pre">fn</span></tt> the number of false negatives.</td>
</tr>
</tbody>
</table>
<p>Note that the <a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><tt class="xref py py-func docutils literal"><span class="pre">precision_recall_curve</span></tt></a> function is restricted to the
binary case. The <a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><tt class="xref py py-func docutils literal"><span class="pre">average_precision_score</span></tt></a> function works only in
binary classification and multilabel indicator format.</p>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li>See <a class="reference internal" href="../auto_examples/document_classification_20newsgroups.html#example-document-classification-20newsgroups-py"><em>Classification of text documents using sparse features</em></a>
for an example of <a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><tt class="xref py py-func docutils literal"><span class="pre">f1_score</span></tt></a> usage with classification of text
documents.</li>
<li>See <a class="reference internal" href="../auto_examples/grid_search_digits.html#example-grid-search-digits-py"><em>Parameter estimation using grid search with a nested cross-validation</em></a>
for an example of <a class="reference internal" href="generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><tt class="xref py py-func docutils literal"><span class="pre">precision_score</span></tt></a> and <a class="reference internal" href="generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><tt class="xref py py-func docutils literal"><span class="pre">recall_score</span></tt></a> usage
in parameter estimation using grid search with a nested cross-validation.</li>
<li>See <a class="reference internal" href="../auto_examples/plot_precision_recall.html#example-plot-precision-recall-py"><em>Precision-Recall</em></a>
for an example of precision-Recall metric to evaluate the quality of the
output of a classifier with <a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><tt class="xref py py-func docutils literal"><span class="pre">precision_recall_curve</span></tt></a>.</li>
<li>See <a class="reference internal" href="../auto_examples/linear_model/plot_sparse_recovery.html#example-linear-model-plot-sparse-recovery-py"><em>Sparse recovery: feature selection for sparse linear models</em></a>
for an example of <a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><tt class="xref py py-func docutils literal"><span class="pre">precision_recall_curve</span></tt></a> usage in feature selection
for sparse linear models.</li>
</ul>
</div>
<div class="section" id="binary-classification">
<h5>3.5.2.1.6.1. Binary classification<a class="headerlink" href="#binary-classification" title="Permalink to this headline">¶</a></h5>
<p>In a binary classification task, the terms &#8216;&#8217;positive&#8217;&#8217; and &#8216;&#8217;negative&#8217;&#8217; refer
to the classifier&#8217;s prediction and the terms &#8216;&#8217;true&#8217;&#8217; and &#8216;&#8217;false&#8217;&#8217; refer to
whether that prediction corresponds to the external judgment (sometimes known
as the &#8216;&#8217;observation&#8217;&#8216;). Given these definitions, we can formulate the
following table:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="32%" />
<col width="39%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&nbsp;</td>
<td colspan="2">Actual class (observation)</td>
</tr>
<tr class="row-even"><td rowspan="2">Predicted class
(expectation)</td>
<td>tp (true positive)
Correct result</td>
<td>fp (false positive)
Unexpected result</td>
</tr>
<tr class="row-odd"><td>fn (false negative)
Missing result</td>
<td>tn (true negative)
Correct absence of result</td>
</tr>
</tbody>
</table>
<p>In this context, we can define the notions of precision, recall and F-measure:</p>
<div class="math">
<p><img src="../_images/math/f8029f7b6c8fc80db737d850ed8e10ea8f27e410.png" alt="\text{precision} = \frac{tp}{tp + fp},"/></p>
</div><div class="math">
<p><img src="../_images/math/ca017d3d38a5a935ae8bee84d8143b44f1b32c9a.png" alt="\text{recall} = \frac{tp}{tp + fn},"/></p>
</div><div class="math">
<p><img src="../_images/math/b6183c8fb10498f949131f2aa67eeb1256cdc68a.png" alt="F_\beta = (1 + \beta^2) \frac{\text{precision} \times \text{recall}}{\beta^2 \text{precision} + \text{recall}}."/></p>
</div><p>Here some small examples in binary classification:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">precision_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">recall_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>  
<span class="go">0.66...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">fbeta_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>  
<span class="go">0.83...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">fbeta_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">0.66...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">fbeta_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> 
<span class="go">0.55...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">precision_recall_fscore_support</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>  
<span class="go">(array([ 0.66...,  1.        ]), array([ 1. ,  0.5]), array([ 0.71...,  0.83...]), array([2, 2]...))</span>


<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">precision_recall_curve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">average_precision_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">precision_recall_curve</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_scores</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precision</span>  
<span class="go">array([ 0.66...,  0.5       ,  1.        ,  1.        ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">recall</span>
<span class="go">array([ 1. ,  0.5,  0.5,  0. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">threshold</span>
<span class="go">array([ 0.35,  0.4 ,  0.8 ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">average_precision_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_scores</span><span class="p">)</span>  
<span class="go">0.79...</span>
</pre></div>
</div>
</div>
<div class="section" id="multiclass-and-multilabel-classification">
<h5>3.5.2.1.6.2. Multiclass and multilabel classification<a class="headerlink" href="#multiclass-and-multilabel-classification" title="Permalink to this headline">¶</a></h5>
<p>In multiclass and multilabel classification task, the notions of precision,
recall and F-measures can be applied to each label independently.
There are a few ways to combine results across labels,
specified by the <tt class="docutils literal"><span class="pre">average</span></tt> argument to the
<a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><tt class="xref py py-func docutils literal"><span class="pre">average_precision_score</span></tt></a> (multilabel only), <a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><tt class="xref py py-func docutils literal"><span class="pre">f1_score</span></tt></a>,
<a class="reference internal" href="generated/sklearn.metrics.fbeta_score.html#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><tt class="xref py py-func docutils literal"><span class="pre">fbeta_score</span></tt></a>, <a class="reference internal" href="generated/sklearn.metrics.precision_recall_fscore_support.html#sklearn.metrics.precision_recall_fscore_support" title="sklearn.metrics.precision_recall_fscore_support"><tt class="xref py py-func docutils literal"><span class="pre">precision_recall_fscore_support</span></tt></a>,
<a class="reference internal" href="generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><tt class="xref py py-func docutils literal"><span class="pre">precision_score</span></tt></a> and <a class="reference internal" href="generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><tt class="xref py py-func docutils literal"><span class="pre">recall_score</span></tt></a> functions:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">&quot;micro&quot;</span></tt>: calculate metrics globally by counting the total true
positives, false negatives and false positives. Except in the multi-label
case this implies that precision, recall and <img class="math" src="../_images/math/183421431fcc0a42e22f825a33dcc3c51607fa6e.png" alt="F"/> are equal.</li>
<li><tt class="docutils literal"><span class="pre">&quot;samples&quot;</span></tt>: calculate metrics for each sample, comparing sets of
labels assigned to each, and find the mean across all samples.
This is only meaningful and available in the multilabel case.</li>
<li><tt class="docutils literal"><span class="pre">&quot;macro&quot;</span></tt>: calculate metrics for each label, and find their mean.
This does not take label imbalance into account.</li>
<li><tt class="docutils literal"><span class="pre">&quot;weighted&quot;</span></tt>: calculate metrics for each label, and find their average
weighted by the number of occurrences of the label in the true data.
This alters <tt class="docutils literal"><span class="pre">&quot;macro&quot;</span></tt> to account for label imbalance; it may produce an
F-score that is not between precision and recall.</li>
<li><tt class="docutils literal"><span class="pre">None</span></tt>: calculate metrics for each label and do not average them.</li>
</ul>
<p>To make this more explicit, consider the following notation:</p>
<ul class="simple">
<li><img class="math" src="../_images/math/b124ff74afb0914bb434e8fb849eb56d734412f8.png" alt="y"/> the set of <em>predicted</em> <img class="math" src="../_images/math/1a84eaa6f87e3ed766b4b2f302564b4667ad0ba9.png" alt="(sample, label)"/> pairs</li>
<li><img class="math" src="../_images/math/4edbd88750539c2610a7bbfcf79c33cf1ae7a36c.png" alt="\hat{y}"/> the set of <em>true</em> <img class="math" src="../_images/math/1a84eaa6f87e3ed766b4b2f302564b4667ad0ba9.png" alt="(sample, label)"/> pairs</li>
<li><img class="math" src="../_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/> the set of labels</li>
<li><img class="math" src="../_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/> the set of samples</li>
<li><img class="math" src="../_images/math/efcf8324302d900d3e5d02f6b1215ebdb19c56a1.png" alt="y_s"/> the subset of <img class="math" src="../_images/math/b124ff74afb0914bb434e8fb849eb56d734412f8.png" alt="y"/> with sample <img class="math" src="../_images/math/6859317dd1b439cef34131bcd4bafee8393444e0.png" alt="s"/>,
i.e. <img class="math" src="../_images/math/fbef4da83706299daf2d9e8ac762cb70fae90a64.png" alt="y_s := \left\{(s', l) \in y | s' = s\right\}"/></li>
<li><img class="math" src="../_images/math/0b5a7fd2f2dd52ffb51438669d9acff8026a2db9.png" alt="y_l"/> the subset of <img class="math" src="../_images/math/b124ff74afb0914bb434e8fb849eb56d734412f8.png" alt="y"/> with label <img class="math" src="../_images/math/d99efde75c84ef402a92cd4497530d2366fb112f.png" alt="l"/></li>
<li>similarly, <img class="math" src="../_images/math/a1e3128960061808219116bfa141011127c8a202.png" alt="\hat{y}_s"/> and <img class="math" src="../_images/math/5243a04d6927973d5106a8a447a279b6e7bc8c4e.png" alt="\hat{y}_l"/> are subsets of
<img class="math" src="../_images/math/4edbd88750539c2610a7bbfcf79c33cf1ae7a36c.png" alt="\hat{y}"/></li>
<li><img class="math" src="../_images/math/cfbc38219af5e2dddce2a3752f9ce8c7e36c74f4.png" alt="P(A, B) := \frac{\left| A \cap B \right|}{\left|A\right|}"/></li>
<li><img class="math" src="../_images/math/37bd21d9bdc90aae55a42612868b7627e34e473a.png" alt="R(A, B) := \frac{\left| A \cap B \right|}{\left|B\right|}"/>
(Conventions vary on handling <img class="math" src="../_images/math/5ee39cf1ba2e48363d6da03fe2d74383773ce52d.png" alt="B = \emptyset"/>; this implementation uses
<img class="math" src="../_images/math/53f2b29c5e244e289c3f2f1419cad5f5b59b7a1c.png" alt="R(A, B):=0"/>, and similar for <cite>P</cite>.)</li>
<li><img class="math" src="../_images/math/07c10ca9581adc1e9563003d046a47e32a36d902.png" alt="F_\beta(A, B) := \left(1 + \beta^2\right) \frac{P(A, B) \times R(A, B)}{\beta^2 P(A, B) + R(A, B)}"/></li>
</ul>
<p>Then the metrics are defined as:</p>
<table border="1" class="docutils">
<colgroup>
<col width="4%" />
<col width="32%" />
<col width="32%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><tt class="docutils literal"><span class="pre">average</span></tt></th>
<th class="head">Precision</th>
<th class="head">Recall</th>
<th class="head">F_beta</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">&quot;micro&quot;</span></tt></td>
<td><img class="math" src="../_images/math/949d33e11f3c86a73d4a5e620dfd1303a1a2cb33.png" alt="P(y, \hat{y})"/></td>
<td><img class="math" src="../_images/math/3985035067a2795cdb42d096753adef8367c81db.png" alt="R(y, \hat{y})"/></td>
<td><img class="math" src="../_images/math/95ab6d5fe8ab264f7fdeb24242d837c278e509a6.png" alt="F_\beta(y, \hat{y})"/></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">&quot;samples&quot;</span></tt></td>
<td><img class="math" src="../_images/math/970416fa31b015c6ef397ee8b7073af8ac18e534.png" alt="\frac{1}{\left|S\right|} \sum_{s \in S} P(y_s, \hat{y}_s)"/></td>
<td><img class="math" src="../_images/math/2e32af6e1d375a08fe0603bf8c95696943c558b5.png" alt="\frac{1}{\left|S\right|} \sum_{s \in S} R(y_s, \hat{y}_s)"/></td>
<td><img class="math" src="../_images/math/1ac1b7a14866748c386ccbc41d0b4714aafe1c1e.png" alt="\frac{1}{\left|S\right|} \sum_{s \in S} F_\beta(y_s, \hat{y}_s)"/></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">&quot;macro&quot;</span></tt></td>
<td><img class="math" src="../_images/math/126ebec962b92ea636c9a03b9cb9c6bd2672a1f5.png" alt="\frac{1}{\left|L\right|} \sum_{l \in L} P(y_l, \hat{y}_l)"/></td>
<td><img class="math" src="../_images/math/5f2d199ed595804f94edd64ed3a3ecbe9bb802e0.png" alt="\frac{1}{\left|L\right|} \sum_{l \in L} R(y_l, \hat{y}_l)"/></td>
<td><img class="math" src="../_images/math/d4b9f7415136a81704b29ba2438c4a00f22523b4.png" alt="\frac{1}{\left|L\right|} \sum_{l \in L} F_\beta(y_l, \hat{y}_l)"/></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">&quot;weighted&quot;</span></tt></td>
<td><img class="math" src="../_images/math/482659e43723f207c6852fcf9ec728833d1a059c.png" alt="\frac{1}{\sum_{l \in L} \left|\hat{y}_l\right|} \sum_{l \in L} \left|\hat{y}_l\right| P(y_l, \hat{y}_l)"/></td>
<td><img class="math" src="../_images/math/05f6967941388299e26ac610d9660d3b6e7d1c33.png" alt="\frac{1}{\sum_{l \in L} \left|\hat{y}_l\right|} \sum_{l \in L} \left|\hat{y}_l\right| R(y_l, \hat{y}_l)"/></td>
<td><img class="math" src="../_images/math/09e53d7a8fb63ae416b161ae68bb19b686e99e6c.png" alt="\frac{1}{\sum_{l \in L} \left|\hat{y}_l\right|} \sum_{l \in L} \left|\hat{y}_l\right| F_\beta(y_l, \hat{y}_l)"/></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">None</span></tt></td>
<td><img class="math" src="../_images/math/cea4625fa5fb7540216ae99faa89608515f220ce.png" alt="\langle P(y_l, \hat{y}_l) | l \in L \rangle"/></td>
<td><img class="math" src="../_images/math/2ffabef66048a9e67e450c89a8960d3584a342b1.png" alt="\langle R(y_l, \hat{y}_l) | l \in L \rangle"/></td>
<td><img class="math" src="../_images/math/be3d951d311311b8ef38c7362db122debcb9fa88.png" alt="\langle F_\beta(y_l, \hat{y}_l) | l \in L \rangle"/></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">precision_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s">&#39;macro&#39;</span><span class="p">)</span>  
<span class="go">0.22...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">recall_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s">&#39;micro&#39;</span><span class="p">)</span>
<span class="gp">... </span>
<span class="go">0.33...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s">&#39;weighted&#39;</span><span class="p">)</span>  
<span class="go">0.26...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">fbeta_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s">&#39;macro&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>  
<span class="go">0.23...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">precision_recall_fscore_support</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">... </span>
<span class="go">(array([ 0.66...,  0.        ,  0.        ]), array([ 1.,  0.,  0.]), array([ 0.71...,  0.        ,  0.        ]), array([2, 2, 2]...))</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="hinge-loss">
<h4>3.5.2.1.7. Hinge loss<a class="headerlink" href="#hinge-loss" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="generated/sklearn.metrics.hinge_loss.html#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><tt class="xref py py-func docutils literal"><span class="pre">hinge_loss</span></tt></a> function computes the average
<a class="reference external" href="http://en.wikipedia.org/wiki/Hinge_loss">hinge loss function</a>. The hinge
loss is used in maximal margin classification as support vector machines.</p>
<p>If the labels are encoded with +1 and -1,  <img class="math" src="../_images/math/b124ff74afb0914bb434e8fb849eb56d734412f8.png" alt="y"/>: is the true
value and <img class="math" src="../_images/math/8659700e6646cd91bc02c32affaa5ec046ee9935.png" alt="w"/> is the predicted decisions as output by
<tt class="docutils literal"><span class="pre">decision_function</span></tt>, then the hinge loss is defined as:</p>
<div class="math">
<p><img src="../_images/math/c198beefcd66ade24e26b1063e3cc5fc0fb9e66d.png" alt="L_\text{Hinge}(y, w) = \max\left\{1 - wy, 0\right\} = \left|1 - wy\right|_+"/></p>
</div><p>Here a small example demonstrating the use of the <a class="reference internal" href="generated/sklearn.metrics.hinge_loss.html#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><tt class="xref py py-func docutils literal"><span class="pre">hinge_loss</span></tt></a> function
with a svm classifier:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">svm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">hinge_loss</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">LinearSVC</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">LinearSVC(C=1.0, class_weight=None, dual=True, fit_intercept=True,</span>
<span class="go">     intercept_scaling=1, loss=&#39;l2&#39;, multi_class=&#39;ovr&#39;, penalty=&#39;l2&#39;,</span>
<span class="go">     random_state=0, tol=0.0001, verbose=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_decision</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">decision_function</span><span class="p">([[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_decision</span>  
<span class="go">array([-2.18...,  2.36...,  0.09...])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hinge_loss</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pred_decision</span><span class="p">)</span>  
<span class="go">0.3...</span>
</pre></div>
</div>
</div>
<div class="section" id="log-loss">
<h4>3.5.2.1.8. Log loss<a class="headerlink" href="#log-loss" title="Permalink to this headline">¶</a></h4>
<p>The log loss, also called logistic regression loss or cross-entropy loss,
is a loss function defined on probability estimates.
It is commonly used in (multinomial) logistic regression and neural networks,
as well as some variants of expectation-maximization,
and can be used to evaluate the probability outputs (<tt class="docutils literal"><span class="pre">predict_proba</span></tt>)
of a classifier, rather than its discrete predictions.</p>
<p>For binary classification with a true label <img class="math" src="../_images/math/4ce5799a309845ad2e2905d5fc303adabeac1090.png" alt="y_t \in \{0,1\}"/>
and a probability estimate <img class="math" src="../_images/math/fb7f19d136c877906cbf42c05efddf520499e4ba.png" alt="y_p = P(y_t = 1)"/>,
the log loss per sample is the negative log-likelihood
of the classifier given the true label:</p>
<div class="math">
<p><img src="../_images/math/91706aca8d3653d47617181337dd33b6a4e2c920.png" alt="L_{\log}(y_t, y_p) = -\log P(y_t|y_p) = -(y_t \log y_p + (1 - y_t) \log (1 - y_p))"/></p>
</div><p>This extends to the multiclass case as follows.
Let the true labels for a set of samples
be encoded as a 1-of-K binary indicator matrix <img class="math" src="../_images/math/6d42c88506b8da39a2a23653aecbfb7c29728063.png" alt="T"/>,
i.e. <img class="math" src="../_images/math/ec4d2c77ca13de5c52de896b4fa4f9e529ee914a.png" alt="t_{i,k} = 1"/> if sample <img class="math" src="../_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> has label <img class="math" src="../_images/math/e9203da50e1059455123460d4e716c9c7f440cc3.png" alt="k"/>
taken from a set of <img class="math" src="../_images/math/28e003020d0ae96250b302d7d779c791f183f707.png" alt="K"/> labels.
Let <img class="math" src="../_images/math/b018f9153661cd702305aecc28713fd9705e7cb3.png" alt="Y"/> be a matrix of probability estimates,
with <img class="math" src="../_images/math/e6b11ea10c3e4aef62ba6fdac881c1a75fb33808.png" alt="y_{i,k} = P(t_{i,k} = 1)"/>.
Then the total log loss of the whole set is</p>
<div class="math">
<p><img src="../_images/math/1bde687d20dce9c324f60f9c44f172903f46a873.png" alt="L_{\log}(T, Y) = -\log P(T|Y) = - \sum_i \sum_j t_{i,k} \log y_{i,k}"/></p>
</div><p>The function <a class="reference internal" href="generated/sklearn.metrics.log_loss.html#sklearn.metrics.log_loss" title="sklearn.metrics.log_loss"><tt class="xref py py-func docutils literal"><span class="pre">log_loss</span></tt></a> computes either total or mean log loss
given a list of ground-truth labels and a probability matrix,
as returned by an estimator&#8217;s <tt class="docutils literal"><span class="pre">predict_proba</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">log_loss</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[[</span><span class="o">.</span><span class="mi">9</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">.</span><span class="mi">8</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span> <span class="o">.</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="o">.</span><span class="mo">01</span><span class="p">,</span> <span class="o">.</span><span class="mi">99</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>    
<span class="go">0.1738...</span>
</pre></div>
</div>
<p>The first <tt class="docutils literal"><span class="pre">[.9,</span> <span class="pre">.1]</span></tt> in <tt class="docutils literal"><span class="pre">y_pred</span></tt>
denotes 90% probability that the first sample has label 0.
The log loss is non-negative.</p>
</div>
<div class="section" id="matthews-correlation-coefficient">
<h4>3.5.2.1.9. Matthews correlation coefficient<a class="headerlink" href="#matthews-correlation-coefficient" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="generated/sklearn.metrics.matthews_corrcoef.html#sklearn.metrics.matthews_corrcoef" title="sklearn.metrics.matthews_corrcoef"><tt class="xref py py-func docutils literal"><span class="pre">matthews_corrcoef</span></tt></a> function computes the Matthew&#8217;s correlation
coefficient (MCC) for binary classes (quoting the <a class="reference external" href="http://en.wikipedia.org/wiki/Matthews_correlation_coefficient">Wikipedia article on the
Matthew&#8217;s correlation coefficient</a>):</p>
<blockquote>
<div>&#8220;The Matthews correlation coefficient is used in machine learning as a
measure of the quality of binary (two-class) classifications. It takes
into account true and false positives and negatives and is generally
regarded as a balanced measure which can be used even if the classes are
of very different sizes. The MCC is in essence a correlation coefficient
value between -1 and +1. A coefficient of +1 represents a perfect
prediction, 0 an average random prediction and -1 an inverse prediction.
The statistic is also known as the phi coefficient.&#8221;</div></blockquote>
<p>If <img class="math" src="../_images/math/907f05ef53aaa4e8f4a9f2f06dd3c257f7bc9f5a.png" alt="tp"/>, <img class="math" src="../_images/math/10c1145cd86665e4b73a65a7e9175b18fa65bebc.png" alt="tn"/>, <img class="math" src="../_images/math/cd5f753c7065014aa75c6c7b3a40f9d614d4bba8.png" alt="fp"/> and <img class="math" src="../_images/math/769cd7f00a85e761d9b63fc6a6b4eec08a3a4adf.png" alt="fn"/> are respectively the
number of true positives, true negatives, false positives ans false negatives,
the MCC coefficient is defined as</p>
<div class="math">
<p><img src="../_images/math/6461c5a07ba694eef0501a5b22cf9c4b7ff3a19d.png" alt="MCC = \frac{tp \times tn - fp \times fn}{\sqrt{(tp + fp)(tp + fn)(tn + fp)(tn + fn)}}."/></p>
</div><p>Here a small example illustrating the usage of the <a class="reference internal" href="generated/sklearn.metrics.matthews_corrcoef.html#sklearn.metrics.matthews_corrcoef" title="sklearn.metrics.matthews_corrcoef"><tt class="xref py py-func docutils literal"><span class="pre">matthews_corrcoef</span></tt></a>
function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">matthews_corrcoef</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matthews_corrcoef</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>  
<span class="go">-0.33...</span>
</pre></div>
</div>
</div>
<div class="section" id="receiver-operating-characteristic-roc">
<span id="roc-metrics"></span><h4>3.5.2.1.10. Receiver operating characteristic (ROC)<a class="headerlink" href="#receiver-operating-characteristic-roc" title="Permalink to this headline">¶</a></h4>
<p>The function <a class="reference internal" href="generated/sklearn.metrics.roc_curve.html#sklearn.metrics.roc_curve" title="sklearn.metrics.roc_curve"><tt class="xref py py-func docutils literal"><span class="pre">roc_curve</span></tt></a> computes the <a class="reference external" href="http://en.wikipedia.org/wiki/Receiver_operating_characteristic">receiver operating characteristic
curve, or ROC curve (quoting
Wikipedia)</a>:</p>
<blockquote>
<div>&#8220;A receiver operating characteristic (ROC), or simply ROC curve, is a
graphical plot which illustrates the performance of a binary classifier
system as its discrimination threshold is varied. It is created by plotting
the fraction of true positives out of the positives (TPR = true positive
rate) vs. the fraction of false positives out of the negatives (FPR = false
positive rate), at various threshold settings. TPR is also known as
sensitivity, and FPR is one minus the specificity or true negative rate.&#8221;</div></blockquote>
<p>This function requires the true binary
value and the target scores, which can either be probability estimates of the
positive class, confidence values, or binary decisions.
Here a small example of how to use the <a class="reference internal" href="generated/sklearn.metrics.roc_curve.html#sklearn.metrics.roc_curve" title="sklearn.metrics.roc_curve"><tt class="xref py py-func docutils literal"><span class="pre">roc_curve</span></tt></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_curve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">pos_label</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fpr</span>
<span class="go">array([ 0. ,  0.5,  0.5,  1. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tpr</span>
<span class="go">array([ 0.5,  0.5,  1. ,  1. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresholds</span>
<span class="go">array([ 0.8 ,  0.4 ,  0.35,  0.1 ])</span>
</pre></div>
</div>
<p>The following figure shows an example of such ROC curve.</p>
<a class="reference external image-reference" href="../auto_examples/plot_roc.html"><img alt="../_images/plot_roc_11.png" class="align-center" src="../_images/plot_roc_11.png" style="width: 600.0px; height: 450.0px;" /></a>
<p>The <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><tt class="xref py py-func docutils literal"><span class="pre">roc_auc_score</span></tt></a> function computes the area under the receiver
operating characteristic (ROC) curve, which is also denoted by
AUC or AUROC.  By computing the
area under the roc curve, the curve information is summarized in one number.
For more information see the <a class="reference external" href="http://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_curve">Wikipedia article on AUC</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_auc_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_scores</span><span class="p">)</span>
<span class="go">0.75</span>
</pre></div>
</div>
<p>In multi-label classification, the <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><tt class="xref py py-func docutils literal"><span class="pre">roc_auc_score</span></tt></a> function is
extended by averaging over the labels:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">&quot;micro&quot;</span></tt>: computes the area under the ROC curve globally obtained
by considering each element of the label indicator matrix as a label.</li>
<li><tt class="docutils literal"><span class="pre">&quot;samples&quot;</span></tt>: computes the area under the ROC curve on each sample,
comparing the set of labels and scores assigned to each, and find the mean
across all samples.</li>
<li><tt class="docutils literal"><span class="pre">&quot;macro&quot;</span></tt>: computes the area under the ROC curve for each label, and find
their mean.</li>
<li><tt class="docutils literal"><span class="pre">&quot;weighted&quot;</span></tt>: computes the area under the ROC curve for each label, and
find their average weighted by the number of occurrences of the label in the
true data.</li>
<li><tt class="docutils literal"><span class="pre">None</span></tt>: this returns an array of scores with scores with shape (n_classes,)
instead of an aggregate scalar score.</li>
</ul>
<p>Compared to metrics such as the subset accuracy, the hamming loss or the
F1 score, ROC AUC doesn&#8217;t require to optimize a threshold for each label. The
<a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><tt class="xref py py-func docutils literal"><span class="pre">roc_auc_score</span></tt></a> function can also be used in multi-class classification
if predicted outputs have been binarized.</p>
<a class="reference external image-reference" href="../auto_examples/plot_roc.html"><img alt="modules/../auto_examples/images/plot_roc_2.png" class="align-center" src="modules/../auto_examples/images/plot_roc_2.png" /></a>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li>See <a class="reference internal" href="../auto_examples/plot_roc.html#example-plot-roc-py"><em>Receiver Operating Characteristic (ROC)</em></a>
for an example of receiver operating characteristic (ROC) metric to
evaluate the quality of the output of a classifier.</li>
<li>See <a class="reference internal" href="../auto_examples/plot_roc_crossval.html#example-plot-roc-crossval-py"><em>Receiver Operating Characteristic (ROC) with cross validation</em></a>
for an example of receiver operating characteristic (ROC) metric to
evaluate the quality of the output of a classifier using cross-validation.</li>
<li>See <a class="reference internal" href="../auto_examples/applications/plot_species_distribution_modeling.html#example-applications-plot-species-distribution-modeling-py"><em>Species distribution modeling</em></a>
for an example of receiver operating characteristic (ROC) metric to
model species distribution.</li>
</ul>
</div>
</div>
<div class="section" id="zero-one-loss">
<span id="id4"></span><h4>3.5.2.1.11. Zero one loss<a class="headerlink" href="#zero-one-loss" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="generated/sklearn.metrics.zero_one_loss.html#sklearn.metrics.zero_one_loss" title="sklearn.metrics.zero_one_loss"><tt class="xref py py-func docutils literal"><span class="pre">zero_one_loss</span></tt></a> function computes the sum or the average of the 0-1
classification loss (<img class="math" src="../_images/math/804a9c8168cae2d295c66c7e62007ae903dbbd31.png" alt="L_{0-1}"/>) over <img class="math" src="../_images/math/e088d1aeabf6b6f6608c43bb18829dd7a4097d7f.png" alt="n_{\text{samples}}"/>. By
defaults, the function normalizes over the sample. To get the sum of the
<img class="math" src="../_images/math/804a9c8168cae2d295c66c7e62007ae903dbbd31.png" alt="L_{0-1}"/>, set <tt class="docutils literal"><span class="pre">normalize</span></tt>  to <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<p>In multilabel classification, the <a class="reference internal" href="generated/sklearn.metrics.zero_one_loss.html#sklearn.metrics.zero_one_loss" title="sklearn.metrics.zero_one_loss"><tt class="xref py py-func docutils literal"><span class="pre">zero_one_loss</span></tt></a> function corresponds
to the subset zero-one loss: the subset of labels must be correctly predict.</p>
<p>If <img class="math" src="../_images/math/e8eb12f9407362d0fc035a12094fcc7797dcb69a.png" alt="\hat{y}_i"/> is the predicted value of
the <img class="math" src="../_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/>-th sample and <img class="math" src="../_images/math/410a65f64e2a609a2a7f544ed72f0982b719807a.png" alt="y_i"/> is the corresponding true value,
then the 0-1 loss <img class="math" src="../_images/math/804a9c8168cae2d295c66c7e62007ae903dbbd31.png" alt="L_{0-1}"/> is defined as:</p>
<div class="math">
<p><img src="../_images/math/ffc7ed353dab8e432d5438f675003c661b61c118.png" alt="L_{0-1}(y_i, \hat{y}_i) = 1(\hat{y}_i \not= y_i)"/></p>
</div><p>where <img class="math" src="../_images/math/6205f47dc46df64205ff4ed08f0e63aed02741ea.png" alt="1(x)"/> is the <a class="reference external" href="http://en.wikipedia.org/wiki/Indicator_function">indicator function</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">zero_one_loss</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zero_one_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zero_one_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>In the multilabel case with binary indicator format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">zero_one_loss</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="go">0.5</span>
</pre></div>
</div>
<p>and with a list of labels format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">zero_one_loss</span><span class="p">([(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">()])</span>
<span class="go">1.0</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">Example:</p>
<ul class="simple">
<li>See <a class="reference internal" href="../auto_examples/plot_rfe_with_cross_validation.html#example-plot-rfe-with-cross-validation-py"><em>Recursive feature elimination with cross-validation</em></a>
for an example of the zero one loss usage to perform recursive feature
elimination with cross-validation.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="regression-metrics">
<span id="id6"></span><h3>3.5.2.2. Regression metrics<a class="headerlink" href="#regression-metrics" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="classes.html#module-sklearn.metrics" title="sklearn.metrics"><tt class="xref py py-mod docutils literal"><span class="pre">sklearn.metrics</span></tt></a> implements several losses, scores and utility
functions to measure regression performance. Some of those have been enhanced
to handle the multioutput case: <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error.html#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><tt class="xref py py-func docutils literal"><span class="pre">mean_absolute_error</span></tt></a>,
<a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error.html#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><tt class="xref py py-func docutils literal"><span class="pre">mean_absolute_error</span></tt></a> and <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><tt class="xref py py-func docutils literal"><span class="pre">r2_score</span></tt></a>.</p>
<div class="section" id="explained-variance-score">
<h4>3.5.2.2.1. Explained variance score<a class="headerlink" href="#explained-variance-score" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="generated/sklearn.metrics.explained_variance_score.html#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><tt class="xref py py-func docutils literal"><span class="pre">explained_variance_score</span></tt></a> computes the <a class="reference external" href="http://en.wikipedia.org/wiki/Explained_variation">explained variance
regression score</a>.</p>
<p>If <img class="math" src="../_images/math/4edbd88750539c2610a7bbfcf79c33cf1ae7a36c.png" alt="\hat{y}"/> is the estimated target output
and <img class="math" src="../_images/math/b124ff74afb0914bb434e8fb849eb56d734412f8.png" alt="y"/> is the corresponding (correct) target output, then the explained
variance is  estimated  as follow:</p>
<div class="math">
<p><img src="../_images/math/56782c21fe4a6ef3b34912b9e13463b1e23f6719.png" alt="\texttt{explained\_{}variance}(y, \hat{y}) = 1 - \frac{Var\{ y - \hat{y}\}}{Var\{y\}}"/></p>
</div><p>The best possible score is 1.0, lower values are worse.</p>
<p>Here a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.explained_variance_score.html#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><tt class="xref py py-func docutils literal"><span class="pre">explained_variance_score</span></tt></a>
function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">explained_variance_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">explained_variance_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>  
<span class="go">0.957...</span>
</pre></div>
</div>
</div>
<div class="section" id="mean-absolute-error">
<h4>3.5.2.2.2. Mean absolute error<a class="headerlink" href="#mean-absolute-error" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error.html#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><tt class="xref py py-func docutils literal"><span class="pre">mean_absolute_error</span></tt></a> function computes the <a class="reference external" href="http://en.wikipedia.org/wiki/Mean_absolute_error">mean absolute
error</a>, which is a risk
function corresponding to the expected value of the absolute error loss or
<img class="math" src="../_images/math/c3a1ea1c5ef9f9923d99db023a65c73d4b6dbc94.png" alt="l1"/>-norm loss.</p>
<p>If <img class="math" src="../_images/math/e8eb12f9407362d0fc035a12094fcc7797dcb69a.png" alt="\hat{y}_i"/> is the predicted value of the <img class="math" src="../_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/>-th sample
and <img class="math" src="../_images/math/410a65f64e2a609a2a7f544ed72f0982b719807a.png" alt="y_i"/> is the corresponding true value, then the mean absolute error
(MAE) estimated over <img class="math" src="../_images/math/e088d1aeabf6b6f6608c43bb18829dd7a4097d7f.png" alt="n_{\text{samples}}"/> is defined as</p>
<div class="math">
<p><img src="../_images/math/c9069138144f82207c7a093887720188291e663a.png" alt="\text{MAE}(y, \hat{y}) = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}}-1} \left| y_i - \hat{y}_i \right|."/></p>
</div><p>Here a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error.html#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><tt class="xref py py-func docutils literal"><span class="pre">mean_absolute_error</span></tt></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_absolute_error</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_absolute_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_absolute_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.75</span>
</pre></div>
</div>
</div>
<div class="section" id="mean-squared-error">
<h4>3.5.2.2.3. Mean squared error<a class="headerlink" href="#mean-squared-error" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><tt class="xref py py-func docutils literal"><span class="pre">mean_squared_error</span></tt></a> function computes the <a class="reference external" href="http://en.wikipedia.org/wiki/Mean_squared_error">mean square
error</a>, which is a risk
function corresponding to the expected value of the squared error loss or
quadratic loss.</p>
<p>If <img class="math" src="../_images/math/e8eb12f9407362d0fc035a12094fcc7797dcb69a.png" alt="\hat{y}_i"/> is the predicted value of the <img class="math" src="../_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/>-th sample
and <img class="math" src="../_images/math/410a65f64e2a609a2a7f544ed72f0982b719807a.png" alt="y_i"/> is the corresponding true value, then the mean squared error
(MSE) estimated over <img class="math" src="../_images/math/e088d1aeabf6b6f6608c43bb18829dd7a4097d7f.png" alt="n_{\text{samples}}"/> is defined as</p>
<div class="math">
<p><img src="../_images/math/b141ee17d93799d1b44c7ba206a859af1a21ba2e.png" alt="\text{MSE}(y, \hat{y}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples} - 1} (y_i - \hat{y}_i)^2."/></p>
</div><p>Here a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><tt class="xref py py-func docutils literal"><span class="pre">mean_squared_error</span></tt></a>
function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.375</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>  
<span class="go">0.7083...</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li>See <a class="reference internal" href="../auto_examples/ensemble/plot_gradient_boosting_regression.html#example-ensemble-plot-gradient-boosting-regression-py"><em>Gradient Boosting regression</em></a>
for an example of mean squared error usage to
evaluate gradient boosting regression.</li>
</ul>
</div>
</div>
<div class="section" id="r2-score-the-coefficient-of-determination">
<h4>3.5.2.2.4. R² score, the coefficient of determination<a class="headerlink" href="#r2-score-the-coefficient-of-determination" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><tt class="xref py py-func docutils literal"><span class="pre">r2_score</span></tt></a> function computes R², the <a class="reference external" href="http://en.wikipedia.org/wiki/Coefficient_of_determination">coefficient of
determination</a>.
It provides a measure of how well future samples are likely to
be predicted by the model.</p>
<p>If <img class="math" src="../_images/math/e8eb12f9407362d0fc035a12094fcc7797dcb69a.png" alt="\hat{y}_i"/> is the predicted value of the <img class="math" src="../_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/>-th sample
and <img class="math" src="../_images/math/410a65f64e2a609a2a7f544ed72f0982b719807a.png" alt="y_i"/> is the corresponding true value, then the score R² estimated
over <img class="math" src="../_images/math/e088d1aeabf6b6f6608c43bb18829dd7a4097d7f.png" alt="n_{\text{samples}}"/> is defined as</p>
<div class="math">
<p><img src="../_images/math/02fd9261058a79736b1df19af192c584f222eb3a.png" alt="R^2(y, \hat{y}) = 1 - \frac{\sum_{i=0}^{n_{\text{samples}} - 1} (y_i - \hat{y}_i)^2}{\sum_{i=0}^{n_\text{samples} - 1} (y_i - \bar{y})^2}"/></p>
</div><p>where <img class="math" src="../_images/math/8953d4d91d7fd620495bfa79ff5f9efe6e94ea84.png" alt="\bar{y} =  \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}} - 1} y_i"/>.</p>
<p>Here a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><tt class="xref py py-func docutils literal"><span class="pre">r2_score</span></tt></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">r2_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>  
<span class="go">0.948...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>  
<span class="go">0.938...</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">Example:</p>
<ul class="simple">
<li>See <a class="reference internal" href="../auto_examples/linear_model/plot_lasso_and_elasticnet.html#example-linear-model-plot-lasso-and-elasticnet-py"><em>Lasso and Elastic Net for Sparse Signals</em></a>
for an example of R² score usage to
evaluate Lasso and Elastic Net on sparse signals.</li>
</ul>
</div>
</div>
</div>
</div>
<div class="section" id="clustering-metrics">
<h2>3.5.3. Clustering metrics<a class="headerlink" href="#clustering-metrics" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="classes.html#module-sklearn.metrics" title="sklearn.metrics"><tt class="xref py py-mod docutils literal"><span class="pre">sklearn.metrics</span></tt></a> implements several losses, scores and utility
function for more information see the <a class="reference internal" href="clustering.html#clustering-evaluation"><em>Clustering performance evaluation</em></a>
section.</p>
</div>
<div class="section" id="biclustering-metrics">
<h2>3.5.4. Biclustering metrics<a class="headerlink" href="#biclustering-metrics" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="classes.html#module-sklearn.metrics" title="sklearn.metrics"><tt class="xref py py-mod docutils literal"><span class="pre">sklearn.metrics</span></tt></a> module implements bicluster scoring
metrics. For more information see the <a class="reference internal" href="biclustering.html#biclustering-evaluation"><em>Biclustering evaluation</em></a>
section.</p>
<div class="section" id="id8">
<span id="id9"></span><h3>3.5.4.1. Clustering metrics<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="classes.html#module-sklearn.metrics" title="sklearn.metrics"><tt class="xref py py-mod docutils literal"><span class="pre">sklearn.metrics</span></tt></a> implements several losses, scores and utility
functions. For more information see the <a class="reference internal" href="clustering.html#clustering-evaluation"><em>Clustering performance evaluation</em></a> section.</p>
</div>
</div>
<div class="section" id="dummy-estimators">
<span id="id10"></span><h2>3.5.5. Dummy estimators<a class="headerlink" href="#dummy-estimators" title="Permalink to this headline">¶</a></h2>
<p>When doing supervised learning, a simple sanity check consists in comparing
one&#8217;s estimator against simple rules of thumb. <a class="reference internal" href="generated/sklearn.dummy.DummyClassifier.html#sklearn.dummy.DummyClassifier" title="sklearn.dummy.DummyClassifier"><tt class="xref py py-class docutils literal"><span class="pre">DummyClassifier</span></tt></a>
implements three such simple strategies for classification:</p>
<ul>
<li><p class="first"><cite>stratified</cite> generates randomly predictions by respecting the training
set&#8217;s class distribution,</p>
</li>
<li><p class="first"><cite>most_frequent</cite> always predicts the most frequent label in the training set,</p>
</li>
<li><p class="first"><cite>uniform</cite> generates predictions uniformly at random.</p>
</li>
<li><dl class="first docutils">
<dt><cite>constant</cite> always predicts a constant label that is provided by the user.</dt>
<dd><p class="first last">A major motivation of this method is F1-scoring when the positive class
is in the minority.</p>
</dd>
</dl>
</li>
</ul>
<p>Note that with all these strategies, the <cite>predict</cite> method completely ignores
the input data!</p>
<p>To illustrate <a class="reference internal" href="generated/sklearn.dummy.DummyClassifier.html#sklearn.dummy.DummyClassifier" title="sklearn.dummy.DummyClassifier"><tt class="xref py py-class docutils literal"><span class="pre">DummyClassifier</span></tt></a>, first let&#8217;s create an imbalanced
dataset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_iris</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iris</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, let&#8217;s compare the accuracy of <cite>SVC</cite> and <cite>most_frequent</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.dummy</span> <span class="kn">import</span> <span class="n">DummyClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span> 
<span class="go">0.63...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">DummyClassifier</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s">&#39;most_frequent&#39;</span><span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="go">DummyClassifier(constant=None, random_state=0, strategy=&#39;most_frequent&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>  
<span class="go">0.57...</span>
</pre></div>
</div>
<p>We see that <cite>SVC</cite> doesn&#8217;t do much better than a dummy classifier. Now, let&#8217;s
change the kernel:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">&#39;rbf&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>  
<span class="go">0.97...</span>
</pre></div>
</div>
<p>We see that the accuracy was boosted to almost 100%. For a better estimate
of the accuracy, it is recommended to use a cross validation strategy, if it
is not too CPU costly. For more information see the <a class="reference internal" href="cross_validation.html#cross-validation"><em>Cross-validation: evaluating estimator performance</em></a>
section. Moreover if you want to optimize over the parameter space, it is
highly recommended to use an appropriate methodology see the <a class="reference internal" href="grid_search.html#grid-search"><em>Grid Search: Searching for estimator parameters</em></a>
section.</p>
<p>More generally, when the accuracy of a classifier is too close to random
classification, it probably means that something went wrong: features are not
helpful, a hyper parameter is not correctly tuned, the classifier is suffering
from class imbalance, etc...</p>
<p><a class="reference internal" href="generated/sklearn.dummy.DummyRegressor.html#sklearn.dummy.DummyRegressor" title="sklearn.dummy.DummyRegressor"><tt class="xref py py-class docutils literal"><span class="pre">DummyRegressor</span></tt></a> implements a simple rule of thumb for regression:
always predict the mean of the training targets.</p>
</div>
</div>


          </div>
        </div>
      </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer">
        &copy; 2010 - 2014, scikit-learn developers (BSD License).
      <a href="../_sources/modules/model_evaluation.txt" rel="nofollow">Show this page source</a>
    </div>
     <div class="rel">
    
    <div class="buttonPrevious">
      <a href="pipeline.html">Previous
      </a>
    </div>
    <div class="buttonNext">
      <a href="learning_curve.html">Next
      </a>
    </div>
    <div class="buttonPrevious">
      <a href="../np-modindex.html">Previous
      </a>
    </div>
    <div class="buttonNext">
      <a href="../py-modindex.html">Next
      </a>
    </div>
    
     </div>

    
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-22606712-2']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    

    <script src="http://www.google.com/jsapi" type="text/javascript"></script>
    <script type="text/javascript"> google.load('search', '1',
        {language : 'en'}); google.setOnLoadCallback(function() {
            var customSearchControl = new
            google.search.CustomSearchControl('016639176250731907682:tjtqbvtvij0');
            customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
            var options = new google.search.DrawOptions();
            options.setAutoComplete(true);
            customSearchControl.draw('cse', options); }, true);
    </script>
  </body>
</html>