<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>numpy.linalg.qr — NumPy v1.8 Manual</title>
<link href="../../_static/css/spc-bootstrap.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/css/spc-extend.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/scipy.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.8.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
<script src="../../_static/js/jquery.min.js" type="text/javascript"></script>
<script src="../../_static/js/bootstrap.min.js" type="text/javascript"></script>
<script src="../../_static/jquery.js" type="text/javascript"></script>
<script src="../../_static/underscore.js" type="text/javascript"></script>
<script src="../../_static/doctools.js" type="text/javascript"></script>
<link href="../../about.html" rel="author" title="About these documents"/>
<link href="../../index.html" rel="top" title="NumPy v1.8 Manual"/>
<link href="../routines.linalg.html" rel="up" title="Linear algebra (numpy.linalg)"/>
<link href="numpy.linalg.svd.html" rel="next" title="numpy.linalg.svd"/>
<link href="numpy.linalg.cholesky.html" rel="prev" title="numpy.linalg.cholesky"/>
</head>
<body>
<div class="container">
<div class="header">
</div>
</div>
<div class="container">
<div class="main">
<div class="row-fluid">
<div class="span12">
<div class="spc-navbar">
<ul class="nav nav-pills pull-left">
<li class="active"><a href="../../index.html">NumPy v1.8 Manual</a></li>
<li class="active"><a href="../index.html">NumPy Reference</a></li>
<li class="active"><a href="../routines.html">Routines</a></li>
<li class="active"><a accesskey="U" href="../routines.linalg.html">Linear algebra (<tt class="docutils literal"><span class="pre">numpy.linalg</span></tt>)</a></li>
</ul>
<ul class="nav nav-pills pull-right">
<li class="active">
<a accesskey="I" href="../../genindex.html" title="General Index">index</a>
</li>
<li class="active">
<a accesskey="N" href="numpy.linalg.svd.html" title="numpy.linalg.svd">next</a>
</li>
<li class="active">
<a accesskey="P" href="numpy.linalg.cholesky.html" title="numpy.linalg.cholesky">previous</a>
</li>
</ul>
</div>
</div>
</div>
<div class="row-fluid">
<div class="spc-rightsidebar span3">
<div class="sphinxsidebarwrapper">
<h4>Previous topic</h4>
<p class="topless"><a href="numpy.linalg.cholesky.html" title="previous chapter">numpy.linalg.cholesky</a></p>
<h4>Next topic</h4>
<p class="topless"><a href="numpy.linalg.svd.html" title="next chapter">numpy.linalg.svd</a></p>
</div>
</div>
<div class="span9">
<div class="bodywrapper">
<div class="body" id="spc-section-body">
<div class="section" id="numpy-linalg-qr">
<h1>numpy.linalg.qr<a class="headerlink" href="#numpy-linalg-qr" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="numpy.linalg.qr"><a name="//apple_ref/cpp/func/numpy.linalg.qr"></a>
<tt class="descclassname">numpy.linalg.</tt><tt class="descname">qr</tt><big>(</big><em>a</em>, <em>mode='reduced'</em><big>)</big><a class="reference external" href="http://github.com/numpy/numpy/blob/v1.8.0/numpy/linalg/linalg.py#L607"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#numpy.linalg.qr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the qr factorization of a matrix.</p>
<p>Factor the matrix <em class="xref py py-obj">a</em> as <em>qr</em>, where <em class="xref py py-obj">q</em> is orthonormal and <em class="xref py py-obj">r</em> is
upper-triangular.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>a</strong> : array_like, shape (M, N)</p>
<blockquote>
<div><p>Matrix to be factored.</p>
</div></blockquote>
<p><strong>mode</strong> : {‘reduced’, ‘complete’, ‘r’, ‘raw’, ‘full’, ‘economic’}, optional</p>
<blockquote>
<div><p>If K = min(M, N), then</p>
<p>‘reduced’  : returns q, r with dimensions (M, K), (K, N) (default)
‘complete’ : returns q, r with dimensions (M, M), (M, N)
‘r’        : returns r only with dimensions (K, N)
‘raw’      : returns h, tau with dimensions (N, M), (K,)
‘full’     : alias of ‘reduced’, deprecated
‘economic’ : returns h from ‘raw’, deprecated.</p>
<p>The options ‘reduced’, ‘complete, and ‘raw’ are new in numpy 1.8,
see the notes for more information. The default is ‘reduced’ and to
maintain backward compatibility with earlier versions of numpy both
it and the old default ‘full’ can be omitted. Note that array h
returned in ‘raw’ mode is transposed for calling Fortran. The
‘economic’ mode is deprecated.  The modes ‘full’ and ‘economic’ may
be passed using only the first letter for backwards compatibility,
but all others must be spelled out. See the Notes for more
explanation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>q</strong> : ndarray of float or complex, optional</p>
<blockquote>
<div><p>A matrix with orthonormal columns. When mode = ‘complete’ the
result is an orthogonal/unitary matrix depending on whether or not
a is real/complex. The determinant may be either +/- 1 in that
case.</p>
</div></blockquote>
<p><strong>r</strong> : ndarray of float or complex, optional</p>
<blockquote>
<div><p>The upper-triangular matrix.</p>
</div></blockquote>
<p><strong>(h, tau)</strong> : ndarrays of np.double or np.cdouble, optional</p>
<blockquote>
<div><p>The array h contains the Householder reflectors that generate q
along with r. The tau array contains scaling factors for the
reflectors. In the deprecated  ‘economic’ mode only h is returned.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first"><strong>LinAlgError</strong></p>
<blockquote class="last">
<div><p>If factoring fails.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This is an interface to the LAPACK routines dgeqrf, zgeqrf,
dorgqr, and zungqr.</p>
<p>For more information on the qr factorization, see for example:
<a class="reference external" href="http://en.wikipedia.org/wiki/QR_factorization">http://en.wikipedia.org/wiki/QR_factorization</a></p>
<p>Subclasses of <em class="xref py py-obj">ndarray</em> are preserved except for the ‘raw’ mode. So if
<em class="xref py py-obj">a</em> is of type <em class="xref py py-obj">matrix</em>, all the return values will be matrices too.</p>
<p>New ‘reduced’, ‘complete’, and ‘raw’ options for mode were added in
Numpy 1.8 and the old option ‘full’ was made an alias of ‘reduced’.  In
addition the options ‘full’ and ‘economic’ were deprecated.  Because
‘full’ was the previous default and ‘reduced’ is the new default,
backward compatibility can be maintained by letting <em class="xref py py-obj">mode</em> default.
The ‘raw’ option was added so that LAPACK routines that can multiply
arrays by q using the Householder reflectors can be used. Note that in
this case the returned arrays are of type np.double or np.cdouble and
the h array is transposed to be FORTRAN compatible.  No routines using
the ‘raw’ return are currently exposed by numpy, but some are available
in lapack_lite and just await the necessary work.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>  <span class="c"># a does equal qr</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">'r'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">'economic'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>  <span class="c"># mode='r' returns the same r as mode='full'</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># But only triu parts are guaranteed equal when mode='economic'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">r3</span><span class="p">[:</span><span class="mi">6</span><span class="p">,:</span><span class="mi">6</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Example illustrating a common use of <a class="reference internal" href="#numpy.linalg.qr" title="numpy.linalg.qr"><tt class="xref py py-obj docutils literal"><span class="pre">qr</span></tt></a>: solving of least squares
problems</p>
<p>What are the least-squares-best <em class="xref py py-obj">m</em> and <em class="xref py py-obj">y0</em> in <tt class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">y0</span> <span class="pre">+</span> <span class="pre">mx</span></tt> for
the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points
and you’ll see that it should be y0 = 0, m = 1.)  The answer is provided
by solving the over-determined matrix equation <tt class="docutils literal"><span class="pre">Ax</span> <span class="pre">=</span> <span class="pre">b</span></tt>, where:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="n">y0</span><span class="p">],</span> <span class="p">[</span><span class="n">m</span><span class="p">]])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
<p>If A = qr such that q is orthonormal (which is always possible via
Gram-Schmidt), then <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">inv(r)</span> <span class="pre">*</span> <span class="pre">(q.T)</span> <span class="pre">*</span> <span class="pre">b</span></tt>.  (In numpy practice,
however, we simply use <a class="reference internal" href="numpy.linalg.lstsq.html#numpy.linalg.lstsq" title="numpy.linalg.lstsq"><tt class="xref py py-obj docutils literal"><span class="pre">lstsq</span></tt></a>.)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [2, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">LA</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">p</span><span class="p">)</span>
<span class="go">array([  1.1e-16,   1.0e+00])</span>
</pre></div>
</div>
</dd></dl>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="container container-navbar-bottom">
<div class="spc-navbar">
</div>
</div>
<div class="container">
<div class="footer">
<div class="row-fluid">
<ul class="inline pull-left">
<li>
        © Copyright 2008-2009, The Scipy community.
      </li>
<li>
      Last updated on Nov 10, 2013.
      </li>
<li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
      </li>
</ul>
</div>
</div>
</div>
</body>
</html>