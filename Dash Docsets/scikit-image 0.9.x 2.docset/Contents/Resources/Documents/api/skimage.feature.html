<!DOCTYPE html>
<html lang="en">
<head>
<title>Module: feature — skimage v0.9.0 docs</title>
<link href="../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css"/>
<link href="../_static/css/custom.css" rel="stylesheet" type="text/css"/>
<link href="http://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css"/>
<script src="http://code.jquery.com/jquery-latest.js"></script>
<script src="../_static/js/bootstrap.min.js"></script>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
<script src="../_static/jquery.js" type="text/javascript"></script>
<script src="../_static/underscore.js" type="text/javascript"></script>
<script src="../_static/doctools.js" type="text/javascript"></script>
<link href="../index.html" rel="top" title="skimage v0.9.0 docs"/>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
<link href="../_static/favicon.ico" rel="shortcut icon"/>
</head>
<body class="container">
<a class="logo" href="http://scikit-image.org"><img alt="" src="../_static/img/logo.png"/></a>
<div class="clearfix"></div>
<div class="navbar">
<div class="navbar-inner">
<ul class="nav">
<li><a href="/">Home</a></li>
<li><a href="/download.html">Download</a></li>
<li><a href="/docs/dev/auto_examples">Gallery</a></li>
<li><a href="/docs/dev">Documentation</a></li>
<li><a href="https://github.com/scikit-image/scikit-image">Source</a></li>
</ul>
<form action="../search.html" class="navbar-form pull-right" method="get">
<input class="search span3" name="q" placeholder="Search documentation ..." type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div class="row">
<div class="span9">
<div class="section" id="module-skimage.feature">
<span id="module-feature"></span><h1><a name="//apple_ref/cpp/Module/skimage.feature"></a>Module: <tt class="xref py py-mod docutils literal"><span class="pre">feature</span></tt><a class="headerlink" href="#module-skimage.feature" title="Permalink to this headline">¶</a></h1>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"></col>
<col width="90%"></col>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.corner_foerstner" title="skimage.feature.corner_foerstner"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_foerstner</span></tt></a>(image[, sigma])</td>
<td>Compute Foerstner corner measure response image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.corner_harris" title="skimage.feature.corner_harris"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_harris</span></tt></a>(image[, ...])</td>
<td>Compute Harris corner measure response image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.corner_kitchen_rosenfeld" title="skimage.feature.corner_kitchen_rosenfeld"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_kitchen_rosenfeld</span></tt></a>(image)</td>
<td>Compute Kitchen and Rosenfeld corner measure response image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.corner_moravec" title="skimage.feature.corner_moravec"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_moravec</span></tt></a></td>
<td>Compute Moravec corner measure response image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.corner_peaks" title="skimage.feature.corner_peaks"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_peaks</span></tt></a>(image[, ...])</td>
<td>Find corners in corner measure response image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.corner_shi_tomasi" title="skimage.feature.corner_shi_tomasi"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_shi_tomasi</span></tt></a>(image[, sigma])</td>
<td>Compute Shi-Tomasi (Kanade-Tomasi) corner measure response image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.corner_subpix" title="skimage.feature.corner_subpix"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_subpix</span></tt></a>(image, corners)</td>
<td>Determine subpixel position of corners.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.daisy" title="skimage.feature.daisy"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.daisy</span></tt></a>(img[, step, radius, ...])</td>
<td>Extract DAISY feature descriptors densely for the given image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.greycomatrix" title="skimage.feature.greycomatrix"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.greycomatrix</span></tt></a>(image, ...[, ...])</td>
<td>Calculate the grey-level co-occurrence matrix.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.greycoprops" title="skimage.feature.greycoprops"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.greycoprops</span></tt></a>(P[, prop])</td>
<td>Calculate texture properties of a GLCM.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.hog" title="skimage.feature.hog"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.hog</span></tt></a>(image[, orientations, ...])</td>
<td>Extract Histogram of Oriented Gradients (HOG) for a given image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.local_binary_pattern" title="skimage.feature.local_binary_pattern"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.local_binary_pattern</span></tt></a>(image, P, R)</td>
<td>Gray scale and rotation invariant LBP (Local Binary Patterns).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.match_template" title="skimage.feature.match_template"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.match_template</span></tt></a>(image, template)</td>
<td>Match a template to an image using normalized correlation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.peak_local_max" title="skimage.feature.peak_local_max"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.peak_local_max</span></tt></a>(image[, ...])</td>
<td>Find peaks in an image, and return them as coordinates or a boolean array.</td>
</tr>
</tbody>
</table>
<div class="section" id="corner-foerstner">
<h2>corner_foerstner<a class="headerlink" href="#corner-foerstner" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_foerstner"><a name="//apple_ref/cpp/func/skimage.feature.corner_foerstner"></a>
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_foerstner</tt><big>(</big><em>image</em>, <em>sigma=1</em><big>)</big><a class="headerlink" href="#skimage.feature.corner_foerstner" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Foerstner corner measure response image.</p>
<p>This corner detector uses information from the auto-correlation matrix A:</p>
<div class="highlight-python"><pre>A = [(imx**2)   (imx*imy)] = [Axx Axy]
    [(imx*imy)   (imy**2)]   [Axy Ayy]</pre>
</div>
<p>Where imx and imy are the first derivatives averaged with a gaussian filter.
The corner measure is then defined as:</p>
<div class="highlight-python"><pre>w = det(A) / trace(A)           (size of error ellipse)
q = 4 * det(A) / trace(A)**2    (roundness of error ellipse)</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote>
<div><p>Standard deviation used for the Gaussian kernel, which is used as
weighting function for the auto-correlation matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>w</strong> : ndarray</p>
<blockquote>
<div><p>Error ellipse sizes.</p>
</div></blockquote>
<p><strong>q</strong> : ndarray</p>
<blockquote class="last">
<div><p>Roundness of error ellipse.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r99" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[R99]</a></td><td><a class="reference external" href="http://www.ipb.uni-bonn.de/uploads/tx_ikgpublication/foerstner87.fast.pdf">http://www.ipb.uni-bonn.de/uploads/tx_ikgpublication/foerstner87.fast.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r100" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[R100]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Corner_detection">http://en.wikipedia.org/wiki/Corner_detection</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">corner_foerstner</span><span class="p">,</span> <span class="n">corner_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span>
<span class="go">array([[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],</span>
<span class="go">       [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],</span>
<span class="go">       [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">corner_foerstner</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">accuracy_thresh</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roundness_thresh</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foerstner</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;</span> <span class="n">roundness_thresh</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="n">accuracy_thresh</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">foerstner</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 7],</span>
<span class="go">       [7, 2],</span>
<span class="go">       [7, 7]])</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="corner-harris">
<h2>corner_harris<a class="headerlink" href="#corner-harris" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_harris"><a name="//apple_ref/cpp/func/skimage.feature.corner_harris"></a>
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_harris</tt><big>(</big><em>image</em>, <em>method='k'</em>, <em>k=0.05</em>, <em>eps=1e-06</em>, <em>sigma=1</em><big>)</big><a class="headerlink" href="#skimage.feature.corner_harris" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Harris corner measure response image.</p>
<p>This corner detector uses information from the auto-correlation matrix A:</p>
<div class="highlight-python"><pre>A = [(imx**2)   (imx*imy)] = [Axx Axy]
    [(imx*imy)   (imy**2)]   [Axy Ayy]</pre>
</div>
<p>Where imx and imy are the first derivatives averaged with a gaussian filter.
The corner measure is then defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span> <span class="o">*</span> <span class="n">trace</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">2</span> <span class="o">*</span> <span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">trace</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>method</strong> : {‘k’, ‘eps’}, optional</p>
<blockquote>
<div><p>Method to compute the response image from the auto-correlation matrix.</p>
</div></blockquote>
<p><strong>k</strong> : float, optional</p>
<blockquote>
<div><p>Sensitivity factor to separate corners from edges, typically in range
<cite>[0, 0.2]</cite>. Small values of k result in detection of sharp corners.</p>
</div></blockquote>
<p><strong>eps</strong> : float, optional</p>
<blockquote>
<div><p>Normalisation factor (Noble’s corner measure).</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote>
<div><p>Standard deviation used for the Gaussian kernel, which is used as
weighting function for the auto-correlation matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>response</strong> : ndarray</p>
<blockquote class="last">
<div><p>Harris response image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r101" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[R101]</a></td><td><a class="reference external" href="http://kiwi.cs.dal.ca/~dparks/CornerDetection/harris.htm">http://kiwi.cs.dal.ca/~dparks/CornerDetection/harris.htm</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r102" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[R102]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Corner_detection">http://en.wikipedia.org/wiki/Corner_detection</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">corner_harris</span><span class="p">,</span> <span class="n">corner_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span>
<span class="go">array([[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],</span>
<span class="go">       [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],</span>
<span class="go">       [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">corner_harris</span><span class="p">(</span><span class="n">square</span><span class="p">),</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 7],</span>
<span class="go">       [7, 2],</span>
<span class="go">       [7, 7]])</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="corner-kitchen-rosenfeld">
<h2>corner_kitchen_rosenfeld<a class="headerlink" href="#corner-kitchen-rosenfeld" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_kitchen_rosenfeld"><a name="//apple_ref/cpp/func/skimage.feature.corner_kitchen_rosenfeld"></a>
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_kitchen_rosenfeld</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#skimage.feature.corner_kitchen_rosenfeld" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Kitchen and Rosenfeld corner measure response image.</p>
<p>The corner measure is calculated as follows:</p>
<div class="highlight-python"><pre>:Parameters:</pre>
</div>
<blockquote>
<div><p><strong>image</strong> : ndarray</p>
<blockquote>
<div>Input image.</div></blockquote>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>response</strong> : ndarray</p>
<blockquote class="last">
<div><p>Kitchen and Rosenfeld response image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>
</div>
<div class="section" id="corner-moravec">
<h2>corner_moravec<a class="headerlink" href="#corner-moravec" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_moravec"><a name="//apple_ref/cpp/func/skimage.feature.corner_moravec"></a>
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_moravec</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.feature.corner_moravec" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Moravec corner measure response image.</p>
<p>This is one of the simplest corner detectors and is comparatively fast but
has several limitations (e.g. not rotation invariant).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>window_size</strong> : int, optional (default 1)</p>
<blockquote>
<div><p>Window size.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>response</strong> : ndarray</p>
<blockquote class="last">
<div><p>Moravec response image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>..[1] <a class="reference external" href="http://kiwi.cs.dal.ca/~dparks/CornerDetection/moravec.htm">http://kiwi.cs.dal.ca/~dparks/CornerDetection/moravec.htm</a>
..[2] <a class="reference external" href="http://en.wikipedia.org/wiki/Corner_detection">http://en.wikipedia.org/wiki/Corner_detection</a></p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">moravec</span><span class="p">,</span> <span class="n">peak_local_max</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  1.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moravec</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  1.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  2.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  1.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="corner-peaks">
<h2>corner_peaks<a class="headerlink" href="#corner-peaks" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_peaks"><a name="//apple_ref/cpp/func/skimage.feature.corner_peaks"></a>
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_peaks</tt><big>(</big><em>image</em>, <em>min_distance=10</em>, <em>threshold_abs=0</em>, <em>threshold_rel=0.1</em>, <em>exclude_border=True</em>, <em>indices=True</em>, <em>num_peaks=inf</em>, <em>footprint=None</em>, <em>labels=None</em><big>)</big><a class="headerlink" href="#skimage.feature.corner_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Find corners in corner measure response image.</p>
<p>This differs from <cite>skimage.feature.peak_local_max</cite> in that it suppresses
multiple connected peaks with the same accumulator value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><strong>See `skimage.feature.peak_local_max`.</strong> :</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><strong>See `skimage.feature.peak_local_max`.</strong> :</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">peak_local_max</span><span class="p">,</span> <span class="n">corner_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 2],</span>
<span class="go">       [3, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">array([[2, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 2],</span>
<span class="go">       [3, 3]])</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="corner-shi-tomasi">
<h2>corner_shi_tomasi<a class="headerlink" href="#corner-shi-tomasi" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_shi_tomasi"><a name="//apple_ref/cpp/func/skimage.feature.corner_shi_tomasi"></a>
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_shi_tomasi</tt><big>(</big><em>image</em>, <em>sigma=1</em><big>)</big><a class="headerlink" href="#skimage.feature.corner_shi_tomasi" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Shi-Tomasi (Kanade-Tomasi) corner measure response image.</p>
<p>This corner detector uses information from the auto-correlation matrix A:</p>
<div class="highlight-python"><pre>A = [(imx**2)   (imx*imy)] = [Axx Axy]
    [(imx*imy)   (imy**2)]   [Axy Ayy]</pre>
</div>
<p>Where imx and imy are the first derivatives averaged with a gaussian filter.
The corner measure is then defined as the smaller eigenvalue of A:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">((</span><span class="n">Axx</span> <span class="o">+</span> <span class="n">Ayy</span><span class="p">)</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">Axx</span> <span class="o">-</span> <span class="n">Ayy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">Axy</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote>
<div><p>Standard deviation used for the Gaussian kernel, which is used as
weighting function for the auto-correlation matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>response</strong> : ndarray</p>
<blockquote class="last">
<div><p>Shi-Tomasi response image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r103" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[R103]</a></td><td><a class="reference external" href="http://kiwi.cs.dal.ca/~dparks/CornerDetection/harris.htm">http://kiwi.cs.dal.ca/~dparks/CornerDetection/harris.htm</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r104" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[R104]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Corner_detection">http://en.wikipedia.org/wiki/Corner_detection</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">corner_shi_tomasi</span><span class="p">,</span> <span class="n">corner_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span>
<span class="go">array([[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],</span>
<span class="go">       [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  1,  1,  1,  1,  1,  1,  0,  0],</span>
<span class="go">       [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],</span>
<span class="go">       [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">corner_shi_tomasi</span><span class="p">(</span><span class="n">square</span><span class="p">),</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 7],</span>
<span class="go">       [7, 2],</span>
<span class="go">       [7, 7]])</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="corner-subpix">
<h2>corner_subpix<a class="headerlink" href="#corner-subpix" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_subpix"><a name="//apple_ref/cpp/func/skimage.feature.corner_subpix"></a>
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_subpix</tt><big>(</big><em>image</em>, <em>corners</em>, <em>window_size=11</em>, <em>alpha=0.99</em><big>)</big><a class="headerlink" href="#skimage.feature.corner_subpix" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine subpixel position of corners.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>corners</strong> : (N, 2) ndarray</p>
<blockquote>
<div><p>Corner coordinates <cite>(row, col)</cite>.</p>
</div></blockquote>
<p><strong>window_size</strong> : int, optional</p>
<blockquote>
<div><p>Search window size for subpixel estimation.</p>
</div></blockquote>
<p><strong>alpha</strong> : float, optional</p>
<blockquote>
<div><p>Significance level for point classification.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>positions</strong> : (N, 2) ndarray</p>
<blockquote class="last">
<div><p>Subpixel corner positions. NaN for “not classified” corners.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r105" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[R105]</a></td><td><a class="reference external" href="http://www.ipb.uni-bonn.de/uploads/tx_ikgpublication/">http://www.ipb.uni-bonn.de/uploads/tx_ikgpublication/</a>           foerstner87.fast.pdf</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r106" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[R106]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Corner_detection">http://en.wikipedia.org/wiki/Corner_detection</a></td></tr>
</tbody>
</table>
</dd></dl>
</div>
<div class="section" id="daisy">
<h2>daisy<a class="headerlink" href="#daisy" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.daisy"><a name="//apple_ref/cpp/func/skimage.feature.daisy"></a>
<tt class="descclassname">skimage.feature.</tt><tt class="descname">daisy</tt><big>(</big><em>img</em>, <em>step=4</em>, <em>radius=15</em>, <em>rings=3</em>, <em>histograms=8</em>, <em>orientations=8</em>, <em>normalization='l1'</em>, <em>sigmas=None</em>, <em>ring_radii=None</em>, <em>visualize=False</em><big>)</big><a class="headerlink" href="#skimage.feature.daisy" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract DAISY feature descriptors densely for the given image.</p>
<p>DAISY is a feature descriptor similar to SIFT formulated in a way that
allows for fast dense extraction. Typically, this is practical for
bag-of-features image representations.</p>
<p>The implementation follows Tola et al. <a class="reference internal" href="#r107">[R107]</a> but deviate on the following
points:</p>
<blockquote>
<div><ul class="simple">
<li>Histogram bin contribution are smoothed with a circular Gaussian
window over the tonal range (the angular range).</li>
<li>The sigma values of the spatial Gaussian smoothing in this code do not
match the sigma values in the original code by Tola et al. <a class="reference internal" href="#r108">[R108]</a>. In
their code, spatial smoothing is applied to both the input image and
the center histogram. However, this smoothing is not documented in <a class="reference internal" href="#r107">[R107]</a>
and, therefore, it is omitted.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>img</strong> : (M, N) array</p>
<blockquote>
<div><p>Input image (greyscale).</p>
</div></blockquote>
<p><strong>step</strong> : int, optional</p>
<blockquote>
<div><p>Distance between descriptor sampling points.</p>
</div></blockquote>
<p><strong>radius</strong> : int, optional</p>
<blockquote>
<div><p>Radius (in pixels) of the outermost ring.</p>
</div></blockquote>
<p><strong>rings</strong> : int, optional</p>
<blockquote>
<div><p>Number of rings.</p>
</div></blockquote>
<p><strong>histograms</strong> : int, optional</p>
<blockquote>
<div><p>Number of histograms sampled per ring.</p>
</div></blockquote>
<p><strong>orientations</strong> : int, optional</p>
<blockquote>
<div><p>Number of orientations (bins) per histogram.</p>
</div></blockquote>
<p><strong>normalization</strong> : [ ‘l1’ | ‘l2’ | ‘daisy’ | ‘off’ ], optional</p>
<blockquote>
<div><p>How to normalize the descriptors</p>
<blockquote>
<div><ul class="simple">
<li>‘l1’: L1-normalization of each descriptor.</li>
<li>‘l2’: L2-normalization of each descriptor.</li>
<li>‘daisy’: L2-normalization of individual histograms.</li>
<li>‘off’: Disable normalization.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>sigmas</strong> : 1D array of float, optional</p>
<blockquote>
<div><p>Standard deviation of spatial Gaussian smoothing for the center
histogram and for each ring of histograms. The array of sigmas should
be sorted from the center and out. I.e. the first sigma value defines
the spatial smoothing of the center histogram and the last sigma value
defines the spatial smoothing of the outermost ring. Specifying sigmas
overrides the following parameter.</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">rings</span> <span class="pre">=</span> <span class="pre">len(sigmas)</span> <span class="pre">-</span> <span class="pre">1</span></tt></p>
</div></blockquote>
</div></blockquote>
<p><strong>ring_radii</strong> : 1D array of int, optional</p>
<blockquote>
<div><p>Radius (in pixels) for each ring. Specifying ring_radii overrides the
following two parameters.</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">rings</span> <span class="pre">=</span> <span class="pre">len(ring_radii)</span></tt>
<tt class="docutils literal"><span class="pre">radius</span> <span class="pre">=</span> <span class="pre">ring_radii[-1]</span></tt></p>
</div></blockquote>
<p>If both sigmas and ring_radii are given, they must satisfy the
following predicate since no radius is needed for the center
histogram.</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">len(ring_radii)</span> <span class="pre">==</span> <span class="pre">len(sigmas)</span> <span class="pre">+</span> <span class="pre">1</span></tt></p>
</div></blockquote>
</div></blockquote>
<p><strong>visualize</strong> : bool, optional</p>
<blockquote>
<div><p>Generate a visualization of the DAISY descriptors</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>descs</strong> : array</p>
<blockquote>
<div><p>Grid of DAISY descriptors for the given image as an array
dimensionality  (P, Q, R) where</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">ceil((M</span> <span class="pre">-</span> <span class="pre">radius*2)</span> <span class="pre">/</span> <span class="pre">step)</span></tt>
<tt class="docutils literal"><span class="pre">Q</span> <span class="pre">=</span> <span class="pre">ceil((N</span> <span class="pre">-</span> <span class="pre">radius*2)</span> <span class="pre">/</span> <span class="pre">step)</span></tt>
<tt class="docutils literal"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">(rings</span> <span class="pre">*</span> <span class="pre">histograms</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">orientations</span></tt></p>
</div></blockquote>
</div></blockquote>
<p><strong>descs_img</strong> : (M, N, 3) array (only if visualize==True)</p>
<blockquote class="last">
<div><p>Visualization of the DAISY descriptors.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r107" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label">[R107]</td><td><em>(<a class="fn-backref" href="#id9">1</a>, <a class="fn-backref" href="#id11">2</a>, <a class="fn-backref" href="#id12">3</a>)</em> Tola et al. “Daisy: An efficient dense descriptor applied to wide-
baseline stereo.” Pattern Analysis and Machine Intelligence, IEEE
Transactions on 32.5 (2010): 815-830.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r108" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label">[R108]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id13">2</a>)</em> <a class="reference external" href="http://cvlab.epfl.ch/alumni/tola/daisy.html">http://cvlab.epfl.ch/alumni/tola/daisy.html</a></td></tr>
</tbody>
</table>
</dd></dl>
</div>
<div class="section" id="greycomatrix">
<h2>greycomatrix<a class="headerlink" href="#greycomatrix" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.greycomatrix"><a name="//apple_ref/cpp/func/skimage.feature.greycomatrix"></a>
<tt class="descclassname">skimage.feature.</tt><tt class="descname">greycomatrix</tt><big>(</big><em>image</em>, <em>distances</em>, <em>angles</em>, <em>levels=256</em>, <em>symmetric=False</em>, <em>normed=False</em><big>)</big><a class="headerlink" href="#skimage.feature.greycomatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the grey-level co-occurrence matrix.</p>
<p>A grey level co-occurence matrix is a histogram of co-occuring
greyscale values at a given offset over an image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : array_like of uint8</p>
<blockquote>
<div><p>Integer typed input image. The image will be cast to uint8, so
the maximum value must be less than 256.</p>
</div></blockquote>
<p><strong>distances</strong> : array_like</p>
<blockquote>
<div><p>List of pixel pair distance offsets.</p>
</div></blockquote>
<p><strong>angles</strong> : array_like</p>
<blockquote>
<div><p>List of pixel pair angles in radians.</p>
</div></blockquote>
<p><strong>levels</strong> : int, optional</p>
<blockquote>
<div><p>The input image should contain integers in [0, levels-1],
where levels indicate the number of grey-levels counted
(typically 256 for an 8-bit image). The maximum value is
256.</p>
</div></blockquote>
<p><strong>symmetric</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the output matrix <cite>P[:, :, d, theta]</cite> is symmetric. This
is accomplished by ignoring the order of value pairs, so both
(i, j) and (j, i) are accumulated when (i, j) is encountered
for a given offset. The default is False.</p>
</div></blockquote>
<p><strong>normed</strong> : bool, optional</p>
<blockquote>
<div><p>If True, normalize each matrix <cite>P[:, :, d, theta]</cite> by dividing
by the total number of accumulated co-occurrences for the given
offset. The elements of the resulting matrix sum to 1. The
default is False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>P</strong> : 4-D ndarray</p>
<blockquote class="last">
<div><p>The grey-level co-occurrence histogram. The value
<cite>P[i,j,d,theta]</cite> is the number of times that grey-level <cite>j</cite>
occurs at a distance <cite>d</cite> and at an angle <cite>theta</cite> from
grey-level <cite>i</cite>. If <cite>normed</cite> is <cite>False</cite>, the output is of
type uint32, otherwise it is float64.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r109" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[R109]</a></td><td>The GLCM Tutorial Home Page,
<a class="reference external" href="http://www.fp.ucalgary.ca/mhallbey/tutorial.htm">http://www.fp.ucalgary.ca/mhallbey/tutorial.htm</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r110" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[R110]</a></td><td>Pattern Recognition Engineering, Morton Nadler &amp; Eric P.
Smith</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r111" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[R111]</a></td><td>Wikipedia, <a class="reference external" href="http://en.wikipedia.org/wiki/Co-occurrence_matrix">http://en.wikipedia.org/wiki/Co-occurrence_matrix</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Compute 2 GLCMs: One for a 1-pixel offset to the right, and one
for a 1-pixel offset upwards.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">greycomatrix</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="n">levels</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[2, 2, 1, 0],</span>
<span class="go">       [0, 2, 0, 0],</span>
<span class="go">       [0, 0, 3, 1],</span>
<span class="go">       [0, 0, 0, 1]], dtype=uint32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">array([[3, 0, 2, 0],</span>
<span class="go">       [0, 2, 2, 0],</span>
<span class="go">       [0, 0, 1, 2],</span>
<span class="go">       [0, 0, 0, 0]], dtype=uint32)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="greycoprops">
<h2>greycoprops<a class="headerlink" href="#greycoprops" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.greycoprops"><a name="//apple_ref/cpp/func/skimage.feature.greycoprops"></a>
<tt class="descclassname">skimage.feature.</tt><tt class="descname">greycoprops</tt><big>(</big><em>P</em>, <em>prop='contrast'</em><big>)</big><a class="headerlink" href="#skimage.feature.greycoprops" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate texture properties of a GLCM.</p>
<p>Compute a feature of a grey level co-occurrence matrix to serve as
a compact summary of the matrix. The properties are computed as
follows:</p>
<ul>
<li><p class="first">‘contrast’: <img alt="\sum_{i,j=0}^{levels-1} P_{i,j}(i-j)^2" class="math" src="../_images/math/205d8f8904b8573f58a249e5ea632c4c25443359.png"/></p>
</li>
<li><p class="first">‘dissimilarity’: <img alt="\sum_{i,j=0}^{levels-1}P_{i,j}|i-j|" class="math" src="../_images/math/9b4b5740ddf6c9266b62ece671c15d797f397fc0.png"/></p>
</li>
<li><p class="first">‘homogeneity’: <img alt="\sum_{i,j=0}^{levels-1}\frac{P_{i,j}}{1+(i-j)^2}" class="math" src="../_images/math/59369a5976101a0d3136b6a9462bf2250e8d9cf0.png"/></p>
</li>
<li><p class="first">‘ASM’: <img alt="\sum_{i,j=0}^{levels-1} P_{i,j}^2" class="math" src="../_images/math/67b319e5a321f56099306cb0e92a3f838487daab.png"/></p>
</li>
<li><p class="first">‘energy’: <img alt="\sqrt{ASM}" class="math" src="../_images/math/95cdb2c1be1f3d664e0d0d8fe0a56db6053909e7.png"/></p>
</li>
<li><dl class="first docutils">
<dt>‘correlation’:</dt>
<dd><div class="first last math">
<p><img alt="\sum_{i,j=0}^{levels-1} P_{i,j}\left[\frac{(i-\mu_i) \
(j-\mu_j)}{\sqrt{(\sigma_i^2)(\sigma_j^2)}}\right]" src="../_images/math/c649a0ee8056e19b6bb96959c6590078b369a2e5.png"/></p>
</div></dd>
</dl>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>P</strong> : ndarray</p>
<blockquote>
<div><p>Input array. <cite>P</cite> is the grey-level co-occurrence histogram
for which to compute the specified property. The value
<cite>P[i,j,d,theta]</cite> is the number of times that grey-level j
occurs at a distance d and at an angle theta from
grey-level i.</p>
</div></blockquote>
<p><strong>prop</strong> : {‘contrast’, ‘dissimilarity’, ‘homogeneity’, ‘energy’,             ‘correlation’, ‘ASM’}, optional</p>
<blockquote>
<div><p>The property of the GLCM to compute. The default is ‘contrast’.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>results</strong> : 2-D ndarray</p>
<blockquote class="last">
<div><p>2-dimensional array. <cite>results[d, a]</cite> is the property ‘prop’ for
the d’th distance and the a’th angle.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r112" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[R112]</a></td><td>The GLCM Tutorial Home Page,
<a class="reference external" href="http://www.fp.ucalgary.ca/mhallbey/tutorial.htm">http://www.fp.ucalgary.ca/mhallbey/tutorial.htm</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Compute the contrast for GLCMs with distances [1, 2] and angles
[0 degrees, 90 degrees]</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">greycomatrix</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="n">levels</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
<span class="gp">... </span>                 <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">contrast</span> <span class="o">=</span> <span class="n">greycoprops</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s">'contrast'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">contrast</span>
<span class="go">array([[ 0.58333333,  1.        ],</span>
<span class="go">       [ 1.25      ,  2.75      ]])</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="hog">
<h2>hog<a class="headerlink" href="#hog" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.hog"><a name="//apple_ref/cpp/func/skimage.feature.hog"></a>
<tt class="descclassname">skimage.feature.</tt><tt class="descname">hog</tt><big>(</big><em>image</em>, <em>orientations=9</em>, <em>pixels_per_cell=(8</em>, <em>8)</em>, <em>cells_per_block=(3</em>, <em>3)</em>, <em>visualise=False</em>, <em>normalise=False</em><big>)</big><a class="headerlink" href="#skimage.feature.hog" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract Histogram of Oriented Gradients (HOG) for a given image.</p>
<p>Compute a Histogram of Oriented Gradients (HOG) by</p>
<blockquote>
<div><ol class="arabic simple">
<li>(optional) global image normalisation</li>
<li>computing the gradient image in x and y</li>
<li>computing gradient histograms</li>
<li>normalising across blocks</li>
<li>flattening into a feature vector</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : (M, N) ndarray</p>
<blockquote>
<div><p>Input image (greyscale).</p>
</div></blockquote>
<p><strong>orientations</strong> : int</p>
<blockquote>
<div><p>Number of orientation bins.</p>
</div></blockquote>
<p><strong>pixels_per_cell</strong> : 2 tuple (int, int)</p>
<blockquote>
<div><p>Size (in pixels) of a cell.</p>
</div></blockquote>
<p><strong>cells_per_block</strong> : 2 tuple (int,int)</p>
<blockquote>
<div><p>Number of cells in each block.</p>
</div></blockquote>
<p><strong>visualise</strong> : bool, optional</p>
<blockquote>
<div><p>Also return an image of the HOG.</p>
</div></blockquote>
<p><strong>normalise</strong> : bool, optional</p>
<blockquote>
<div><p>Apply power law compression to normalise the image before
processing.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>newarr</strong> : ndarray</p>
<blockquote>
<div><p>HOG for the image as a 1D (flattened) array.</p>
</div></blockquote>
<p><strong>hog_image</strong> : ndarray (if visualise=True)</p>
<blockquote class="last">
<div><p>A visualisation of the HOG image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Histogram_of_oriented_gradients">http://en.wikipedia.org/wiki/Histogram_of_oriented_gradients</a></li>
<li>Dalal, N and Triggs, B, Histograms of Oriented Gradients for
Human Detection, IEEE Computer Society Conference on Computer
Vision and Pattern Recognition 2005 San Diego, CA, USA</li>
</ul>
</dd></dl>
</div>
<div class="section" id="local-binary-pattern">
<h2>local_binary_pattern<a class="headerlink" href="#local-binary-pattern" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.local_binary_pattern"><a name="//apple_ref/cpp/func/skimage.feature.local_binary_pattern"></a>
<tt class="descclassname">skimage.feature.</tt><tt class="descname">local_binary_pattern</tt><big>(</big><em>image</em>, <em>P</em>, <em>R</em>, <em>method='default'</em><big>)</big><a class="headerlink" href="#skimage.feature.local_binary_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Gray scale and rotation invariant LBP (Local Binary Patterns).</p>
<p>LBP is an invariant descriptor that can be used for texture classification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : (N, M) array</p>
<blockquote>
<div><p>Graylevel image.</p>
</div></blockquote>
<p><strong>P</strong> : int</p>
<blockquote>
<div><p>Number of circularly symmetric neighbour set points (quantization of
the angular space).</p>
</div></blockquote>
<p><strong>R</strong> : float</p>
<blockquote>
<div><p>Radius of circle (spatial resolution of the operator).</p>
</div></blockquote>
<p><strong>method</strong> : {‘default’, ‘ror’, ‘uniform’, ‘var’}</p>
<blockquote>
<div><p>Method to determine the pattern.</p>
<ul>
<li><dl class="first docutils">
<dt>‘default’: original local binary pattern which is gray scale but not</dt>
<dd><p class="first last">rotation invariant.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>‘ror’: extension of default implementation which is gray scale and</dt>
<dd><p class="first last">rotation invariant.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>‘uniform’: improved rotation invariance with uniform patterns and</dt>
<dd><p class="first last">finer quantization of the angular space which is gray scale and
rotation invariant.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>‘nri_uniform’: non rotation-invariant uniform patterns variant</dt>
<dd><p class="first last">which is only gray scale invariant [2].</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>‘var’: rotation invariant variance measures of the contrast of local</dt>
<dd><p class="first last">image texture which is rotation but not gray scale invariant.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>output</strong> : (N, M) array</p>
<blockquote class="last">
<div><p>LBP image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r113" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[R113]</a></td><td>Multiresolution Gray-Scale and Rotation Invariant Texture
Classification with Local Binary Patterns.
Timo Ojala, Matti Pietikainen, Topi Maenpaa.
<a class="reference external" href="http://www.rafbis.it/biplab15/images/stories/docenti/Danielriccio/">http://www.rafbis.it/biplab15/images/stories/docenti/Danielriccio/</a>           Articoliriferimento/LBP.pdf, 2002.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r114" rules="none">
<colgroup><col class="label"></col><col></col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[R114]</a></td><td>Face recognition with local binary patterns.
Timo Ahonen, Abdenour Hadid, Matti Pietikainen,
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.214.6851">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.214.6851</a>,
2004.</td></tr>
</tbody>
</table>
</dd></dl>
</div>
<div class="section" id="match-template">
<h2>match_template<a class="headerlink" href="#match-template" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.match_template"><a name="//apple_ref/cpp/func/skimage.feature.match_template"></a>
<tt class="descclassname">skimage.feature.</tt><tt class="descname">match_template</tt><big>(</big><em>image</em>, <em>template</em>, <em>pad_input=False</em><big>)</big><a class="headerlink" href="#skimage.feature.match_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Match a template to an image using normalized correlation.</p>
<p>The output is an array with values between -1.0 and 1.0, which correspond
to the probability that the template is found at that position.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : array_like</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>template</strong> : array_like</p>
<blockquote>
<div><p>Template to locate.</p>
</div></blockquote>
<p><strong>pad_input</strong> : bool</p>
<blockquote>
<div><p>If True, pad <cite>image</cite> with image mean so that output is the same size as
the image, and output values correspond to the template center.
Otherwise, the output is an array with shape <cite>(M - m + 1, N - n + 1)</cite>
for an <cite>(M, N)</cite> image and an <cite>(m, n)</cite> template, and matches correspond
to origin (top-left corner) of the template.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>output</strong> : ndarray</p>
<blockquote class="last">
<div><p>Correlation results between -1.0 and 1.0. For an <cite>(M, N)</cite> image and an
<cite>(m, n)</cite> template, the <cite>output</cite> is <cite>(M - m + 1, N - n + 1)</cite> when
<cite>pad_input = False</cite> and <cite>(M, N)</cite> when <cite>pad_input = True</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">template</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
<span class="go">[[ 0.  0.  0.]</span>
<span class="go"> [ 0.  1.  0.]</span>
<span class="go"> [ 0.  0.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">[[ 0.  0.  0.  0.  0.  0.]</span>
<span class="go"> [ 0.  1.  0.  0.  0.  0.]</span>
<span class="go"> [ 0.  0.  0.  0.  0.  0.]</span>
<span class="go"> [ 0.  0.  0.  0.  0.  0.]</span>
<span class="go"> [ 0.  0.  0.  0. -1.  0.]</span>
<span class="go"> [ 0.  0.  0.  0.  0.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">match_template</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">[[ 1.    -0.125  0.     0.   ]</span>
<span class="go"> [-0.125 -0.125  0.     0.   ]</span>
<span class="go"> [ 0.     0.     0.125  0.125]</span>
<span class="go"> [ 0.     0.     0.125 -1.   ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">match_template</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">pad_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">[[-0.125 -0.125 -0.125  0.     0.     0.   ]</span>
<span class="go"> [-0.125  1.    -0.125  0.     0.     0.   ]</span>
<span class="go"> [-0.125 -0.125 -0.125  0.     0.     0.   ]</span>
<span class="go"> [ 0.     0.     0.     0.125  0.125  0.125]</span>
<span class="go"> [ 0.     0.     0.     0.125 -1.     0.125]</span>
<span class="go"> [ 0.     0.     0.     0.125  0.125  0.125]]</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="peak-local-max">
<h2>peak_local_max<a class="headerlink" href="#peak-local-max" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.peak_local_max"><a name="//apple_ref/cpp/func/skimage.feature.peak_local_max"></a>
<tt class="descclassname">skimage.feature.</tt><tt class="descname">peak_local_max</tt><big>(</big><em>image</em>, <em>min_distance=10</em>, <em>threshold_abs=0</em>, <em>threshold_rel=0.1</em>, <em>exclude_border=True</em>, <em>indices=True</em>, <em>num_peaks=inf</em>, <em>footprint=None</em>, <em>labels=None</em><big>)</big><a class="headerlink" href="#skimage.feature.peak_local_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Find peaks in an image, and return them as coordinates or a boolean array.</p>
<p>Peaks are the local maxima in a region of <cite>2 * min_distance + 1</cite>
(i.e. peaks are separated by at least <cite>min_distance</cite>).</p>
<p>NOTE: If peaks are flat (i.e. multiple adjacent pixels have identical
intensities), the coordinates of all such pixels are returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray of floats</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>min_distance</strong> : int</p>
<blockquote>
<div><p>Minimum number of pixels separating peaks in a region of <cite>2 *
min_distance + 1</cite> (i.e. peaks are separated by at least
<cite>min_distance</cite>). If <cite>exclude_border</cite> is True, this value also excludes
a border <cite>min_distance</cite> from the image boundary.
To find the maximum number of peaks, use <cite>min_distance=1</cite>.</p>
</div></blockquote>
<p><strong>threshold_abs</strong> : float</p>
<blockquote>
<div><p>Minimum intensity of peaks.</p>
</div></blockquote>
<p><strong>threshold_rel</strong> : float</p>
<blockquote>
<div><p>Minimum intensity of peaks calculated as <cite>max(image) * threshold_rel</cite>.</p>
</div></blockquote>
<p><strong>exclude_border</strong> : bool</p>
<blockquote>
<div><p>If True, <cite>min_distance</cite> excludes peaks from the border of the image as
well as from each other.</p>
</div></blockquote>
<p><strong>indices</strong> : bool</p>
<blockquote>
<div><p>If True, the output will be an array representing peak coordinates.
If False, the output will be a boolean array shaped as <cite>image.shape</cite>
with peaks present at True elements.</p>
</div></blockquote>
<p><strong>num_peaks</strong> : int</p>
<blockquote>
<div><p>Maximum number of peaks. When the number of peaks exceeds <cite>num_peaks</cite>,
return <cite>num_peaks</cite> peaks based on highest peak intensity.</p>
</div></blockquote>
<p><strong>footprint</strong> : ndarray of bools, optional</p>
<blockquote>
<div><p>If provided, <cite>footprint == 1</cite> represents the local region within which
to search for peaks at every point in <cite>image</cite>.  Overrides
<cite>min_distance</cite>, except for border exclusion if <cite>exclude_border=True</cite>.</p>
</div></blockquote>
<p><strong>labels</strong> : ndarray of ints, optional</p>
<blockquote>
<div><p>If provided, each unique region <cite>labels == value</cite> represents a unique
region to search for peaks. Zero is reserved for background.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>output</strong> : (N, 2) array or ndarray of bools</p>
<blockquote class="last">
<div><ul class="simple">
<li>If <cite>indices = True</cite>  : (row, column) coordinates of peaks.</li>
<li>If <cite>indices = False</cite> : Boolean array shaped like <cite>image</cite>, with peaks
represented by True values.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The peak local maximum function returns the coordinates of local peaks
(maxima) in a image. A maximum filter is used for finding local maxima.
This operation dilates the original image. After comparison between
dilated and original image, peak_local_max function returns the
coordinates of peaks where dilated image = original.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span>
<span class="go">array([[ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ],</span>
<span class="go">       [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ],</span>
<span class="go">       [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ],</span>
<span class="go">       [ 0. ,  0. ,  1.5,  0. ,  1. ,  0. ,  0. ],</span>
<span class="go">       [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ],</span>
<span class="go">       [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ],</span>
<span class="go">       [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[3, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[3, 2]])</span>
</pre></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="span3"><h4 class="sidebar-box-heading">Navigation</h4>
<div class="well sidebar-box">
<ul class="nav nav-list">
<li><a href="../index.html">Documentation Home</a></li>
</ul>
</div>
<h4 class="sidebar-box-heading">Contents</h4>
<div class="well sidebar-box toc">
<ul class="nav nav-list">
<li><a class="reference internal" href="#">Module: <tt class="docutils literal"><span class="pre">feature</span></tt></a><ul class="nav nav-list">
<li><a class="reference internal" href="#corner-foerstner">corner_foerstner</a></li>
<li><a class="reference internal" href="#corner-harris">corner_harris</a></li>
<li><a class="reference internal" href="#corner-kitchen-rosenfeld">corner_kitchen_rosenfeld</a></li>
<li><a class="reference internal" href="#corner-moravec">corner_moravec</a></li>
<li><a class="reference internal" href="#corner-peaks">corner_peaks</a></li>
<li><a class="reference internal" href="#corner-shi-tomasi">corner_shi_tomasi</a></li>
<li><a class="reference internal" href="#corner-subpix">corner_subpix</a></li>
<li><a class="reference internal" href="#daisy">daisy</a></li>
<li><a class="reference internal" href="#greycomatrix">greycomatrix</a></li>
<li><a class="reference internal" href="#greycoprops">greycoprops</a></li>
<li><a class="reference internal" href="#hog">hog</a></li>
<li><a class="reference internal" href="#local-binary-pattern">local_binary_pattern</a></li>
<li><a class="reference internal" href="#match-template">match_template</a></li>
<li><a class="reference internal" href="#peak-local-max">peak_local_max</a></li>
</ul>
</li>
</ul>
</div>
<h4 class="sidebar-box-heading">Versions</h4>
<div class="well sidebar-box">
<ul class="nav nav-list">
<script src="../_static/docversions.js"></script>
<script type="text/javascript">
            insert_version_links();
        </script>
</ul>
</div>
</div>
</div>
<div class="well footer">
<small>
            © Copyright the scikit-image development team.
            Created using <a href="http://twitter.github.com/bootstrap/">Bootstrap</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.
        </small>
</div>
</body>
</html>