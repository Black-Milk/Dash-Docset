

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>6.1. Feature extraction &mdash; scikit-learn 0.13.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.13.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="top" title="scikit-learn 0.13.1 documentation" href="../index.html" />
    <link rel="up" title="6. Dataset transformations" href="../data_transforms.html" />
    <link rel="next" title="6.2. Preprocessing data" href="preprocessing.html" />
    <link rel="prev" title="6. Dataset transformations" href="../data_transforms.html" />


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-22606712-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>



  </head>
  <body>

    <div class="header-wrapper">
      <div class="header">
          <p class="logo"><a href="../index.html">
            <img src="../_static/scikit-learn-logo-small.png" alt="Logo"/>
          </a>
          </p><div class="navbar">
          <ul>
            <li><a href="../install.html">Download</a></li>
            <li><a href="../support.html">Support</a></li>
            <li><a href="../user_guide.html">User Guide</a></li>
            <li><a href="../auto_examples/index.html">Examples</a></li>
            <li><a href="classes.html">Reference</a></li>
       </ul>

<div class="search_form">

<div id="cse" style="width: 100%;"></div>
<script src="http://www.google.com/jsapi" type="text/javascript"></script>
<script type="text/javascript">
  google.load('search', '1', {language : 'en'});
  google.setOnLoadCallback(function() {
    var customSearchControl = new google.search.CustomSearchControl('016639176250731907682:tjtqbvtvij0');
    customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
    var options = new google.search.DrawOptions();
    options.setAutoComplete(true);
    customSearchControl.draw('cse', options);
  }, true);
</script>

</div>
          </div> <!-- end navbar --></div>
    </div>

    <div class="content-wrapper">

      <div class="sphinxsidebar">
	<div class="sphinxsidebarwrapper">
	  <div class="rel">
	   
	<!-- rellinks[1:] is an ugly hack to avoid link to module
	    index  -->
	<div class="rellink">
	<a href="../data_transforms.html" title="6. Dataset transformations"
	    accesskey="P">Previous
	    <br>
	    <span class="smallrellink">
	    6. Dataset trans...
	    </span>
	    <span class="hiddenrellink">
	    6. Dataset transformations
	    </span>
	    
	    </a>
	</div>
	    <div class="spacer">
	    &nbsp;
	    </div>
	
	<div class="rellink">
	<a href="preprocessing.html" title="6.2. Preprocessing data"
	    accesskey="N">Next
	    <br>
	    <span class="smallrellink">
	    6.2. Preprocessi...
	    </span>
	    <span class="hiddenrellink">
	    6.2. Preprocessing data
	    </span>
	    
	    </a>
	</div>
	    <div class="spacer">
	    &nbsp;
	    </div>
	
	<div class="rellink">
	<a href="../np-modindex.html" title="Python Module Index"
	    >Modules
	    <br>
	    <span class="smallrellink">
	    Python Module In...
	    </span>
	    <span class="hiddenrellink">
	    Python Module Index
	    </span>
	    
	    </a>
	</div>
	    <div class="spacer">
	    &nbsp;
	    </div>
	
	<div class="rellink">
	<a href="../py-modindex.html" title="Python Module Index"
	    >Modules
	    <br>
	    <span class="smallrellink">
	    Python Module In...
	    </span>
	    <span class="hiddenrellink">
	    Python Module Index
	    </span>
	    
	    </a>
	</div>
	<!-- Ad a link to the 'up' page -->
	<div class="spacer">
	&nbsp;
	</div>
	<div class="rellink">
	<a href="../data_transforms.html" title="6. Dataset transformations" >
	Up
	<br>
	<span class="smallrellink">
	6. Dataset trans...
	</span>
	<span class="hiddenrellink">
	6. Dataset transformations
	</span>
	
	</a>
	</div>
    </div>
    <p style="text-align: center; background-color: #FFE4E4">This documentation is
    for scikit-learn <strong>version 0.13.1</strong>
    &mdash; <a href="http://scikit-learn.org/stable/support.html#documentation-resources">Other versions</a></p>
    
    <h3><a href="../about.html#citing-scikit-learn">Citing</a></h3>
    <p>If you use the software, please consider
    <a href="../about.html#citing-scikit-learn">citing scikit-learn</a>.</p>
    <h3>This page</h3>
	<ul>
<li><a class="reference internal" href="#">6.1. Feature extraction</a><ul>
<li><a class="reference internal" href="#loading-features-from-dicts">6.1.1. Loading features from dicts</a></li>
<li><a class="reference internal" href="#feature-hashing">6.1.2. Feature hashing</a><ul>
<li><a class="reference internal" href="#implementation-details">6.1.2.1. Implementation details</a></li>
</ul>
</li>
<li><a class="reference internal" href="#text-feature-extraction">6.1.3. Text feature extraction</a><ul>
<li><a class="reference internal" href="#the-bag-of-words-representation">6.1.3.1. The Bag of Words representation</a></li>
<li><a class="reference internal" href="#sparsity">6.1.3.2. Sparsity</a></li>
<li><a class="reference internal" href="#common-vectorizer-usage">6.1.3.3. Common Vectorizer usage</a></li>
<li><a class="reference internal" href="#tfidf-term-weighting">6.1.3.4. Tf–idf term weighting</a></li>
<li><a class="reference internal" href="#applications-and-examples">6.1.3.5. Applications and examples</a></li>
<li><a class="reference internal" href="#limitations-of-the-bag-of-words-representation">6.1.3.6. Limitations of the Bag of Words representation</a></li>
<li><a class="reference internal" href="#vectorizing-a-large-text-corpus-with-the-hashing-trick">6.1.3.7. Vectorizing a large text corpus with the hashing trick</a></li>
<li><a class="reference internal" href="#customizing-the-vectorizer-classes">6.1.3.8. Customizing the vectorizer classes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#image-feature-extraction">6.1.4. Image feature extraction</a><ul>
<li><a class="reference internal" href="#patch-extraction">6.1.4.1. Patch extraction</a></li>
<li><a class="reference internal" href="#connectivity-graph-of-an-image">6.1.4.2. Connectivity graph of an image</a></li>
</ul>
</li>
</ul>
</li>
</ul>

    
    </div>
	  </div>


      <div class="content">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="feature-extraction">
<span id="id1"></span><h1>6.1. Feature extraction<a class="headerlink" href="#feature-extraction" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="classes.html#module-sklearn.feature_extraction" title="sklearn.feature_extraction"><tt class="xref py py-mod docutils literal"><span class="pre">sklearn.feature_extraction</span></tt></a> module can be used to extract
features in a format supported by machine learning algorithms from datasets
consisting of formats such as text and image.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Feature extraction is very different from <a class="reference internal" href="feature_selection.html#feature-selection"><em>Feature selection</em></a>:
the former consists in transforming arbitrary data, such as text or
images, into numerical features usable for machine learning. The latter
is a machine learning technique applied on these features.</p>
</div>
<div class="section" id="loading-features-from-dicts">
<span id="dict-feature-extraction"></span><h2>6.1.1. Loading features from dicts<a class="headerlink" href="#loading-features-from-dicts" title="Permalink to this headline">¶</a></h2>
<p>The class <a class="reference internal" href="generated/sklearn.feature_extraction.DictVectorizer.html#sklearn.feature_extraction.DictVectorizer" title="sklearn.feature_extraction.DictVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">DictVectorizer</span></tt></a> can be used to convert feature
arrays represented as lists of standard Python <tt class="docutils literal"><span class="pre">dict</span></tt> objects to the
NumPy/SciPy representation used by scikit-learn estimators.</p>
<p>While not particularly fast to process, Python&#8217;s <tt class="docutils literal"><span class="pre">dict</span></tt> has the
advantages of being convenient to use, being sparse (absent features
need not be stored) and storing feature names in addition to values.</p>
<p><a class="reference internal" href="generated/sklearn.feature_extraction.DictVectorizer.html#sklearn.feature_extraction.DictVectorizer" title="sklearn.feature_extraction.DictVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">DictVectorizer</span></tt></a> implements what is called one-of-K or &#8220;one-hot&#8221;
coding for categorical (aka nominal, discrete) features. Categorical
features are &#8220;attribute-value&#8221; pairs where the value is restricted
to a list of discrete of possibilities without ordering (e.g. topic
identifiers, types of objects, tags, names...).</p>
<p>In the following, &#8220;city&#8221; is a categorical attribute while &#8220;temperature&#8221;
is a traditional numerical feature:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">measurements</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">{</span><span class="s">&#39;city&#39;</span><span class="p">:</span> <span class="s">&#39;Dubai&#39;</span><span class="p">,</span> <span class="s">&#39;temperature&#39;</span><span class="p">:</span> <span class="mf">33.</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">{</span><span class="s">&#39;city&#39;</span><span class="p">:</span> <span class="s">&#39;London&#39;</span><span class="p">,</span> <span class="s">&#39;temperature&#39;</span><span class="p">:</span> <span class="mf">12.</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">{</span><span class="s">&#39;city&#39;</span><span class="p">:</span> <span class="s">&#39;San Fransisco&#39;</span><span class="p">,</span> <span class="s">&#39;temperature&#39;</span><span class="p">:</span> <span class="mf">18.</span><span class="p">},</span>
<span class="gp">... </span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.feature_extraction</span> <span class="kn">import</span> <span class="n">DictVectorizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="n">DictVectorizer</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">measurements</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[  1.,   0.,   0.,  33.],</span>
<span class="go">       [  0.,   1.,   0.,  12.],</span>
<span class="go">       [  0.,   0.,   1.,  18.]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">()</span>
<span class="go">[&#39;city=Dubai&#39;, &#39;city=London&#39;, &#39;city=San Fransisco&#39;, &#39;temperature&#39;]</span>
</pre></div>
</div>
<p><a class="reference internal" href="generated/sklearn.feature_extraction.DictVectorizer.html#sklearn.feature_extraction.DictVectorizer" title="sklearn.feature_extraction.DictVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">DictVectorizer</span></tt></a> is also a useful representation transformation
for training sequence classifiers in Natural Language Processing models
that typically work by extracting feature windows around a particular
word of interest.</p>
<p>For example, suppose that we have a first algorithm that extracts Part of
Speech (PoS) tags that we want to use as complementary tags for training
a sequence classifier (e.g. a chunker). The following dict could be
such a window of features extracted around the word &#8216;sat&#8217; in the sentence
&#8216;The cat sat on the mat.&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pos_window</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">{</span>
<span class="gp">... </span>        <span class="s">&#39;word-2&#39;</span><span class="p">:</span> <span class="s">&#39;the&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s">&#39;pos-2&#39;</span><span class="p">:</span> <span class="s">&#39;DT&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s">&#39;word-1&#39;</span><span class="p">:</span> <span class="s">&#39;cat&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s">&#39;pos-1&#39;</span><span class="p">:</span> <span class="s">&#39;NN&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s">&#39;word+1&#39;</span><span class="p">:</span> <span class="s">&#39;on&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s">&#39;pos+1&#39;</span><span class="p">:</span> <span class="s">&#39;PP&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">},</span>
<span class="gp">... </span>    <span class="c"># in a real application one would extract many such dictionaries</span>
<span class="gp">... </span><span class="p">]</span>
</pre></div>
</div>
<p>This description can be vectorized into a sparse two-dimensional matrix
suitable for feeding into a classifier (maybe after being piped into a
<a class="reference internal" href="generated/sklearn.feature_extraction.text.TfidfTransformer.html#sklearn.feature_extraction.text.TfidfTransformer" title="sklearn.feature_extraction.text.TfidfTransformer"><tt class="xref py py-class docutils literal"><span class="pre">text.TfidfTransformer</span></tt></a> for normalization):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="n">DictVectorizer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos_vectorized</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">pos_window</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos_vectorized</span>                     
<span class="go">&lt;1x6 sparse matrix of type &#39;&lt;type &#39;numpy.float64&#39;&gt;&#39;</span>
<span class="go">    with 6 stored elements in Compressed Sparse Row format&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos_vectorized</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.,  1.,  1.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">()</span>
<span class="go">[&#39;pos+1=PP&#39;, &#39;pos-1=NN&#39;, &#39;pos-2=DT&#39;, &#39;word+1=on&#39;, &#39;word-1=cat&#39;, &#39;word-2=the&#39;]</span>
</pre></div>
</div>
<p>As you can imagine, if one extracts such a context around each individual
word of a corpus of documents the resulting matrix will be very wide
(many one-hot-features) with most of them being valued to zero most
of the time. So as to make the resulting data structure able to fit in
memory the <tt class="docutils literal"><span class="pre">DictVectorizer</span></tt> class uses a <tt class="docutils literal"><span class="pre">scipy.sparse</span></tt> matrix by
default instead of a <tt class="docutils literal"><span class="pre">numpy.ndarray</span></tt>.</p>
</div>
<div class="section" id="feature-hashing">
<span id="id2"></span><h2>6.1.2. Feature hashing<a class="headerlink" href="#feature-hashing" title="Permalink to this headline">¶</a></h2>
<p>The class <a class="reference internal" href="generated/sklearn.feature_extraction.FeatureHasher.html#sklearn.feature_extraction.FeatureHasher" title="sklearn.feature_extraction.FeatureHasher"><tt class="xref py py-class docutils literal"><span class="pre">FeatureHasher</span></tt></a> is a high-speed, low-memory vectorizer that
uses a technique known as
<a class="reference external" href="https://en.wikipedia.org/wiki/Feature_hashing">feature hashing</a>,
or the &#8220;hashing trick&#8221;.
Instead of building a hash table of the features encountered in training,
as the vectorizers do, instances of <a class="reference internal" href="generated/sklearn.feature_extraction.FeatureHasher.html#sklearn.feature_extraction.FeatureHasher" title="sklearn.feature_extraction.FeatureHasher"><tt class="xref py py-class docutils literal"><span class="pre">FeatureHasher</span></tt></a>
apply a hash function to the features
to determine their column index in sample matrices directly.
The result is increased speed and reduced memory usage,
at the expense of inspectability;
the hasher does not remember what the input features looked like
and has no <tt class="docutils literal"><span class="pre">inverse_transform</span></tt> method.</p>
<p>Since the hash function might cause collisions between (unrelated) features,
a signed hash function is used and the sign of the hash value
determines the sign of the value stored in the output matrix for a feature.
This way, collisions are likely to cancel out rather than accumulate error,
and the expected mean of any output feature&#8217;s value is zero.</p>
<p>If <tt class="docutils literal"><span class="pre">non_negative=True</span></tt> is passed to the constructor,
the absolute value is taken.
This undoes some of the collision handling,
but allows the output to be passed to estimators like <tt class="xref py py-class docutils literal"><span class="pre">MultinomialNB</span></tt>
or <tt class="docutils literal"><span class="pre">chi2</span></tt> feature selectors that expect non-negative inputs.</p>
<p><a class="reference internal" href="generated/sklearn.feature_extraction.FeatureHasher.html#sklearn.feature_extraction.FeatureHasher" title="sklearn.feature_extraction.FeatureHasher"><tt class="xref py py-class docutils literal"><span class="pre">FeatureHasher</span></tt></a> accepts either mappings
(like Python&#8217;s <tt class="docutils literal"><span class="pre">dict</span></tt> and its variants in the <tt class="docutils literal"><span class="pre">collections</span></tt> module),
<tt class="docutils literal"><span class="pre">(feature,</span> <span class="pre">value)</span></tt> pairs, or strings,
depending on the constructor parameter <tt class="docutils literal"><span class="pre">input_type</span></tt>.
Mapping are treated as lists of <tt class="docutils literal"><span class="pre">(feature,</span> <span class="pre">value)</span></tt> pairs,
while single strings have an implicit value of 1,
so <tt class="docutils literal"><span class="pre">['feat1',</span> <span class="pre">'feat2',</span> <span class="pre">'feat3']</span></tt> is interpreted as
<tt class="docutils literal"><span class="pre">[('feat1',</span> <span class="pre">1),</span> <span class="pre">('feat2',</span> <span class="pre">1),</span> <span class="pre">('feat3',</span> <span class="pre">1)]</span></tt>.
If a single feature occurs multiple times in a sample,
the associated values will be summed
(so <tt class="docutils literal"><span class="pre">('feat',</span> <span class="pre">2)</span></tt> and <tt class="docutils literal"><span class="pre">('feat',</span> <span class="pre">3.5)</span></tt> become <tt class="docutils literal"><span class="pre">('feat',</span> <span class="pre">5.5)</span></tt>).
The output from <a class="reference internal" href="generated/sklearn.feature_extraction.FeatureHasher.html#sklearn.feature_extraction.FeatureHasher" title="sklearn.feature_extraction.FeatureHasher"><tt class="xref py py-class docutils literal"><span class="pre">FeatureHasher</span></tt></a> is always a <tt class="docutils literal"><span class="pre">scipy.sparse</span></tt> matrix
in the CSR format.</p>
<p>Feature hashing can be employed in document classification,
but unlike <a class="reference internal" href="generated/sklearn.feature_extraction.text.CountVectorizer.html#sklearn.feature_extraction.text.CountVectorizer" title="sklearn.feature_extraction.text.CountVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">text.CountVectorizer</span></tt></a>,
<a class="reference internal" href="generated/sklearn.feature_extraction.FeatureHasher.html#sklearn.feature_extraction.FeatureHasher" title="sklearn.feature_extraction.FeatureHasher"><tt class="xref py py-class docutils literal"><span class="pre">FeatureHasher</span></tt></a> does not do word
splitting or any other preprocessing except Unicode-to-UTF-8 encoding;
see <a class="reference internal" href="#hashing-vectorizer"><em>Vectorizing a large text corpus with the hashing trick</em></a>, below, for a combined tokenizer/hasher.</p>
<p>As an example, consider a word-level natural language processing task
that needs features extracted from <tt class="docutils literal"><span class="pre">(token,</span> <span class="pre">part_of_speech)</span></tt> pairs.
One could use a Python generator function to extract features:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">token_features</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">part_of_speech</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
        <span class="k">yield</span> <span class="s">&quot;numeric&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">yield</span> <span class="s">&quot;token={}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="k">yield</span> <span class="s">&quot;token,pos={},{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">part_of_speech</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">token</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span>
        <span class="k">yield</span> <span class="s">&quot;uppercase_initial&quot;</span>
    <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span>
        <span class="k">yield</span> <span class="s">&quot;all_uppercase&quot;</span>
    <span class="k">yield</span> <span class="s">&quot;pos={}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">part_of_speech</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, the <tt class="docutils literal"><span class="pre">raw_X</span></tt> to be fed to <tt class="docutils literal"><span class="pre">FeatureHasher.transform</span></tt>
can be constructed using:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">raw_X</span> <span class="o">=</span> <span class="p">(</span><span class="n">token_features</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">pos_tagger</span><span class="p">(</span><span class="n">tok</span><span class="p">))</span> <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">corpus</span><span class="p">)</span>
</pre></div>
</div>
<p>and fed to a hasher with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">hasher</span> <span class="o">=</span> <span class="n">FeatureHasher</span><span class="p">(</span><span class="n">input_type</span><span class="o">=</span><span class="n">string</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">hasher</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">raw_X</span><span class="p">)</span>
</pre></div>
</div>
<p>to get a <tt class="docutils literal"><span class="pre">scipy.sparse</span></tt> matrix <tt class="docutils literal"><span class="pre">X</span></tt>.</p>
<p>Note the use of a generator comprehension,
which introduces laziness into the feature extraction:
tokens are only processed on demand from the hasher.</p>
<div class="section" id="implementation-details">
<h3>6.1.2.1. Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.feature_extraction.FeatureHasher.html#sklearn.feature_extraction.FeatureHasher" title="sklearn.feature_extraction.FeatureHasher"><tt class="xref py py-class docutils literal"><span class="pre">FeatureHasher</span></tt></a> uses the signed 32-bit variant of MurmurHash3.
As a result (and because of limitations in <tt class="docutils literal"><span class="pre">scipy.sparse</span></tt>),
the maximum number of features supported is currently <img class="math" src="../_images/math/4827481aa2c0da445faf499be37ad07877db93ec.png" alt="2^{31} - 1"/>.</p>
<p>The original formulation of the hashing trick by Weinberger et al.
used two separate hash functions <img class="math" src="../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/> and <img class="math" src="../_images/math/ccfd1641d037d427d9dbf42cdd54b485a03eafe9.png" alt="\xi"/>
to determine the column index and sign of a feature, respectively.
The present implementation works under the assumption
that the sign bit of MurmurHash3 is independent of its other bits.</p>
<p>Since a simple modulo is used to transform the hash function to a column index,
it is advisable to use a power of two as the <tt class="docutils literal"><span class="pre">n_features</span></tt> parameter;
otherwise the features will not be mapped evenly to the columns.</p>
<div class="topic">
<p class="topic-title first">References:</p>
<ul class="simple">
<li>Kilian Weinberger, Anirban Dasgupta, John Langford, Alex Smola and
Josh Attenberg (2009). <a class="reference external" href="http://alex.smola.org/papers/2009/Weinbergeretal09.pdf">Feature hashing for large scale multitask learning</a>. Proc. ICML.</li>
<li><a class="reference external" href="http://code.google.com/p/smhasher/wiki/MurmurHash3">MurmurHash3</a>.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="text-feature-extraction">
<span id="id4"></span><h2>6.1.3. Text feature extraction<a class="headerlink" href="#text-feature-extraction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-bag-of-words-representation">
<h3>6.1.3.1. The Bag of Words representation<a class="headerlink" href="#the-bag-of-words-representation" title="Permalink to this headline">¶</a></h3>
<p>Text Analysis is a major application field for machine learning
algorithms. However the raw data, a sequence of symbols cannot be fed
directly to the algorithms themselves as most of them expect numerical
feature vectors with a fixed size rather than the raw text documents
with variable length.</p>
<p>In order to address this, scikit-learn provides utilities for the most
common ways to extract numerical features from text content, namely:</p>
<ul class="simple">
<li><strong>tokenizing</strong> strings and giving an integer id for each possible token,
for instance by using whitespaces and punctuation as token separators.</li>
<li><strong>counting</strong> the occurrences of tokens in each document.</li>
<li><strong>normalizing</strong> and weighting with diminishing importance tokens that
occur in the majority of samples / documents.</li>
</ul>
<p>In this scheme, features and samples are defined as follows:</p>
<ul class="simple">
<li>each <strong>individual token occurrence frequency</strong> (normalized or not)
is treated as a <strong>feature</strong>.</li>
<li>the vector of all the token frequencies for a given <strong>document</strong> is
considered a multivariate <strong>sample</strong>.</li>
</ul>
<p>A corpus of documents can thus be represented by a matrix with one row
per document and one column per token (e.g. word) occurring in the corpus.</p>
<p>We call <strong>vectorization</strong> the general process of turning a collection
of text documents into numerical feature vectors. This specific stragegy
(tokenization, counting and normalization) is called the <strong>Bag of Words</strong>
or &#8220;Bag of n-grams&#8221; representation. Documents are described by word
occurrences while completely ignoring the relative position information
of the words in the document.</p>
</div>
<div class="section" id="sparsity">
<h3>6.1.3.2. Sparsity<a class="headerlink" href="#sparsity" title="Permalink to this headline">¶</a></h3>
<p>As most documents will typically use a very subset of a the words used in
the corpus, the resulting matrix will have many feature values that are
zeros (typically more than 99% of them).</p>
<p>For instance a collection of 10,000 short text documents (such as emails)
will use a vocabulary with a size in the order of 100,000 unique words in
total while each document will use 100 to 1000 unique words individually.</p>
<p>In order to be able to store such a matrix in memory but also to speed
up algebraic operations matrix / vector, implementations will typically
use a sparse representation such as the implementations available in the
<tt class="docutils literal"><span class="pre">scipy.sparse</span></tt> package.</p>
</div>
<div class="section" id="common-vectorizer-usage">
<h3>6.1.3.3. Common Vectorizer usage<a class="headerlink" href="#common-vectorizer-usage" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.feature_extraction.text.CountVectorizer.html#sklearn.feature_extraction.text.CountVectorizer" title="sklearn.feature_extraction.text.CountVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">CountVectorizer</span></tt></a> implements both tokenization and occurrence
counting in a single class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">CountVectorizer</span>
</pre></div>
</div>
<p>This model has many parameters, however the default values are quite
reasonable (please see  the <a class="reference internal" href="classes.html#text-feature-extraction-ref"><em>reference documentation</em></a> for the details):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vectorizer</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span><span class="n">min_df</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vectorizer</span>                            
<span class="go">CountVectorizer(analyzer=u&#39;word&#39;, binary=False, charset=u&#39;utf-8&#39;,</span>
<span class="go">        charset_error=u&#39;strict&#39;, dtype=&lt;type &#39;numpy.int64&#39;&gt;,</span>
<span class="go">        input=u&#39;content&#39;, lowercase=True, max_df=1.0, max_features=None,</span>
<span class="go">        min_df=1, ngram_range=(1, 1), preprocessor=None,</span>
<span class="go">        stop_words=None, strip_accents=None,</span>
<span class="go">        token_pattern=u&#39;(?u)\\b\\w\\w+\\b&#39;, tokenizer=None, vocabulary=None)</span>
</pre></div>
</div>
<p>Let&#8217;s use it to tokenize and count the word occurrences of a minimalistic
corpus of text documents:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">corpus</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="s">&#39;This is the first document.&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s">&#39;This is the second second document.&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s">&#39;And the third one.&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s">&#39;Is this the first document?&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>                                       
<span class="go">&lt;4x9 sparse matrix of type &#39;&lt;type &#39;numpy.int64&#39;&gt;&#39;</span>
<span class="go">    with 19 stored elements in Compressed Sparse Column format&gt;</span>
</pre></div>
</div>
<p>The default configuration tokenizes the string by extracting words of
at least 2 letters. The specific function that does this step can be
requested explicitly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">analyze</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">build_analyzer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">analyze</span><span class="p">(</span><span class="s">&quot;This is a text document to analyze.&quot;</span><span class="p">)</span>
<span class="go">[u&#39;this&#39;, u&#39;is&#39;, u&#39;text&#39;, u&#39;document&#39;, u&#39;to&#39;, u&#39;analyze&#39;]</span>
</pre></div>
</div>
<p>Each term found by the analyzer during the fit is assigned a unique
integer index corresponding to a column in the resulting matrix. This
interpretation of the columns can be retrieved as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vectorizer</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">()</span>
<span class="go">[u&#39;and&#39;, u&#39;document&#39;, u&#39;first&#39;, u&#39;is&#39;, u&#39;one&#39;, u&#39;second&#39;, u&#39;the&#39;, u&#39;third&#39;, u&#39;this&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>           
<span class="go">array([[0, 1, 1, 1, 0, 0, 1, 0, 1],</span>
<span class="go">       [0, 1, 0, 1, 0, 2, 1, 0, 1],</span>
<span class="go">       [1, 0, 0, 0, 1, 0, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 0, 0, 1, 0, 1]]...)</span>
</pre></div>
</div>
<p>The converse mapping from feature name to column index is stored in the
<tt class="docutils literal"><span class="pre">vocabulary_</span></tt> attribute of the vectorizer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vectorizer</span><span class="o">.</span><span class="n">vocabulary_</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;document&#39;</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Hence words that were not seen in the training corpus will be completely
ignored in future calls to the transform method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vectorizer</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="s">&#39;Something completely new.&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="gp">... </span>                          
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0]]...)</span>
</pre></div>
</div>
<p>Note that in the previous corpus, the first and the last documents have
exactly the same words hence are encoded in equal vectors. In particular
we lose the information that the last document is an interogative form. To
preserve some of the local ordering information we can extract 2-grams
of words in addition to the 1-grams (the word themselvs):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bigram_vectorizer</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span><span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span>                                    <span class="n">token_pattern</span><span class="o">=</span><span class="s">ur&#39;\b\w+\b&#39;</span><span class="p">,</span> <span class="n">min_df</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">analyze</span> <span class="o">=</span> <span class="n">bigram_vectorizer</span><span class="o">.</span><span class="n">build_analyzer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">analyze</span><span class="p">(</span><span class="s">&#39;Bi-grams are cool!&#39;</span><span class="p">)</span>
<span class="go">[u&#39;bi&#39;, u&#39;grams&#39;, u&#39;are&#39;, u&#39;cool&#39;, u&#39;bi grams&#39;, u&#39;grams are&#39;, u&#39;are cool&#39;]</span>
</pre></div>
</div>
<p>The vocabulary extracted by this vectorizer is hence much bigger and
can now resolve ambiguities encoded in local positioning patterns:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X_2</span> <span class="o">=</span> <span class="n">bigram_vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_2</span>
<span class="gp">... </span>                          
<span class="go">array([[0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0],</span>
<span class="go">       [0, 0, 1, 0, 0, 1, 1, 0, 0, 2, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0],</span>
<span class="go">       [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1]]...)</span>
</pre></div>
</div>
<p>In particular the interogative form &#8220;Is this&#8221; is only present in the
last document:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">feature_index</span> <span class="o">=</span> <span class="n">bigram_vectorizer</span><span class="o">.</span><span class="n">vocabulary_</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">u&#39;is this&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_2</span><span class="p">[:,</span> <span class="n">feature_index</span><span class="p">]</span>     
<span class="go">array([0, 0, 0, 1]...)</span>
</pre></div>
</div>
</div>
<div class="section" id="tfidf-term-weighting">
<span id="tfidf"></span><h3>6.1.3.4. Tf–idf term weighting<a class="headerlink" href="#tfidf-term-weighting" title="Permalink to this headline">¶</a></h3>
<p>In a large text corpus, some words will be very present (e.g. &#8220;the&#8221;, &#8220;a&#8221;,
&#8220;is&#8221; in English) hence carrying very little meaningul information about
the actual contents of the document. If we were to feed the direct count
data directly to a classifier those very frequent terms would shadow
the frequencies of rarer yet more interesting terms.</p>
<p>In order to re-weight the count features into floating point values
suitable for usage by a classifier it is very common to use the tf–idf
transform.</p>
<p>Tf means <strong>term-frequency</strong> while tf–idf means term-frequency times
<strong>inverse document-frequency</strong>. This is a originally a term weighting
scheme developed for information retrieval (as a ranking function
for search engines results), that has also found good use in document
classification and clustering.</p>
<p>This normalization is implemented by the <tt class="xref py py-class docutils literal"><span class="pre">text.TfidfTransformer</span></tt>
class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">TfidfTransformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span> <span class="o">=</span> <span class="n">TfidfTransformer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span>   
<span class="go">TfidfTransformer(norm=u&#39;l2&#39;, smooth_idf=True, sublinear_tf=False,</span>
<span class="go">                 use_idf=True)</span>
</pre></div>
</div>
<p>Again please see the <a class="reference internal" href="classes.html#text-feature-extraction-ref"><em>reference documentation</em></a> for the details on all the parameters.</p>
<p>Let&#8217;s take an example with the following counts. The first term is present
100% of the time hence not very interesting. The two other features only
in less than 50% of the time hence probably more representative of the
content of the documents:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>          <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>          <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>          <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>          <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>          <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tfidf</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tfidf</span>                                  
<span class="go">&lt;6x3 sparse matrix of type &#39;&lt;type &#39;numpy.float64&#39;&gt;&#39;</span>
<span class="go">    with 9 stored elements in Compressed Sparse Row format&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">tfidf</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>                        
<span class="go">array([[ 0.85...,  0.  ...,  0.52...],</span>
<span class="go">       [ 1.  ...,  0.  ...,  0.  ...],</span>
<span class="go">       [ 1.  ...,  0.  ...,  0.  ...],</span>
<span class="go">       [ 1.  ...,  0.  ...,  0.  ...],</span>
<span class="go">       [ 0.55...,  0.83...,  0.  ...],</span>
<span class="go">       [ 0.63...,  0.  ...,  0.77...]])</span>
</pre></div>
</div>
<p>Each row is normalized to have unit euclidean norm. The weights of each
feature computed by the <tt class="docutils literal"><span class="pre">fit</span></tt> method call are stored in a model
attribute:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span><span class="o">.</span><span class="n">idf_</span>                       
<span class="go">array([ 1. ...,  2.25...,  1.84...])</span>
</pre></div>
</div>
<p>As tf–idf is a very often used for text features, there is also another
class called <a class="reference internal" href="generated/sklearn.feature_extraction.text.TfidfVectorizer.html#sklearn.feature_extraction.text.TfidfVectorizer" title="sklearn.feature_extraction.text.TfidfVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">TfidfVectorizer</span></tt></a> that combines all the option of
<a class="reference internal" href="generated/sklearn.feature_extraction.text.CountVectorizer.html#sklearn.feature_extraction.text.CountVectorizer" title="sklearn.feature_extraction.text.CountVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">CountVectorizer</span></tt></a> and <a class="reference internal" href="generated/sklearn.feature_extraction.text.TfidfTransformer.html#sklearn.feature_extraction.text.TfidfTransformer" title="sklearn.feature_extraction.text.TfidfTransformer"><tt class="xref py py-class docutils literal"><span class="pre">TfidfTransformer</span></tt></a> in a single model:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">TfidfVectorizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vectorizer</span> <span class="o">=</span> <span class="n">TfidfVectorizer</span><span class="p">(</span><span class="n">min_df</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>
<span class="gp">... </span>                                      
<span class="go">&lt;4x9 sparse matrix of type &#39;&lt;type &#39;numpy.float64&#39;&gt;&#39;</span>
<span class="go">    with 19 stored elements in Compressed Sparse Row format&gt;</span>
</pre></div>
</div>
<p>While the tf–idf normalization is often very useful, there might
be cases where the binary occurrence markers might offer better
features. This can be achieved by using the <tt class="docutils literal"><span class="pre">binary</span></tt> parameter
of <a class="reference internal" href="generated/sklearn.feature_extraction.text.CountVectorizer.html#sklearn.feature_extraction.text.CountVectorizer" title="sklearn.feature_extraction.text.CountVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">CountVectorizer</span></tt></a>. In particular, some estimators such as
<a class="reference internal" href="naive_bayes.html#bernoulli-naive-bayes"><em>Bernoulli Naive Bayes</em></a> explicitly model discrete boolean random
variables. Also, very short text are likely to have noisy tf–idf values
while the binary occurrence info is more stable.</p>
<p>As usual the only way how to best adjust the feature extraction parameters
is to use a cross-validated grid search, for instance by pipelining the
feature extractor with a classifier:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="../auto_examples/grid_search_text_feature_extraction.html#example-grid-search-text-feature-extraction-py"><em>Sample pipeline for text feature extraction and evaluation</em></a></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="applications-and-examples">
<h3>6.1.3.5. Applications and examples<a class="headerlink" href="#applications-and-examples" title="Permalink to this headline">¶</a></h3>
<p>The bag of words representation is quite simplistic but surprisingly
useful in practice.</p>
<p>In particular in a <strong>supervised setting</strong> it can be successfully combined
with fast and scalable linear models to train <strong>document classificers</strong>,
for instance:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="../auto_examples/document_classification_20newsgroups.html#example-document-classification-20newsgroups-py"><em>Classification of text documents using sparse features</em></a></li>
</ul>
</div></blockquote>
<p>In an <strong>unsupervised setting</strong> it can be used to group similar documents
together by applying clustering algorithms such as <a class="reference internal" href="clustering.html#k-means"><em>K-means</em></a>:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="../auto_examples/document_clustering.html#example-document-clustering-py"><em>Clustering text documents using k-means</em></a></li>
</ul>
</div></blockquote>
<p>Finally it is possible to discover the main topics of a corpus by
relaxing the hard assignment constraint of clustering, for instance by
using <a class="reference internal" href="decomposition.html#nmf"><em>Non-negative matrix factorization (NMF or NNMF)</em></a>:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="../auto_examples/applications/topics_extraction_with_nmf.html#example-applications-topics-extraction-with-nmf-py"><em>Topics extraction with Non-Negative Matrix Factorization</em></a></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="limitations-of-the-bag-of-words-representation">
<h3>6.1.3.6. Limitations of the Bag of Words representation<a class="headerlink" href="#limitations-of-the-bag-of-words-representation" title="Permalink to this headline">¶</a></h3>
<p>A collection of unigrams (what bag of words is) cannot capture phrases
and multi-word expressions, effectively disregarding any word order
dependence. Additionally, bag of words model doesn&#8217;t account for potential
misspellings or word derivations.</p>
<p>N-grams to the rescue! Instead of building a simple collection of
unigrams (n=1), one might prefer a collection of bigrams (n=2), where
occurrences of pairs of consecutive words are counted.</p>
<p>One might alternatively consider a collection of character n-grams, a
representation resiliant against misspellings and derivations.</p>
<p>For example, let&#8217;s say we&#8217;re dealing with a corpus of two documents:
<tt class="docutils literal"><span class="pre">['words',</span> <span class="pre">'wprds']</span></tt>. The second document contains a misspelling
of the word &#8216;words&#8217;.
A simple bag of words representation would consider these two as
very distinct documents, differing in both of the two possible features.
A character 2-gram representation, however, would find the documents
matching in 4 out of 8 features, which may help the preferred classifier
decide better:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ngram_vectorizer</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span><span class="n">analyzer</span><span class="o">=</span><span class="s">&#39;char_wb&#39;</span><span class="p">,</span> <span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">min_df</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span> <span class="o">=</span> <span class="n">ngram_vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">([</span><span class="s">&#39;words&#39;</span><span class="p">,</span> <span class="s">&#39;wprds&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ngram_vectorizer</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">()</span>
<span class="go">[u&#39; w&#39;, u&#39;ds&#39;, u&#39;or&#39;, u&#39;pr&#39;, u&#39;rd&#39;, u&#39;s &#39;, u&#39;wo&#39;, u&#39;wp&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 0, 1, 1, 1, 0],</span>
<span class="go">       [1, 1, 0, 1, 1, 1, 0, 1]])</span>
</pre></div>
</div>
<p>In above example, <tt class="docutils literal"><span class="pre">'char_wb</span></tt> analyzer is used, which creates n-grams
only from characters inside word boundaries (padded with space on each
side). The <tt class="docutils literal"><span class="pre">'char'</span></tt> analyzer, alternatively, creates n-grams that
span across words:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ngram_vectorizer</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span><span class="n">analyzer</span><span class="o">=</span><span class="s">&#39;char_wb&#39;</span><span class="p">,</span> <span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">min_df</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ngram_vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">([</span><span class="s">&#39;jumpy fox&#39;</span><span class="p">])</span>
<span class="gp">... </span>                                        
<span class="go">&lt;1x4 sparse matrix of type &#39;&lt;type &#39;numpy.int64&#39;&gt;&#39;</span>
<span class="go">   with 4 stored elements in Compressed Sparse Column format&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ngram_vectorizer</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">()</span>
<span class="go">[u&#39; fox &#39;, u&#39; jump&#39;, u&#39;jumpy&#39;, u&#39;umpy &#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ngram_vectorizer</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span><span class="n">analyzer</span><span class="o">=</span><span class="s">&#39;char&#39;</span><span class="p">,</span> <span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">min_df</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ngram_vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">([</span><span class="s">&#39;jumpy fox&#39;</span><span class="p">])</span>
<span class="gp">... </span>                                        
<span class="go">&lt;1x5 sparse matrix of type &#39;&lt;type &#39;numpy.int64&#39;&gt;&#39;</span>
<span class="go">    with 5 stored elements in Compressed Sparse Column format&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ngram_vectorizer</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">()</span>
<span class="go">[u&#39;jumpy&#39;, u&#39;mpy f&#39;, u&#39;py fo&#39;, u&#39;umpy &#39;, u&#39;y fox&#39;]</span>
</pre></div>
</div>
<p>The word boundaries-aware variant <tt class="docutils literal"><span class="pre">char_wb</span></tt> is especially interesting
for languages that use whitespaces for word separation as it generates
significantly less noisy features than the raw <tt class="docutils literal"><span class="pre">char</span></tt> variant in
that case. For such languages it can increase both the predictive
accuracy and convergence speed of classifiers trained using such
features while retaining the robustness w.r.t. misspellings and
word derivations.</p>
<p>While some local positioning information can be preserved by extracting
n-grams instead of individual words, bag of words and bag of n-grams
destroy most of the inner structure of the document and hence most of
the meaning carried by that internal structure.</p>
<p>In order to address the wider task of Natural Language Understanding,
the local structure of sentences and paragraphs should thus be taken
into account. Many such models will thus be casted as &#8220;Structured output&#8221;
problems which are currently outside of the scope of scikit-learn.</p>
</div>
<div class="section" id="vectorizing-a-large-text-corpus-with-the-hashing-trick">
<span id="hashing-vectorizer"></span><h3>6.1.3.7. Vectorizing a large text corpus with the hashing trick<a class="headerlink" href="#vectorizing-a-large-text-corpus-with-the-hashing-trick" title="Permalink to this headline">¶</a></h3>
<p>The above vectorization scheme is simple but the fact that it holds an <strong>in-
memory mapping from the string tokens to the integer feature indices</strong> (the
<tt class="docutils literal"><span class="pre">vocabulary_</span></tt> attribute) causes several <strong>problems when dealing with large
datasets</strong>:</p>
<ul class="simple">
<li>the larger the corpus, the larger the vocabulary will grow and hence the
memory use too,</li>
<li>fitting requires the allocation of intermediate data structures
of size proportional to that of the original dataset.</li>
<li>building the word-mapping requires a full pass over the dataset hence it is
not possible to fit text classifiers in a strictly online manner.</li>
<li>pickling and un-pickling vectorizers with a large <tt class="docutils literal"><span class="pre">vocabulary_</span></tt> can be very
slow (typically much slower than pickling / un-pickling flat data structures
such as a NumPy array of the same size),</li>
<li>it is not easily possible to split the vectorization work into concurrent sub
tasks as the <tt class="docutils literal"><span class="pre">vocabulary_</span></tt> attribute would have to be a shared state with a
fine grained synchronization barrier: the mapping from token string to
feature index is dependent on ordering of the first occurrence of each token
hence would have to be shared, potentially harming the concurrent workers&#8217;
performance to the point of making them slower than the sequential variant.</li>
</ul>
<p>It is possible to overcome those limitations by combining the &#8220;hashing trick&#8221;
(<a class="reference internal" href="#feature-hashing"><em>Feature hashing</em></a>) implemented by the
<a class="reference internal" href="generated/sklearn.feature_extraction.FeatureHasher.html#sklearn.feature_extraction.FeatureHasher" title="sklearn.feature_extraction.FeatureHasher"><tt class="xref py py-class docutils literal"><span class="pre">sklearn.feature_extraction.FeatureHasher</span></tt></a> class and the text
preprocessing and tokenization features of the <a class="reference internal" href="generated/sklearn.feature_extraction.text.CountVectorizer.html#sklearn.feature_extraction.text.CountVectorizer" title="sklearn.feature_extraction.text.CountVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">CountVectorizer</span></tt></a>.</p>
<p>This combination is implementing in <a class="reference internal" href="generated/sklearn.feature_extraction.text.HashingVectorizer.html#sklearn.feature_extraction.text.HashingVectorizer" title="sklearn.feature_extraction.text.HashingVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">HashingVectorizer</span></tt></a>,
a transformer class that is mostly API compatible with <a class="reference internal" href="generated/sklearn.feature_extraction.text.CountVectorizer.html#sklearn.feature_extraction.text.CountVectorizer" title="sklearn.feature_extraction.text.CountVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">CountVectorizer</span></tt></a>.
<a class="reference internal" href="generated/sklearn.feature_extraction.text.HashingVectorizer.html#sklearn.feature_extraction.text.HashingVectorizer" title="sklearn.feature_extraction.text.HashingVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">HashingVectorizer</span></tt></a> is stateless,
meaning that you don&#8217;t have to call <tt class="docutils literal"><span class="pre">fit</span></tt> on it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">HashingVectorizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hv</span> <span class="o">=</span> <span class="n">HashingVectorizer</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hv</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>
<span class="gp">... </span>                                      
<span class="go">&lt;4x10 sparse matrix of type &#39;&lt;type &#39;numpy.float64&#39;&gt;&#39;</span>
<span class="go">    with 16 stored elements in Compressed Sparse Row format&gt;</span>
</pre></div>
</div>
<p>You can see that 16 non-zero feature tokens where extracted in the vector
output: this is less than the 19 non-zeros extracted previously by the
<a class="reference internal" href="generated/sklearn.feature_extraction.text.CountVectorizer.html#sklearn.feature_extraction.text.CountVectorizer" title="sklearn.feature_extraction.text.CountVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">CountVectorizer</span></tt></a> on the same toy corpus. The discrepancy comes from
hash function collisions because of the low value of the <tt class="docutils literal"><span class="pre">n_features</span></tt> parameter.</p>
<p>In a real world setting, the <tt class="docutils literal"><span class="pre">n_features</span></tt> parameter can be left to its
default value of <tt class="docutils literal"><span class="pre">2</span> <span class="pre">**</span> <span class="pre">20</span></tt> (roughly one million possible features). If memory
or downstream models size is an issue selecting a lower value such as <tt class="docutils literal"><span class="pre">2</span> <span class="pre">**</span>
<span class="pre">18</span></tt> might help without introducing too many additional collisions on typical
text classification tasks.</p>
<p>Note that the dimensionality does not affect the CPU training time of
algorithms which operate on CSR matrices (<tt class="docutils literal"><span class="pre">LinearSVC(dual=True)</span></tt>,
<tt class="docutils literal"><span class="pre">Perceptron</span></tt>, <tt class="docutils literal"><span class="pre">SGDClassifier</span></tt>, <tt class="docutils literal"><span class="pre">PassiveAggressive</span></tt>) but it does for
algorithm that work with CSC matrices (<tt class="docutils literal"><span class="pre">LinearSVC(dual=False)</span></tt>, <tt class="docutils literal"><span class="pre">Lasso()</span></tt>,
etc).</p>
<p>Let&#8217;s try again with the default setting:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">hv</span> <span class="o">=</span> <span class="n">HashingVectorizer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hv</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>
<span class="gp">... </span>                                      
<span class="go">&lt;4x1048576 sparse matrix of type &#39;&lt;type &#39;numpy.float64&#39;&gt;&#39;</span>
<span class="go">    with 19 stored elements in Compressed Sparse Row format&gt;</span>
</pre></div>
</div>
<p>We no longer get the collisions, but this comes at the expense of a much larger
dimensionality of the output space.
Of course, other terms than the 19 used here
might still collide with each other.</p>
<p>The <a class="reference internal" href="generated/sklearn.feature_extraction.text.HashingVectorizer.html#sklearn.feature_extraction.text.HashingVectorizer" title="sklearn.feature_extraction.text.HashingVectorizer"><tt class="xref py py-class docutils literal"><span class="pre">HashingVectorizer</span></tt></a> also comes with the following limitations:</p>
<ul class="simple">
<li>it is not possible to invert the model (no <tt class="docutils literal"><span class="pre">inverse_transform</span></tt> method),
nor to access the original string representation of the features,
because of the one-way nature of the hash function that performs the mapping.</li>
<li>it does not provide IDF weighting as that would introduce statefulness in the
model. A <a class="reference internal" href="generated/sklearn.feature_extraction.text.TfidfTransformer.html#sklearn.feature_extraction.text.TfidfTransformer" title="sklearn.feature_extraction.text.TfidfTransformer"><tt class="xref py py-class docutils literal"><span class="pre">TfidfTransformer</span></tt></a> can be appended to it in a pipeline if
required.</li>
</ul>
</div>
<div class="section" id="customizing-the-vectorizer-classes">
<h3>6.1.3.8. Customizing the vectorizer classes<a class="headerlink" href="#customizing-the-vectorizer-classes" title="Permalink to this headline">¶</a></h3>
<p>It is possible to customize the behavior by passing a callable
to the vectorizer constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_tokenizer</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vectorizer</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span><span class="n">tokenizer</span><span class="o">=</span><span class="n">my_tokenizer</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vectorizer</span><span class="o">.</span><span class="n">build_analyzer</span><span class="p">()(</span><span class="s">u&quot;Some... punctuation!&quot;</span><span class="p">)</span>
<span class="go">[u&#39;some...&#39;, u&#39;punctuation!&#39;]</span>
</pre></div>
</div>
<p>In particular we name:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">preprocessor</span></tt>: a callable that takes an entire document as input (as a
single string), and returns a possibly transformed version of the document,
still as an entire string. This can be used to remove HTML tags, lowercase
the entire document, etc.</li>
<li><tt class="docutils literal"><span class="pre">tokenizer</span></tt>: a callable that takes the output from the preprocessor
and splits it into tokens, then returns a list of these.</li>
<li><tt class="docutils literal"><span class="pre">analyzer</span></tt>: a callable that replaces the preprocessor and tokenizer.
The default analyzers all call the preprocessor and tokenizer, but custom
analyzers will skip this. N-gram extraction and stop word filtering take
place at the analyzer level, so a custom analyzer may have to reproduce
these steps.</li>
</ul>
</div></blockquote>
<p>(Lucene users might recognize these names, but be aware that scikit-learn
concepts may not map one-to-one onto Lucene concepts.)</p>
<p>To make the preprocessor, tokenizer and analyzers aware of the model
parameters it is possible to derive from the class and override the
<tt class="docutils literal"><span class="pre">build_preprocessor</span></tt>, <tt class="docutils literal"><span class="pre">build_tokenizer`</span></tt> and <tt class="docutils literal"><span class="pre">build_analyzer</span></tt>
factory methods instead of passing custom functions.</p>
<p>Some tips and tricks:</p>
<blockquote>
<div><ul>
<li><p class="first">If documents are pre-tokenized by an external package, then store them in
files (or strings) with the tokens separated by whitespace and pass
<tt class="docutils literal"><span class="pre">analyzer=str.split</span></tt></p>
</li>
<li><p class="first">Fancy token-level analysis such as stemming, lemmatizing, compound
splitting, filtering based on part-of-speech, etc. are not included in the
scikit-learn codebase, but can be added by customizing either the
tokenizer or the analyzer.
Here&#8217;s a <tt class="docutils literal"><span class="pre">CountVectorizer</span></tt> with a tokenizer and lemmatizer using NLTK:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk</span> <span class="kn">import</span> <span class="n">word_tokenize</span>          
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.stem</span> <span class="kn">import</span> <span class="n">WordNetLemmatizer</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">LemmaTokenizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">wnl</span> <span class="o">=</span> <span class="n">WordNetLemmatizer</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">wnl</span><span class="o">.</span><span class="n">lemmatize</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">word_tokenize</span><span class="p">(</span><span class="n">doc</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vect</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span><span class="n">tokenizer</span><span class="o">=</span><span class="n">LemmaTokenizer</span><span class="p">())</span>  
</pre></div>
</div>
<p>(Note that this will not filter out punctuation.)</p>
</li>
</ul>
</div></blockquote>
<p>Customizing the vectorizer can also be useful when handling Asian languages
that do not use an explicit word separator such as whitespace.</p>
</div>
</div>
<div class="section" id="image-feature-extraction">
<h2>6.1.4. Image feature extraction<a class="headerlink" href="#image-feature-extraction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="patch-extraction">
<h3>6.1.4.1. Patch extraction<a class="headerlink" href="#patch-extraction" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="generated/sklearn.feature_extraction.image.extract_patches_2d.html#sklearn.feature_extraction.image.extract_patches_2d" title="sklearn.feature_extraction.image.extract_patches_2d"><tt class="xref py py-func docutils literal"><span class="pre">extract_patches_2d</span></tt></a> function extracts patches from an image stored
as a two-dimensional array, or three-dimensional with color information along
the third axis. For rebuilding an image from all its patches, use
<a class="reference internal" href="generated/sklearn.feature_extraction.image.reconstruct_from_patches_2d.html#sklearn.feature_extraction.image.reconstruct_from_patches_2d" title="sklearn.feature_extraction.image.reconstruct_from_patches_2d"><tt class="xref py py-func docutils literal"><span class="pre">reconstruct_from_patches_2d</span></tt></a>. For example let use generate a 4x4 pixel
picture with 3 color channels (e.g. in RGB format):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.feature_extraction</span> <span class="kn">import</span> <span class="n">image</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">one_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">one_image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c"># R channel of a fake RGB picture</span>
<span class="go">array([[ 0,  3,  6,  9],</span>
<span class="go">       [12, 15, 18, 21],</span>
<span class="go">       [24, 27, 30, 33],</span>
<span class="go">       [36, 39, 42, 45]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">patches</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">extract_patches_2d</span><span class="p">(</span><span class="n">one_image</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">max_patches</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patches</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patches</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[[ 0,  3],</span>
<span class="go">        [12, 15]],</span>

<span class="go">       [[15, 18],</span>
<span class="go">        [27, 30]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patches</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">extract_patches_2d</span><span class="p">(</span><span class="n">one_image</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patches</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(9, 2, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patches</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[15, 18],</span>
<span class="go">       [27, 30]])</span>
</pre></div>
</div>
<p>Let us now try to reconstruct the original image from the patches by averaging
on overlapping areas:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">reconstructed</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">reconstruct_from_patches_2d</span><span class="p">(</span><span class="n">patches</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">one_image</span><span class="p">,</span> <span class="n">reconstructed</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="generated/sklearn.feature_extraction.image.PatchExtractor.html#sklearn.feature_extraction.image.PatchExtractor" title="sklearn.feature_extraction.image.PatchExtractor"><tt class="xref py py-class docutils literal"><span class="pre">PatchExtractor</span></tt></a> class works in the same way as
<a class="reference internal" href="generated/sklearn.feature_extraction.image.extract_patches_2d.html#sklearn.feature_extraction.image.extract_patches_2d" title="sklearn.feature_extraction.image.extract_patches_2d"><tt class="xref py py-func docutils literal"><span class="pre">extract_patches_2d</span></tt></a>, only it supports multiple images as input. It is
implemented as an estimator, so it can be used in pipelines. See:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">five_images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patches</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">PatchExtractor</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">five_images</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patches</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(45, 2, 2, 3)</span>
</pre></div>
</div>
</div>
<div class="section" id="connectivity-graph-of-an-image">
<h3>6.1.4.2. Connectivity graph of an image<a class="headerlink" href="#connectivity-graph-of-an-image" title="Permalink to this headline">¶</a></h3>
<p>Several estimators in the scikit-learn can use connectivity information between
features or samples. For instance Ward clustering
(<a class="reference internal" href="clustering.html#hierarchical-clustering"><em>Hierarchical clustering</em></a>) can cluster together only neighboring pixels
of an image, thus forming contiguous patches:</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/cluster/plot_lena_ward_segmentation.html"><img alt="../_images/plot_lena_ward_segmentation_11.png" src="../_images/plot_lena_ward_segmentation_11.png" style="width: 200.0px; height: 200.0px;" /></a>
</div>
<p>For this purpose, the estimators use a &#8216;connectivity&#8217; matrix, giving
which samples are connected.</p>
<p>The function <a class="reference internal" href="generated/sklearn.feature_extraction.image.img_to_graph.html#sklearn.feature_extraction.image.img_to_graph" title="sklearn.feature_extraction.image.img_to_graph"><tt class="xref py py-func docutils literal"><span class="pre">img_to_graph</span></tt></a> returns such a matrix from a 2D or 3D
image. Similarly, <a class="reference internal" href="generated/sklearn.feature_extraction.image.grid_to_graph.html#sklearn.feature_extraction.image.grid_to_graph" title="sklearn.feature_extraction.image.grid_to_graph"><tt class="xref py py-func docutils literal"><span class="pre">grid_to_graph</span></tt></a> build a connectivity matrix for
images given the shape of these image.</p>
<p>These matrices can be used to impose connectivity in estimators that use
connectivity information, such as Ward clustering
(<a class="reference internal" href="clustering.html#hierarchical-clustering"><em>Hierarchical clustering</em></a>), but also to build precomputed kernels,
or similarity matrices.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>Examples</strong></p>
<ul class="last simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_lena_ward_segmentation.html#example-cluster-plot-lena-ward-segmentation-py"><em>A demo of structured Ward hierarchical clustering on Lena image</em></a></li>
<li><a class="reference internal" href="../auto_examples/cluster/plot_segmentation_toy.html#example-cluster-plot-segmentation-toy-py"><em>Spectral clustering for image segmentation</em></a></li>
<li><a class="reference internal" href="../auto_examples/cluster/plot_feature_agglomeration_vs_univariate_selection.html#example-cluster-plot-feature-agglomeration-vs-univariate-selection-py"><em>Feature agglomeration vs. univariate selection</em></a></li>
</ul>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer">
        &copy; 2010–2013, scikit-learn developers (BSD License).
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3. Design by <a href="http://desgrana.es">Desgrana</a>.
    <span style="padding-left: 5ex;">
    <a href="../_sources/modules/feature_extraction.txt"
	    rel="nofollow">Show this page source</a>
    </span>
    </div>
     <div class="rel">
    
    <div class="buttonPrevious">
      <a href="../data_transforms.html">
        Previous
      </a>
    </div>
    <div class="buttonNext">
      <a href="preprocessing.html">
        Next
      </a>
    </div>
    <div class="buttonPrevious">
      <a href="../np-modindex.html">
        Previous
      </a>
    </div>
    <div class="buttonNext">
      <a href="../py-modindex.html">
        Next
      </a>
    </div>
    
     </div>
     <script type="text/javascript">
       $("div.buttonNext, div.buttonPrevious").hover(
           function () {
               $(this).css('background-color', '#FF9C34');
           },
           function () {
               $(this).css('background-color', '#A7D6E2');
           }
       );
       var bodywrapper = $('.bodywrapper');
   	var sidebarbutton = $('#sidebarbutton');
        sidebarbutton.css({
	    'height': '900px'
       });
     </script>
  </body>
</html>