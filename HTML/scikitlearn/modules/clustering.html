

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>4.3. Clustering &mdash; scikit-learn 0.13.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.13.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="top" title="scikit-learn 0.13.1 documentation" href="../index.html" />
    <link rel="up" title="4. Unsupervised learning" href="../unsupervised_learning.html" />
    <link rel="next" title="4.4. Decomposing signals in components (matrix factorization problems)" href="decomposition.html" />
    <link rel="prev" title="4.2. Manifold learning" href="manifold.html" />


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-22606712-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>



  </head>
  <body>

    <div class="header-wrapper">
      <div class="header">
          <p class="logo"><a href="../index.html">
            <img src="../_static/scikit-learn-logo-small.png" alt="Logo"/>
          </a>
          </p><div class="navbar">
          <ul>
            <li><a href="../install.html">Download</a></li>
            <li><a href="../support.html">Support</a></li>
            <li><a href="../user_guide.html">User Guide</a></li>
            <li><a href="../auto_examples/index.html">Examples</a></li>
            <li><a href="classes.html">Reference</a></li>
       </ul>

<div class="search_form">

<div id="cse" style="width: 100%;"></div>
<script src="http://www.google.com/jsapi" type="text/javascript"></script>
<script type="text/javascript">
  google.load('search', '1', {language : 'en'});
  google.setOnLoadCallback(function() {
    var customSearchControl = new google.search.CustomSearchControl('016639176250731907682:tjtqbvtvij0');
    customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
    var options = new google.search.DrawOptions();
    options.setAutoComplete(true);
    customSearchControl.draw('cse', options);
  }, true);
</script>

</div>
          </div> <!-- end navbar --></div>
    </div>

    <div class="content-wrapper">

      <div class="sphinxsidebar">
	<div class="sphinxsidebarwrapper">
	  <div class="rel">
	   
	<!-- rellinks[1:] is an ugly hack to avoid link to module
	    index  -->
	<div class="rellink">
	<a href="manifold.html" title="4.2. Manifold learning"
	    accesskey="P">Previous
	    <br>
	    <span class="smallrellink">
	    4.2. Manifold le...
	    </span>
	    <span class="hiddenrellink">
	    4.2. Manifold learning
	    </span>
	    
	    </a>
	</div>
	    <div class="spacer">
	    &nbsp;
	    </div>
	
	<div class="rellink">
	<a href="decomposition.html" title="4.4. Decomposing signals in components (matrix factorization problems)"
	    accesskey="N">Next
	    <br>
	    <span class="smallrellink">
	    4.4. Decomposing...
	    </span>
	    <span class="hiddenrellink">
	    4.4. Decomposing signals in components (matrix factorization problems)
	    </span>
	    
	    </a>
	</div>
	<!-- Ad a link to the 'up' page -->
	<div class="spacer">
	&nbsp;
	</div>
	<div class="rellink">
	<a href="../unsupervised_learning.html" title="4. Unsupervised learning" >
	Up
	<br>
	<span class="smallrellink">
	4. Unsupervised ...
	</span>
	<span class="hiddenrellink">
	4. Unsupervised learning
	</span>
	
	</a>
	</div>
    </div>
    <p style="text-align: center; background-color: #FFE4E4">This documentation is
    for scikit-learn <strong>version 0.13.1</strong>
    &mdash; <a href="http://scikit-learn.org/stable/support.html#documentation-resources">Other versions</a></p>
    
    <h3><a href="../about.html#citing-scikit-learn">Citing</a></h3>
    <p>If you use the software, please consider
    <a href="../about.html#citing-scikit-learn">citing scikit-learn</a>.</p>
    <h3>This page</h3>
	<ul>
<li><a class="reference internal" href="#">4.3. Clustering</a><ul>
<li><a class="reference internal" href="#overview-of-clustering-methods">4.3.1. Overview of clustering methods</a></li>
<li><a class="reference internal" href="#k-means">4.3.2. K-means</a><ul>
<li><a class="reference internal" href="#mini-batch-k-means">4.3.2.1. Mini Batch K-Means</a></li>
</ul>
</li>
<li><a class="reference internal" href="#affinity-propagation">4.3.3. Affinity Propagation</a></li>
<li><a class="reference internal" href="#mean-shift">4.3.4. Mean Shift</a></li>
<li><a class="reference internal" href="#spectral-clustering">4.3.5. Spectral clustering</a><ul>
<li><a class="reference internal" href="#different-label-assignment-strategies">4.3.5.1. Different label assignment strategies</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hierarchical-clustering">4.3.6. Hierarchical clustering</a><ul>
<li><a class="reference internal" href="#adding-connectivity-constraints">4.3.6.1. Adding connectivity constraints</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dbscan">4.3.7. DBSCAN</a></li>
<li><a class="reference internal" href="#clustering-performance-evaluation">4.3.8. Clustering performance evaluation</a><ul>
<li><a class="reference internal" href="#inertia">4.3.8.1. Inertia</a><ul>
<li><a class="reference internal" href="#presentation-and-usage">4.3.8.1.1. Presentation and usage</a></li>
<li><a class="reference internal" href="#advantages">4.3.8.1.2. Advantages</a></li>
<li><a class="reference internal" href="#drawbacks">4.3.8.1.3. Drawbacks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#adjusted-rand-index">4.3.8.2. Adjusted Rand index</a><ul>
<li><a class="reference internal" href="#id8">4.3.8.2.1. Presentation and usage</a></li>
<li><a class="reference internal" href="#id9">4.3.8.2.2. Advantages</a></li>
<li><a class="reference internal" href="#id10">4.3.8.2.3. Drawbacks</a></li>
<li><a class="reference internal" href="#mathematical-formulation">4.3.8.2.4. Mathematical formulation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mutual-information-based-scores">4.3.8.3. Mutual Information based scores</a><ul>
<li><a class="reference internal" href="#id11">4.3.8.3.1. Presentation and usage</a></li>
<li><a class="reference internal" href="#id12">4.3.8.3.2. Advantages</a></li>
<li><a class="reference internal" href="#id13">4.3.8.3.3. Drawbacks</a></li>
<li><a class="reference internal" href="#id14">4.3.8.3.4. Mathematical formulation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#homogeneity-completeness-and-v-measure">4.3.8.4. Homogeneity, completeness and V-measure</a><ul>
<li><a class="reference internal" href="#id15">4.3.8.4.1. Presentation and usage</a></li>
<li><a class="reference internal" href="#id17">4.3.8.4.2. Advantages</a></li>
<li><a class="reference internal" href="#id18">4.3.8.4.3. Drawbacks</a></li>
<li><a class="reference internal" href="#id19">4.3.8.4.4. Mathematical formulation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#silhouette-coefficient">4.3.8.5. Silhouette Coefficient</a><ul>
<li><a class="reference internal" href="#id21">4.3.8.5.1. Presentation and usage</a></li>
<li><a class="reference internal" href="#id22">4.3.8.5.2. Advantages</a></li>
<li><a class="reference internal" href="#id23">4.3.8.5.3. Drawbacks</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    
    </div>
	  </div>


      <div class="content">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="clustering">
<span id="id1"></span><h1>4.3. Clustering<a class="headerlink" href="#clustering" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Cluster_analysis">Clustering</a> of
unlabeled data can be performed with the module <a class="reference internal" href="classes.html#module-sklearn.cluster" title="sklearn.cluster"><tt class="xref py py-mod docutils literal"><span class="pre">sklearn.cluster</span></tt></a>.</p>
<p>Each clustering algorithm comes in two variants: a class, that implements
the <cite>fit</cite> method to learn the clusters on train data, and a function,
that, given train data, returns an array of integer labels corresponding
to the different clusters. For the class, the labels over the training
data can be found in the <cite>labels_</cite> attribute.</p>
<div class="topic">
<p class="topic-title first">Input data</p>
<p>One important thing to note is that the algorithms implemented in
this module take different kinds of matrix as input.  On one hand,
<a class="reference internal" href="generated/sklearn.cluster.MeanShift.html#sklearn.cluster.MeanShift" title="sklearn.cluster.MeanShift"><tt class="xref py py-class docutils literal"><span class="pre">MeanShift</span></tt></a> and <a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><tt class="xref py py-class docutils literal"><span class="pre">KMeans</span></tt></a> take data matrices of shape
[n_samples, n_features]. These can be obtained from the classes in
the <a class="reference internal" href="classes.html#module-sklearn.feature_extraction" title="sklearn.feature_extraction"><tt class="xref py py-mod docutils literal"><span class="pre">sklearn.feature_extraction</span></tt></a> module. On the other hand,
<a class="reference internal" href="generated/sklearn.cluster.AffinityPropagation.html#sklearn.cluster.AffinityPropagation" title="sklearn.cluster.AffinityPropagation"><tt class="xref py py-class docutils literal"><span class="pre">AffinityPropagation</span></tt></a> and <a class="reference internal" href="generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><tt class="xref py py-class docutils literal"><span class="pre">SpectralClustering</span></tt></a> take
similarity matrices of shape [n_samples, n_samples].  These can be
obtained from the functions in the <a class="reference internal" href="classes.html#module-sklearn.metrics.pairwise" title="sklearn.metrics.pairwise"><tt class="xref py py-mod docutils literal"><span class="pre">sklearn.metrics.pairwise</span></tt></a>
module. In other words, <a class="reference internal" href="generated/sklearn.cluster.MeanShift.html#sklearn.cluster.MeanShift" title="sklearn.cluster.MeanShift"><tt class="xref py py-class docutils literal"><span class="pre">MeanShift</span></tt></a> and <a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><tt class="xref py py-class docutils literal"><span class="pre">KMeans</span></tt></a> work
with points in a vector space, whereas <a class="reference internal" href="generated/sklearn.cluster.AffinityPropagation.html#sklearn.cluster.AffinityPropagation" title="sklearn.cluster.AffinityPropagation"><tt class="xref py py-class docutils literal"><span class="pre">AffinityPropagation</span></tt></a>
and <a class="reference internal" href="generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><tt class="xref py py-class docutils literal"><span class="pre">SpectralClustering</span></tt></a> can work with arbitrary objects, as
long as a similarity measure exists for such objects.</p>
</div>
<div class="section" id="overview-of-clustering-methods">
<h2>4.3.1. Overview of clustering methods<a class="headerlink" href="#overview-of-clustering-methods" title="Permalink to this headline">¶</a></h2>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/cluster/plot_cluster_comparison.html"><img alt="../_images/plot_cluster_comparison_11.png" src="../_images/plot_cluster_comparison_11.png" style="width: 700.0px; height: 475.0px;" /></a>
<p class="caption">A comparison of the clustering algorithms in scikit-learn</p>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="16%" />
<col width="20%" />
<col width="27%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Parameters</th>
<th class="head">Scalability</th>
<th class="head">Usecase</th>
<th class="head">Geometry (metric used)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#k-means"><em>K-Means</em></a></td>
<td>number of clusters</td>
<td>Very large <cite>n_samples</cite>, medium <cite>n_clusters</cite> with
<a class="reference internal" href="#mini-batch-kmeans"><em>MiniBatch code</em></a></td>
<td>General-purpose, even cluster size, flat geometry, not too many clusters</td>
<td>Distances between points</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#affinity-propagation"><em>Affinity propagation</em></a></td>
<td>damping, sample preference</td>
<td>Not scalable with n_samples</td>
<td>Many clusters, uneven cluster size, non-flat geometry</td>
<td>Graph distance (e.g. nearest-neighbor graph)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mean-shift"><em>Mean-shift</em></a></td>
<td>bandwidth</td>
<td>Not scalable with n_samples</td>
<td>Many clusters, uneven cluster size, non-flat geometry</td>
<td>Distances between points</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spectral-clustering"><em>Spectral clustering</em></a></td>
<td>number of clusters</td>
<td>Medium <cite>n_samples</cite>, small <cite>n_clusters</cite></td>
<td>Few clusters, even cluster size, non-flat geometry</td>
<td>Graph distance (e.g. nearest-neighbor graph)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hierarchical-clustering"><em>Hierarchical clustering</em></a></td>
<td>number of clusters</td>
<td>Large <cite>n_samples</cite> and <cite>n_clusters</cite></td>
<td>Many clusters, possibly connectivity constraints</td>
<td>Distances between points</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dbscan"><em>DBSCAN</em></a></td>
<td>neighborhood size</td>
<td>Very large <cite>n_samples</cite>, medium <cite>n_clusters</cite></td>
<td>Non-flat geometry, uneven cluster sizes</td>
<td>Distances between nearest points</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="mixture.html#mixture"><em>Gaussian mixtures</em></a></td>
<td>many</td>
<td>Not scalable</td>
<td>Flat geometry, good for density estimation</td>
<td>Mahalanobis distances to  centers</td>
</tr>
</tbody>
</table>
<p>Non-flat geometry clustering is useful when the clusters have a specific
shape, i.e. a non-flat manifold, and the standard euclidean distance is
not the right metric. This case arises in the two top rows of the figure
above.</p>
<p>Gaussian mixture models, useful for clustering, are described in
<a class="reference internal" href="mixture.html#mixture"><em>another chapter of the documentation</em></a> dedicated to
mixture models. KMeans can be seen as a special case of Gaussian mixture
model with equal covariance per component.</p>
</div>
<div class="section" id="k-means">
<span id="id2"></span><h2>4.3.2. K-means<a class="headerlink" href="#k-means" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><tt class="xref py py-class docutils literal"><span class="pre">KMeans</span></tt></a> algorithm clusters data by trying to separate samples
in n groups of equal variance, minimizing a criterion known as the
&#8216;inertia&#8217; of the groups. This algorithm requires the number of cluster to
be specified. It scales well to large number of samples and has been used
across a large range of application areas in many different fields. It is
also equivalent to the expectation-maximization algorithm when setting the
covariance matrix to be diagonal, equal and small. The K-means algorithm
aims to choose centroids <img class="math" src="../_images/math/c3355896da590fc491a10150a50416687626d7cc.png" alt="C"/> that minimise the within cluster sum of
squares objective function with a dataset <img class="math" src="../_images/math/6a47ca0fe7cb276abc022af6ac88ddae1a9d6894.png" alt="X"/> with <img class="math" src="../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n"/> samples:</p>
<div class="math">
<p><img src="../_images/math/eb370e2b1002b07a6a41a827e6cc85de073bce71.png" alt="J(X, C) = \sum_{i=0}^{n}\min_{\mu_j \in C}(||x_j - \mu_i||^2)"/></p>
</div><p>K-means is often referred to as Lloyd&#8217;s algorithm. In basic terms, the
algorithm has three steps. The first step chooses the initial centroids, with
the most basic method being to choose <img class="math" src="../_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k"/> samples from the dataset
<img class="math" src="../_images/math/6a47ca0fe7cb276abc022af6ac88ddae1a9d6894.png" alt="X"/>. After initialization, k-means consists of looping between the other
two major steps. The first steps assigns each sample to its nearest centroid.
The second step creates new centroids by taking the mean value of all of the
samples assigned to each previous centroid. The difference between the old
and the new centroids is the inertia and the algorithm repeats these last two
steps until this value is less than a threshold. In other words, it repeats
until the centroids do not move significantly.</p>
<a class="reference external image-reference" href="../auto_examples/cluster/plot_kmeans_digits.html"><img alt="../_images/plot_kmeans_digits_11.png" class="align-right" src="../_images/plot_kmeans_digits_11.png" style="width: 280.0px; height: 210.0px;" /></a>
<p>The algorithm can be identified through the concept of <a class="reference external" href="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi diagrams</a>. First the Voronoi diagram
of the points is calculated using the current centroids. Each segment in the
Voronoi diagram becomes a separate cluster. Secondly, the centroids are updated
to the mean of each segment. The algorithm then repeats this until a stopping
criterion is fulfilled. Usually, as in this implementation, the algorithm stops
when the relative decrease in the objective function between iterations is less
than the given tolerance value.</p>
<p>Given enough time, K-means will always converge, however this may be to a local
minimum. This is highly dependent on the the initialisation of the centroids.
As a result, the computation is often done several times, with different
initialisation of the centroids. One method to help address this issue is the
k-means++ initialisation algorithm, which has been implemented in
scikit-learn (use the <tt class="docutils literal"><span class="pre">init='kmeans++'</span></tt> parameter). This initialises the
centroids to be (generally) distant from each other, leading to provably better
results than random initialisation.</p>
<p>A parameter can be given to allow K-means to be run in parallel, called
<cite>n_jobs</cite>. Giving this parameter a positive value uses that many processors
(default=1). A value of -1 uses all processors, with -2 using one less, and so
on. Parallelization generally speeds up computation at the cost of memory (in
this case, multiple copies of centroids need to be stored, one for each job).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The parallel version of K-Means is broken on OS X when numpy uses the
Accelerate Framework. This is expected behavior: Accelerate can be called
after a fork but you need to execv the subprocess with the python binary
(which multiprocessing does not do under posix).</p>
</div>
<p>K-means can be used for vector quantization. This is achieved using the
transform method of a trained model of <a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><tt class="xref py py-class docutils literal"><span class="pre">KMeans</span></tt></a>.</p>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_kmeans_digits.html#example-cluster-plot-kmeans-digits-py"><em>A demo of K-Means clustering on the handwritten digits data</em></a>: Clustering handwritten digits</li>
</ul>
</div>
<div class="section" id="mini-batch-k-means">
<span id="mini-batch-kmeans"></span><h3>4.3.2.1. Mini Batch K-Means<a class="headerlink" href="#mini-batch-k-means" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="generated/sklearn.cluster.MiniBatchKMeans.html#sklearn.cluster.MiniBatchKMeans" title="sklearn.cluster.MiniBatchKMeans"><tt class="xref py py-class docutils literal"><span class="pre">MiniBatchKMeans</span></tt></a> is a variant of the <a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><tt class="xref py py-class docutils literal"><span class="pre">KMeans</span></tt></a> algorithm
which uses mini-batches to reduce the computation time, while still attempting
to optimise the same objective function. Mini-batches are subsets of the input
data, randomly sampled in each training iteration. These mini-batches
drastically reduce the amount of computation required to converge to a local
solution. In contrast to other algorithms that reduce the convergence time of
k-means, mini-batch k-means produces results that are generally only slightly
worse than the standard algorithm.</p>
<p>The algorithm iterates between two major steps, similar to vanilla k-means.
In the first step, <cite>b</cite> samples are drawn randomly from the dataset, to form
a mini-batch. These are then assigned to the nearest centroid. In the second
step, the centroids are updated. In contrast to k-means, this is done on a
per-sample basis. For each sample in the mini-batch, the assigned centroid
is updated by taking the streaming average of the sample and all previous
samples assigned to that centroid. This has the effect of decreasing the
rate of change for a centroid over time. These steps are performed until
convergence or a predetermined number of iterations is reached.</p>
<p><a class="reference internal" href="generated/sklearn.cluster.MiniBatchKMeans.html#sklearn.cluster.MiniBatchKMeans" title="sklearn.cluster.MiniBatchKMeans"><tt class="xref py py-class docutils literal"><span class="pre">MiniBatchKMeans</span></tt></a> converges faster than <a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><tt class="xref py py-class docutils literal"><span class="pre">KMeans</span></tt></a>, but the quality
of the results is reduced. In practice this difference in quality can be quite
small, as shown in the example and cited reference.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/cluster/plot_mini_batch_kmeans.html"><img alt="../_images/plot_mini_batch_kmeans_11.png" src="../_images/plot_mini_batch_kmeans_11.png" style="width: 800.0px; height: 300.0px;" /></a>
</div>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_mini_batch_kmeans.html#example-cluster-plot-mini-batch-kmeans-py"><em>Comparison of the K-Means and MiniBatchKMeans clustering algorithms</em></a>: Comparison of KMeans and
MiniBatchKMeans</li>
<li><a class="reference internal" href="../auto_examples/document_clustering.html#example-document-clustering-py"><em>Clustering text documents using k-means</em></a>: Document clustering using sparse
MiniBatchKMeans</li>
<li><a class="reference internal" href="../auto_examples/cluster/plot_dict_face_patches.html#example-cluster-plot-dict-face-patches-py"><em>Online learning of a dictionary of parts of faces</em></a></li>
</ul>
</div>
<div class="topic">
<p class="topic-title first">References:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.eecs.tufts.edu/~dsculley/papers/fastkmeans.pdf">&#8220;Web Scale K-Means clustering&#8221;</a>
D. Sculley, <em>Proceedings of the 19th international conference on World
wide web</em> (2010)</li>
</ul>
</div>
</div>
</div>
<div class="section" id="affinity-propagation">
<span id="id3"></span><h2>4.3.3. Affinity Propagation<a class="headerlink" href="#affinity-propagation" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="generated/sklearn.cluster.AffinityPropagation.html#sklearn.cluster.AffinityPropagation" title="sklearn.cluster.AffinityPropagation"><tt class="xref py py-class docutils literal"><span class="pre">AffinityPropagation</span></tt></a> creates clusters by sending messages between
pairs of samples until convergence. A dataset is then described using a small
number of exemplars, which are identified as those most representative of other
samples. The messages sent between pairs represent the suitability for one
sample to be the exemplar of the other, which is updated in response to the
values from other pairs. This updating happens iteratively until convergence,
at which point the final exemplars are chosen, and hence the final clustering
is given.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/cluster/plot_affinity_propagation.html"><img alt="../_images/plot_affinity_propagation_11.png" src="../_images/plot_affinity_propagation_11.png" style="width: 400.0px; height: 300.0px;" /></a>
</div>
<p>Affinity Propagation can be interesting as it chooses the number of
clusters based on the data provided. For this purpose, the two important
parameters are the <cite>preference</cite>, which controls how many examplars are
used, and the <cite>damping</cite> factor.</p>
<p>The main drawback of Affinity Propagation is its complexity. The
algorithm has a time complexity of the order <img class="math" src="../_images/math/233744a49e1314cf5d4070e71860d46320ac5574.png" alt="O(N^2 T)"/>, where <cite>N</cite>
is the number of samples and <cite>T</cite> is the number of iterations until
convergence. Further, the memory complexity is of the order
<img class="math" src="../_images/math/6de05613abfee2f5068c82eeb927eb0f7beb0568.png" alt="O(N^2)"/> if a dense similarity matrix is used, but reducible if a
sparse similarity matrix is used. This makes Affinity Propagation most
appropriate for small to medium sized datasets.</p>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_affinity_propagation.html#example-cluster-plot-affinity-propagation-py"><em>Demo of affinity propagation clustering algorithm</em></a>: Affinity
Propagation on a synthetic 2D datasets with 3 classes.</li>
<li><a class="reference internal" href="../auto_examples/applications/plot_stock_market.html#example-applications-plot-stock-market-py"><em>Visualizing the stock market structure</em></a> Affinity Propagation on
Financial time series to find groups of companies</li>
</ul>
</div>
<p><strong>Algorithm description:</strong>
The messages sent between points belong to one of two categories. The first is
the responsibility <cite>r(i, k)</cite>, which is the accumulated evidence that sample <cite>k</cite>
should be the exemplar for sample <cite>i</cite>. The second is the availability <cite>a(i, k)</cite>
which is the accumulated evidence that sample <cite>i</cite> should choose sample <cite>k</cite> to
be its exemplar, and considers the values for all other samples that <cite>k</cite> should
be an exemplar. In this way, exemplars are chosen by samples if they are (1)
similar enough to many samples and (2) chosen by many samples to be
representative of themselves.</p>
<p>More formally, the responsibility of a sample <cite>k</cite> to be the exemplar of sample
<cite>i</cite> is given by:</p>
<div class="math">
<p><img src="../_images/math/d77efeee658e6be46c5c46be29a4bbd581a033e8.png" alt="r(i, k) \leftarrow s(i, k) - max [ a(i, \acute{k}) + s(i, \acute{k}) \forall \acute{k} \neq k ]"/></p>
</div><p>Where <img class="math" src="../_images/math/4b80ae5477d9c60603778f20eea6421a066b1732.png" alt="s(i, k)"/> is the similarity between samples <cite>i</cite> and <cite>k</cite>. The
availability of sample <cite>k</cite> to be the exemplar of sample <cite>i</cite> is given by:</p>
<div class="math">
<p><img src="../_images/math/4a05b5c9581a59fb3ed76ddde6f4275e40465c46.png" alt="a(i, k) \leftarrow min [0, r(k, k) + \sum_{\acute{i}~s.t.~\acute{i} \notin \{i, k\}}{r(\acute{i}, k)}]"/></p>
</div><p>To begin with, all values for <cite>r</cite> and <cite>a</cite> are set to zero, and the calculation
of each iterates until convergence.</p>
</div>
<div class="section" id="mean-shift">
<span id="id4"></span><h2>4.3.4. Mean Shift<a class="headerlink" href="#mean-shift" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="generated/sklearn.cluster.MeanShift.html#sklearn.cluster.MeanShift" title="sklearn.cluster.MeanShift"><tt class="xref py py-class docutils literal"><span class="pre">MeanShift</span></tt></a> clusters data by estimating <em>blobs</em> in a smooth
density of points matrix. This algorithm automatically sets its numbers
of cluster. It will have difficulties scaling to thousands of samples.
The utility function <a class="reference internal" href="generated/sklearn.cluster.estimate_bandwidth.html#sklearn.cluster.estimate_bandwidth" title="sklearn.cluster.estimate_bandwidth"><tt class="xref py py-func docutils literal"><span class="pre">estimate_bandwidth</span></tt></a> can be used to guess
the optimal bandwidth for <a class="reference internal" href="generated/sklearn.cluster.MeanShift.html#sklearn.cluster.MeanShift" title="sklearn.cluster.MeanShift"><tt class="xref py py-class docutils literal"><span class="pre">MeanShift</span></tt></a> from the data.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/cluster/plot_mean_shift.html"><img alt="../_images/plot_mean_shift_11.png" src="../_images/plot_mean_shift_11.png" style="width: 400.0px; height: 300.0px;" /></a>
</div>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_mean_shift.html#example-cluster-plot-mean-shift-py"><em>A demo of the mean-shift clustering algorithm</em></a>: Mean Shift clustering
on a synthetic 2D datasets with 3 classes.</li>
</ul>
</div>
</div>
<div class="section" id="spectral-clustering">
<span id="id5"></span><h2>4.3.5. Spectral clustering<a class="headerlink" href="#spectral-clustering" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><tt class="xref py py-class docutils literal"><span class="pre">SpectralClustering</span></tt></a> does a low-dimension embedding of the
affinity matrix between samples, followed by a KMeans in the low
dimensional space. It is especially efficient if the affinity matrix is
sparse and the <a class="reference external" href="http://code.google.com/p/pyamg/">pyamg</a> module is
installed. SpectralClustering requires the number of clusters to be
specified. It works well for a small number of clusters but is not
advised when using many clusters.</p>
<p>For two clusters, it solves a convex relaxation of the <a class="reference external" href="http://www.cs.berkeley.edu/~malik/papers/SM-ncut.pdf">normalised
cuts</a> problem on
the similarity graph: cutting the graph in two so that the weight of the
edges cut is small compared to the weights in of edges inside each
cluster. This criteria is especially interesting when working on images:
graph vertices are pixels, and edges of the similarity graph are a
function of the gradient of the image.</p>
<p class="centered">
<strong><a class="reference external image-reference" href="../auto_examples/cluster/plot_segmentation_toy.html"><img alt="noisy_img" src="../_images/plot_segmentation_toy_11.png" style="width: 300.0px; height: 300.0px;" /></a>
 <a class="reference external image-reference" href="../auto_examples/cluster/plot_segmentation_toy.html"><img alt="segmented_img" src="../_images/plot_segmentation_toy_21.png" style="width: 300.0px; height: 300.0px;" /></a>
</strong></p><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Transforming distance to well-behaved similarities</p>
<p>Note that if the values of your similarity matrix are not well
distributed, e.g. with negative values or with a distance matrix
rather than a similarity, the spectral problem will be singular and
the problem not solvable. In which case it is advised to apply a
transformation to the entries of the matrix. For instance, in the
case of a signed distance matrix, is common to apply a heat kernel:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">similarity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span> <span class="o">*</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">distance</span><span class="o">.</span><span class="n">std</span><span class="p">())</span>
</pre></div>
</div>
<p class="last">See the examples for such an application.</p>
</div>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_segmentation_toy.html#example-cluster-plot-segmentation-toy-py"><em>Spectral clustering for image segmentation</em></a>: Segmenting objects
from a noisy background using spectral clustering.</li>
<li><a class="reference internal" href="../auto_examples/cluster/plot_lena_segmentation.html#example-cluster-plot-lena-segmentation-py"><em>Segmenting the picture of Lena in regions</em></a>: Spectral clustering
to split the image of lena in regions.</li>
</ul>
</div>
<div class="section" id="different-label-assignment-strategies">
<h3>4.3.5.1. Different label assignment strategies<a class="headerlink" href="#different-label-assignment-strategies" title="Permalink to this headline">¶</a></h3>
<p>Different label assignment strategies can be used, corresponding to the
<cite>assign_labels</cite> parameter of <a class="reference internal" href="generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><tt class="xref py py-class docutils literal"><span class="pre">SpectralClustering</span></tt></a>.
The <cite>kmeans</cite> strategie can match finer details of the data, but it can be
more unstable. In particular, unless you control the <cite>random_state</cite>, it
may not be reproducible from run-to-run, as it depends on a random
initialization. On the other hand, the <cite>discretize</cite> strategy is 100%
reproducible, but it tends to create parcels of fairly even and
geometrical shape.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><cite>assign_labels=&#8221;kmeans&#8221;</cite></th>
<th class="head"><cite>assign_labels=&#8221;discretize&#8221;</cite></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference external" href="../auto_examples/cluster/plot_lena_segmentation.html"><img alt="lena_kmeans" src="../_images/plot_lena_segmentation_11.png" style="width: 325.0px; height: 325.0px;" /></a></td>
<td><a class="reference external" href="../auto_examples/cluster/plot_lena_segmentation.html"><img alt="lena_discretize" src="../_images/plot_lena_segmentation_21.png" style="width: 325.0px; height: 325.0px;" /></a></td>
</tr>
</tbody>
</table>
<div class="topic">
<p class="topic-title first">References:</p>
<ul class="simple">
<li><a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323">&#8220;A Tutorial on Spectral Clustering&#8221;</a>
Ulrike von Luxburg, 2007</li>
<li><a class="reference external" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324">&#8220;Normalized cuts and image segmentation&#8221;</a>
Jianbo Shi, Jitendra Malik, 2000</li>
<li><a class="reference external" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.33.1501">&#8220;A Random Walks View of Spectral Segmentation&#8221;</a>
Marina Meila, Jianbo Shi, 2001</li>
<li><a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.8100">&#8220;On Spectral Clustering: Analysis and an algorithm&#8221;</a>
Andrew Y. Ng, Michael I. Jordan, Yair Weiss, 2001</li>
</ul>
</div>
</div>
</div>
<div class="section" id="hierarchical-clustering">
<span id="id6"></span><h2>4.3.6. Hierarchical clustering<a class="headerlink" href="#hierarchical-clustering" title="Permalink to this headline">¶</a></h2>
<p>Hierarchical clustering is a general family of clustering algorithms that
build nested clusters by merging them successively. This hierarchy of
clusters represented as a tree (or dendrogram). The root of the tree is
the unique cluster that gathers all the samples, the leaves being the
clusters with only one sample. See the <a class="reference external" href="http://en.wikipedia.org/wiki/Hierarchical_clustering">Wikipedia page</a> for more
details.</p>
<p>The <a class="reference internal" href="generated/sklearn.cluster.Ward.html#sklearn.cluster.Ward" title="sklearn.cluster.Ward"><tt class="xref py py-class docutils literal"><span class="pre">Ward</span></tt></a> object performs a hierarchical clustering based on
the Ward algorithm, that is a variance-minimizing approach. At each
step, it minimizes the sum of squared differences within all clusters
(inertia criterion).</p>
<p>This algorithm can scale to large number of samples when it is used jointly
with an connectivity matrix, but can be computationally expensive when no
connectivity constraints are added between samples: it considers at each step
all the possible merges.</p>
<div class="section" id="adding-connectivity-constraints">
<h3>4.3.6.1. Adding connectivity constraints<a class="headerlink" href="#adding-connectivity-constraints" title="Permalink to this headline">¶</a></h3>
<p>An interesting aspect of the <a class="reference internal" href="generated/sklearn.cluster.Ward.html#sklearn.cluster.Ward" title="sklearn.cluster.Ward"><tt class="xref py py-class docutils literal"><span class="pre">Ward</span></tt></a> object is that connectivity
constraints can be added to this algorithm (only adjacent clusters can be
merged together), through an connectivity matrix that defines for each
sample the neighboring samples following a given structure of the data. For
instance, in the swiss-roll example below, the connectivity constraints
forbid the merging of points that are not adjacent on the swiss roll, and
thus avoid forming clusters that extend across overlapping folds of the
roll.</p>
<p class="centered">
<strong><a class="reference external image-reference" href="../auto_examples/cluster/plot_ward_structured_vs_unstructured.html"><img alt="unstructured" src="../_images/plot_ward_structured_vs_unstructured_11.png" style="width: 392.0px; height: 294.0px;" /></a>
 <a class="reference external image-reference" href="../auto_examples/cluster/plot_ward_structured_vs_unstructured.html"><img alt="structured" src="../_images/plot_ward_structured_vs_unstructured_21.png" style="width: 392.0px; height: 294.0px;" /></a>
</strong></p><p>The connectivity constraints are imposed via an connectivity matrix: a
scipy sparse matrix that has elements only at the intersection of a row
and a column with indices of the dataset that should be connected. This
matrix can be constructed from a-priori information, for instance if you
wish to cluster web pages, but only merging pages with a link pointing
from one to another. It can also be learned from the data, for instance
using <a class="reference internal" href="generated/sklearn.neighbors.kneighbors_graph.html#sklearn.neighbors.kneighbors_graph" title="sklearn.neighbors.kneighbors_graph"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.neighbors.kneighbors_graph</span></tt></a> to restrict
merging to nearest neighbors as in the <a class="reference internal" href="../auto_examples/cluster/plot_ward_structured_vs_unstructured.html#example-cluster-plot-ward-structured-vs-unstructured-py"><em>swiss roll</em></a> example, or
using <a class="reference internal" href="generated/sklearn.feature_extraction.image.grid_to_graph.html#sklearn.feature_extraction.image.grid_to_graph" title="sklearn.feature_extraction.image.grid_to_graph"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.feature_extraction.image.grid_to_graph</span></tt></a> to
enable only merging of neighboring pixels on an image, as in the
<a class="reference internal" href="../auto_examples/cluster/plot_lena_ward_segmentation.html#example-cluster-plot-lena-ward-segmentation-py"><em>Lena</em></a> example.</p>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_lena_ward_segmentation.html#example-cluster-plot-lena-ward-segmentation-py"><em>A demo of structured Ward hierarchical clustering on Lena image</em></a>: Ward clustering
to split the image of lena in regions.</li>
<li><a class="reference internal" href="../auto_examples/cluster/plot_ward_structured_vs_unstructured.html#example-cluster-plot-ward-structured-vs-unstructured-py"><em>Hierarchical clustering: structured vs unstructured ward</em></a>: Example of
Ward algorithm on a swiss-roll, comparison of structured approaches
versus unstructured approaches.</li>
<li><a class="reference internal" href="../auto_examples/cluster/plot_feature_agglomeration_vs_univariate_selection.html#example-cluster-plot-feature-agglomeration-vs-univariate-selection-py"><em>Feature agglomeration vs. univariate selection</em></a>:
Example of dimensionality reduction with feature agglomeration based on
Ward hierarchical clustering.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="dbscan">
<span id="id7"></span><h2>4.3.7. DBSCAN<a class="headerlink" href="#dbscan" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="generated/sklearn.cluster.DBSCAN.html#sklearn.cluster.DBSCAN" title="sklearn.cluster.DBSCAN"><tt class="xref py py-class docutils literal"><span class="pre">DBSCAN</span></tt></a> algorithm views clusters as areas of high density
separated by areas of low density. Due to this rather generic view, clusters
found by DBSCAN can be any shape, as opposed to k-means which assumes that
clusters are convex shaped. The central component to the DBSCAN is the concept
of <em>core samples</em>, which are samples that are in areas of high density. A
cluster is therefore a set of core samples, each close to each other
(measured by some distance measure)
and a set of non-core samples that are close to a core sample (but are not
themselves core samples). There are two parameters to the algorithm,
<cite>min_samples</cite> and <cite>eps</cite>, which define formally what we mean when we say <em>dense</em>.
A higher <cite>min_samples</cite> or lower <cite>eps</cite> indicate higher density necessary to form
a cluster.</p>
<p>More formally, we define a core sample as being a sample in the dataset such
that there exist <cite>min_samples</cite> other samples within a distance of
<cite>eps</cite>, which are defined as <em>neighbors</em> of the core sample. This tells
us that the core sample is in a dense area of the vector space. A cluster
is a set of core samples, that can be built by recursively by taking a core
sample, finding all of its neighbors that are core samples, finding all of
<em>their</em> neighbors that are core samples, and so on. A cluster also has a
set of non-core samples, which are samples that are neighbors of a core sample
in the cluster but are not themselves core samples. Intuitively, these samples
are on the fringes of a cluster.</p>
<p>Any core sample is part of a cluster, by definition. Further, any cluster has
at least <cite>min_samples</cite> points in it, following the definition of a core
sample. For any sample that is not a core sample, and does have a
distance higher than <cite>eps</cite> to any core sample, it is considered an outlier by
the algorithm.</p>
<p>The algorithm is non-deterministic, however the core samples themselves will
always belong to the same clusters (although the labels themselves may be
different). The non-determinism comes from deciding on which cluster a
non-core sample belongs to. A non-core sample can have a distance lower
than <cite>eps</cite> to two core samples in different classes. Following from the
triangular inequality, those two core samples would be more distant than
<cite>eps</cite> from each other &#8211; else they would be in the same class. The non-core
sample is simply assigned to which ever cluster is generated first, where
the order is determined randomly within the code. Other than the ordering of,
the dataset, the algorithm is deterministic, making the results relatively
stable between iterations on the same data.</p>
<p>In the figure below, the color indicates cluster membership, with large circles
indicating core samples found by the algorithm. Smaller circles are non-core
samples that are still part of a cluster. Moreover, the outliers are indicated
by black points below.</p>
<p class="centered">
<strong><a class="reference external image-reference" href="../auto_examples/cluster/plot_dbscan.html"><img alt="dbscan_results" src="../_images/plot_dbscan_11.png" style="width: 400.0px; height: 300.0px;" /></a>
</strong></p><div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_dbscan.html#example-cluster-plot-dbscan-py"><em>Demo of DBSCAN clustering algorithm</em></a>: Clustering synthetic data with DBSCAN</li>
</ul>
</div>
<div class="topic">
<p class="topic-title first">References:</p>
<ul class="simple">
<li>&#8220;A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases
with Noise&#8221;
Ester, M., H. P. Kriegel, J. Sander, and X. Xu,
In Proceedings of the 2nd International Conference on Knowledge Discovery
and Data Mining, Portland, OR, AAAI Press, pp. 226–231. 1996</li>
</ul>
</div>
</div>
<div class="section" id="clustering-performance-evaluation">
<span id="clustering-evaluation"></span><h2>4.3.8. Clustering performance evaluation<a class="headerlink" href="#clustering-performance-evaluation" title="Permalink to this headline">¶</a></h2>
<p>Evaluating the performance of a clustering algorithm is not as trivial as
counting the number of errors or the precision and recall of a supervised
classification algorithm. In particular any evaluation metric should not
take the absolute values of the cluster labels into account but rather
if this clustering define separations of the data similar to some ground
truth set of classes or satisfying some assumption such that members
belong to the same class are more similar that members of different
classes according to some similarity metric.</p>
<div class="section" id="inertia">
<h3>4.3.8.1. Inertia<a class="headerlink" href="#inertia" title="Permalink to this headline">¶</a></h3>
<div class="section" id="presentation-and-usage">
<h4>4.3.8.1.1. Presentation and usage<a class="headerlink" href="#presentation-and-usage" title="Permalink to this headline">¶</a></h4>
<p>TODO: factorize inertia computation out of kmeans and then write me!</p>
</div>
<div class="section" id="advantages">
<h4>4.3.8.1.2. Advantages<a class="headerlink" href="#advantages" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>No need for the ground truth knowledge of the &#8220;real&#8221; classes.</li>
</ul>
</div>
<div class="section" id="drawbacks">
<h4>4.3.8.1.3. Drawbacks<a class="headerlink" href="#drawbacks" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Inertia makes the assumption that clusters are convex and isotropic
which is not always the case especially of the clusters are manifolds
with weird shapes: for instance inertia is a useless metrics to evaluate
clustering algorithm that tries to identify nested circles on a 2D plane.</li>
<li>Inertia is not a normalized metrics: we just know that lower values are
better and bounded by zero. One potential solution would be to adjust
inertia for random clustering (assuming the number of ground truth classes
is known).</li>
</ul>
</div>
</div>
<div class="section" id="adjusted-rand-index">
<h3>4.3.8.2. Adjusted Rand index<a class="headerlink" href="#adjusted-rand-index" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id8">
<h4>4.3.8.2.1. Presentation and usage<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>Given the knowledge of the ground truth class assignments <tt class="docutils literal"><span class="pre">labels_true</span></tt>
and our clustering algorithm assignments of the same samples
<tt class="docutils literal"><span class="pre">labels_pred</span></tt>, the <strong>adjusted Rand index</strong> is a function that measures
the <strong>similarity</strong> of the two assignments, ignoring permutations and <strong>with
chance normalization</strong>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.24...</span>
</pre></div>
</div>
<p>One can permute 0 and 1 in the predicted labels and rename <cite>2</cite> by <cite>3</cite> and get
the same score:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.24...</span>
</pre></div>
</div>
<p>Furthermore, <a class="reference internal" href="generated/sklearn.metrics.adjusted_rand_score.html#sklearn.metrics.adjusted_rand_score" title="sklearn.metrics.adjusted_rand_score"><tt class="xref py py-func docutils literal"><span class="pre">adjusted_rand_score</span></tt></a> is <strong>symmetric</strong>: swapping the argument
does not change the score. It can thus be used as a <strong>consensus
measure</strong>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_pred</span><span class="p">,</span> <span class="n">labels_true</span><span class="p">)</span>  
<span class="go">0.24...</span>
</pre></div>
</div>
<p>Perfect labeling is scored 1.0:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="n">labels_true</span><span class="p">[:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>Bad (e.g. independent labelings) have negative or close to 0.0 scores:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">-0.12...</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h4>4.3.8.2.2. Advantages<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><strong>Random (uniform) label assignments have a ARI score close to 0.0</strong>
for any value of <tt class="docutils literal"><span class="pre">n_clusters</span></tt> and <tt class="docutils literal"><span class="pre">n_samples</span></tt> (which is not the
case for raw Rand index or the V-measure for instance).</li>
<li><strong>Bounded range [-1, 1]</strong>: negative values are bad (independent
labelings), similar clusterings have a positive ARI, 1.0 is the perfect
match score.</li>
<li><strong>No assumption is made on the cluster structure</strong>: can be used
to compare clustering algorithms such as k-means which assumes isotropic
blob shapes with results of spectral clustering algorithms which can
find cluster with &#8220;folded&#8221; shapes.</li>
</ul>
</div>
<div class="section" id="id10">
<h4>4.3.8.2.3. Drawbacks<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">Contrary to inertia, <strong>ARI requires knowledge of the ground truth
classes</strong> while is almost never available in practice or requires manual
assignment by human annotators (as in the supervised learning setting).</p>
<p>However ARI can also be useful in a purely unsupervised setting as a
building block for a Consensus Index that can be used for clustering
model selection (TODO).</p>
</li>
</ul>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_adjusted_for_chance_measures.html#example-cluster-plot-adjusted-for-chance-measures-py"><em>Adjustment for chance in clustering performance evaluation</em></a>: Analysis of
the impact of the dataset size on the value of clustering measures
for random assignments.</li>
</ul>
</div>
</div>
<div class="section" id="mathematical-formulation">
<h4>4.3.8.2.4. Mathematical formulation<a class="headerlink" href="#mathematical-formulation" title="Permalink to this headline">¶</a></h4>
<p>If C is a ground truth class assignment and K the clustering, let us
define <img class="math" src="../_images/math/c7d457e388298246adb06c587bccd419ea67f7e8.png" alt="a"/> and <img class="math" src="../_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b"/> as:</p>
<ul class="simple">
<li><img class="math" src="../_images/math/c7d457e388298246adb06c587bccd419ea67f7e8.png" alt="a"/>, the number of pairs of elements that are in the same set
in C and in the same set in K</li>
<li><img class="math" src="../_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b"/>, the number of pairs of elements that are in different sets
in C and in different sets in K</li>
</ul>
<p>The raw (unadjusted) Rand index is then given by:</p>
<div class="math">
<p><img src="../_images/math/93b4deaebeb507f949e6831751847bbb484c2e7e.png" alt="\text{RI} = \frac{a + b}{C_2^{n_{samples}}}"/></p>
</div><p>Where <img class="math" src="../_images/math/a2bd98f6f65a6d2993c94ffa0ba00d134e1fc9c8.png" alt="C_2^{n_{samples}}"/> is the total number of possible pairs
in the dataset (without ordering).</p>
<p>However the RI score does not guarantee that random label assignments
will get a value close to zero (esp. if the number of clusters is in
the same order of magnitude as the number of samples).</p>
<p>To counter this effect we can discount the expected RI <img class="math" src="../_images/math/62634a547d50da7d34b580324a5d552a22385287.png" alt="E[\text{RI}]"/> of
random labelings by defining the adjusted Rand index as follows:</p>
<div class="math">
<p><img src="../_images/math/cea8da7bd0f8861d7099f3ecdb9992f1a065a729.png" alt="\text{ARI} = \frac{\text{RI} - E[\text{RI}]}{\max(\text{RI}) - E[\text{RI}]}"/></p>
</div><div class="topic">
<p class="topic-title first">References</p>
<ul class="simple">
<li><a class="reference external" href="http://www.springerlink.com/content/x64124718341j1j0/">Comparing Partitions</a>
L. Hubert and P. Arabie, Journal of Classification 1985</li>
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Rand_index#Adjusted_Rand_index">Wikipedia entry for the adjusted Rand index</a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="mutual-information-based-scores">
<h3>4.3.8.3. Mutual Information based scores<a class="headerlink" href="#mutual-information-based-scores" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id11">
<h4>4.3.8.3.1. Presentation and usage<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>Given the knowledge of the ground truth class assignments <tt class="docutils literal"><span class="pre">labels_true</span></tt> and
our clustering algorithm assignments of the same samples <tt class="docutils literal"><span class="pre">labels_pred</span></tt>, the
<strong>Mutual Information</strong> is a function that measures the <strong>agreement</strong> of the two
assignments, ignoring permutations.  Two different normalized versions of this
measure are available, <strong>Normalized Mutual Information(NMI)</strong> and <strong>Adjusted
Mutual Information(AMI)</strong>. NMI is often used in the literature while AMI was
proposed more recently and is <strong>normalized against chance</strong>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_mutual_info_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.22504...</span>
</pre></div>
</div>
<p>One can permute 0 and 1 in the predicted labels and rename <cite>2</cite> by <cite>3</cite> and get
the same score:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_mutual_info_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.22504...</span>
</pre></div>
</div>
<p>All, <a class="reference internal" href="generated/sklearn.metrics.mutual_info_score.html#sklearn.metrics.mutual_info_score" title="sklearn.metrics.mutual_info_score"><tt class="xref py py-func docutils literal"><span class="pre">mutual_info_score</span></tt></a>, <a class="reference internal" href="generated/sklearn.metrics.adjusted_mutual_info_score.html#sklearn.metrics.adjusted_mutual_info_score" title="sklearn.metrics.adjusted_mutual_info_score"><tt class="xref py py-func docutils literal"><span class="pre">adjusted_mutual_info_score</span></tt></a> and
<a class="reference internal" href="generated/sklearn.metrics.normalized_mutual_info_score.html#sklearn.metrics.normalized_mutual_info_score" title="sklearn.metrics.normalized_mutual_info_score"><tt class="xref py py-func docutils literal"><span class="pre">normalized_mutual_info_score</span></tt></a> are symmetric: swapping the argument does
not change the score. Thus they can be used as a <strong>consensus measure</strong>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_mutual_info_score</span><span class="p">(</span><span class="n">labels_pred</span><span class="p">,</span> <span class="n">labels_true</span><span class="p">)</span>  
<span class="go">0.22504...</span>
</pre></div>
</div>
<p>Perfect labeling is scored 1.0:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="n">labels_true</span><span class="p">[:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_mutual_info_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>
<span class="go">1.0</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">normalized_mutual_info_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>This is not true for <tt class="docutils literal"><span class="pre">mutual_info_score</span></tt>, which is therefore harder to judge:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">mutual_info_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.69...</span>
</pre></div>
</div>
<p>Bad (e.g. independent labelings) have non-positive scores:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_mutual_info_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">-0.10526...</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h4>4.3.8.3.2. Advantages<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><strong>Random (uniform) label assignments have a AMI score close to 0.0</strong>
for any value of <tt class="docutils literal"><span class="pre">n_clusters</span></tt> and <tt class="docutils literal"><span class="pre">n_samples</span></tt> (which is not the
case for raw Mutual Information or the V-measure for instance).</li>
<li><strong>Bounded range [0, 1]</strong>:  Values close to zero indicate two label
assignments that are largely independent, while values close to one
indicate significant agreement. Further, values of exactly 0 indicate
<strong>purely</strong> independent label assignments and a AMI of exactly 1 indicates
that the two label assignments are equal (with or without permutation).</li>
<li><strong>No assumption is made on the cluster structure</strong>: can be used
to compare clustering algorithms such as k-means which assumes isotropic
blob shapes with results of spectral clustering algorithms which can
find cluster with &#8220;folded&#8221; shapes.</li>
</ul>
</div>
<div class="section" id="id13">
<h4>4.3.8.3.3. Drawbacks<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">Contrary to inertia, <strong>MI-based measures require the knowledge
of the ground truth classes</strong> while almost never available in practice or
requires manual assignment by human annotators (as in the supervised learning
setting).</p>
<p>However MI-based measures can also be useful in purely unsupervised setting as a
building block for a Consensus Index that can be used for clustering
model selection.</p>
</li>
<li><p class="first">NMI and MI are not adjusted against chance.</p>
</li>
</ul>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_adjusted_for_chance_measures.html#example-cluster-plot-adjusted-for-chance-measures-py"><em>Adjustment for chance in clustering performance evaluation</em></a>: Analysis of
the impact of the dataset size on the value of clustering measures
for random assignments. This example also includes the Adjusted Rand
Index.</li>
</ul>
</div>
</div>
<div class="section" id="id14">
<h4>4.3.8.3.4. Mathematical formulation<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>Assume two label assignments (of the same N objects), <img class="math" src="../_images/math/e2bbebb3bd73f1ae5c64098ab0244f739abf7ca4.png" alt="U"/> and <img class="math" src="../_images/math/12d58aa29201da09d8e620f8698e3a37547f6b4a.png" alt="V"/>.
Their entropy is the amount of uncertainty for a partition set, defined by:</p>
<div class="math">
<p><img src="../_images/math/424540d5fc2f862c62aa236c5908c4c9f0ab6e34.png" alt="H(U) = \sum_{i=1}^{|U|}P(i)\log(P(i))"/></p>
</div><p>where <img class="math" src="../_images/math/b0ca48026433847d7223830533a412ec40e06853.png" alt="P(i) = |U_i| / N"/> is the probability that an object picked at
random from <img class="math" src="../_images/math/e2bbebb3bd73f1ae5c64098ab0244f739abf7ca4.png" alt="U"/> falls into class <img class="math" src="../_images/math/fb8df2d00f692a5a5ee3e592916d04a5a3e1060b.png" alt="U_i"/>. Likewise for <img class="math" src="../_images/math/12d58aa29201da09d8e620f8698e3a37547f6b4a.png" alt="V"/>:</p>
<div class="math">
<p><img src="../_images/math/47c3f7d77c188974b21c112a8de850fdeb1ff712.png" alt="H(V) = \sum_{j=1}^{|V|}P'(j)\log(P'(j))"/></p>
</div><p>With <img class="math" src="../_images/math/c2317f66dbe391d6366c63c27e0eaecfbc0fc449.png" alt="P'(j) = |V_j| / N"/>. The mutual information (MI) between <img class="math" src="../_images/math/e2bbebb3bd73f1ae5c64098ab0244f739abf7ca4.png" alt="U"/>
and <img class="math" src="../_images/math/12d58aa29201da09d8e620f8698e3a37547f6b4a.png" alt="V"/> is calculated by:</p>
<div class="math">
<p><img src="../_images/math/6d355123a517fe0ab101918ab3fe8b03ae683b2b.png" alt="\text{MI}(U, V) = \sum_{i=1}^{|U|}\sum_{j=1}^{|V|}P(i, j)\log\left(\frac{P(i,j)}{P(i)P'(j)}\right)"/></p>
</div><p>where <img class="math" src="../_images/math/ce8dc5b0e25130c16f0536216e639cd878badd5f.png" alt="P(i, j) = |U_i \cap V_j| / N"/> is the probability that an object
picked at random falls into both classes <img class="math" src="../_images/math/fb8df2d00f692a5a5ee3e592916d04a5a3e1060b.png" alt="U_i"/> and <img class="math" src="../_images/math/6fbba8e6f8bc75af045750f417c9000c07feb8dc.png" alt="V_j"/>.</p>
<p>The normalized mutual information is defined as</p>
<div class="math">
<p><img src="../_images/math/5f35587580d883aea1f892a5449db879c326c497.png" alt="\text{NMI}(U, V) = \frac{\text{MI}(U, V)}{\sqrt{H(U)H(V)}}"/></p>
</div><p>This value of the mutual information and also the normalized variant is not
adjusted for chance and will tend to increase as the number of different labels
(clusters) increases, regardless of the actual amount of &#8220;mutual information&#8221;
between the label assignments.</p>
<p>The expected value for the mutual information can be calculated using the
following equation, from Vinh, Epps, and Bailey, (2009). In this equation,
<img class="math" src="../_images/math/eeb173b280af1a85871f8f0c0ffc0aa3dd3e18ca.png" alt="a_i = |U_i|"/> (the number of elements in <img class="math" src="../_images/math/fb8df2d00f692a5a5ee3e592916d04a5a3e1060b.png" alt="U_i"/>) and
<img class="math" src="../_images/math/f05b8c14c9772aa1d38ce611da94114c47e4572d.png" alt="b_j = |V_j|"/> (the number of elements in <img class="math" src="../_images/math/6fbba8e6f8bc75af045750f417c9000c07feb8dc.png" alt="V_j"/>).</p>
<div class="math">
<p><img src="../_images/math/a2b6760e3538878467adc1da0f03e28bd67c4a85.png" alt="E[\text{MI}(U,V)]=\sum_{i=1}^|U| \sum_{j=1}^|V| \sum_{n_{ij}=(a_i+b_j-N)^+
}^{\min(a_i, b_j)} \frac{n_{ij}}{N}\log \left( \frac{ N.n_{ij}}{a_i b_j}\right)
\frac{a_i!b_j!(N-a_i)!(N-b_j)!}{N!n_{ij}!(a_i-n_{ij})!(b_j-n_{ij})!
(N-a_i-b_j+n_{ij})!}"/></p>
</div><p>Using the expected value, the adjusted mutual information can then be
calculated using a similar form to that of the adjusted Rand index:</p>
<div class="math">
<p><img src="../_images/math/04e7e8db618ff16863d1520c81bbd8e6620565d1.png" alt="\text{AMI} = \frac{\text{MI} - E[\text{MI}]}{\max(H(U), H(V)) - E[\text{MI}]}"/></p>
</div><div class="topic">
<p class="topic-title first">References</p>
<ul class="simple">
<li>Strehl, Alexander, and Joydeep Ghosh (2002). &#8220;Cluster ensembles – a
knowledge reuse framework for combining multiple partitions&#8221;. Journal of
Machine Learning Research 3: 583–617. doi:10.1162/153244303321897735</li>
<li>Vinh, Epps, and Bailey, (2009). &#8220;Information theoretic measures
for clusterings comparison&#8221;. Proceedings of the 26th Annual International
Conference on Machine Learning - ICML &#8216;09.
doi:10.1145/1553374.1553511. ISBN 9781605585161.</li>
<li>Vinh, Epps, and Bailey, (2010). Information Theoretic Measures for
Clusterings Comparison: Variants, Properties, Normalization and
Correction for Chance}, JMLR
<a class="reference external" href="http://jmlr.csail.mit.edu/papers/volume11/vinh10a/vinh10a.pdf">http://jmlr.csail.mit.edu/papers/volume11/vinh10a/vinh10a.pdf</a></li>
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Mutual_Information">Wikipedia entry for the (normalized) Mutual Information</a></li>
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Adjusted_Mutual_Information">Wikipedia entry for the Adjusted Mutual Information</a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="homogeneity-completeness-and-v-measure">
<h3>4.3.8.4. Homogeneity, completeness and V-measure<a class="headerlink" href="#homogeneity-completeness-and-v-measure" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id15">
<h4>4.3.8.4.1. Presentation and usage<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>Given the knowledge of the ground truth class assignments of the samples,
it is possible to define some intuitive metric using conditional entropy
analysis.</p>
<p>In particular Rosenberg and Hirschberg (2007) define the following two
desirable objectives for any cluster assignment:</p>
<ul class="simple">
<li><strong>homogeneity</strong>: each cluster contains only members of a single class.</li>
<li><strong>completeness</strong>: all members of a given class are assigned to the same
cluster.</li>
</ul>
<p>We can turn those concept as scores <a class="reference internal" href="generated/sklearn.metrics.homogeneity_score.html#sklearn.metrics.homogeneity_score" title="sklearn.metrics.homogeneity_score"><tt class="xref py py-func docutils literal"><span class="pre">homogeneity_score</span></tt></a> and
<a class="reference internal" href="generated/sklearn.metrics.completeness_score.html#sklearn.metrics.completeness_score" title="sklearn.metrics.completeness_score"><tt class="xref py py-func docutils literal"><span class="pre">completeness_score</span></tt></a>. Both are bounded below by 0.0 and above by
1.0 (higher is better):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">homogeneity_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.66...</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">completeness_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span> 
<span class="go">0.42...</span>
</pre></div>
</div>
<p>Their harmonic mean called <strong>V-measure</strong> is computed by
<a class="reference internal" href="generated/sklearn.metrics.v_measure_score.html#sklearn.metrics.v_measure_score" title="sklearn.metrics.v_measure_score"><tt class="xref py py-func docutils literal"><span class="pre">v_measure_score</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">v_measure_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>    
<span class="go">0.51...</span>
</pre></div>
</div>
<p>The V-measure is actually equivalent to the mutual information (NMI)
discussed above normalized by the sum of the label entropies <a class="reference internal" href="#b2011">[B2011]</a>.</p>
<p>Homogeneity, completensess and V-measure can be computed at once using
<a class="reference internal" href="generated/sklearn.metrics.homogeneity_completeness_v_measure.html#sklearn.metrics.homogeneity_completeness_v_measure" title="sklearn.metrics.homogeneity_completeness_v_measure"><tt class="xref py py-func docutils literal"><span class="pre">homogeneity_completeness_v_measure</span></tt></a> as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">homogeneity_completeness_v_measure</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>
<span class="gp">... </span>                                                     
<span class="go">(0.66..., 0.42..., 0.51...)</span>
</pre></div>
</div>
<p>The following clustering assignment is slighlty better, since it is
homogeneous but not complete:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">homogeneity_completeness_v_measure</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>
<span class="gp">... </span>                                                     
<span class="go">(1.0, 0.68..., 0.81...)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><a class="reference internal" href="generated/sklearn.metrics.v_measure_score.html#sklearn.metrics.v_measure_score" title="sklearn.metrics.v_measure_score"><tt class="xref py py-func docutils literal"><span class="pre">v_measure_score</span></tt></a> is <strong>symmetric</strong>: it can be used to evaluate
the <strong>agreement</strong> of two independent assignments on the same dataset.</p>
<p>This is not the case for <a class="reference internal" href="generated/sklearn.metrics.completeness_score.html#sklearn.metrics.completeness_score" title="sklearn.metrics.completeness_score"><tt class="xref py py-func docutils literal"><span class="pre">completeness_score</span></tt></a> and
<a class="reference internal" href="generated/sklearn.metrics.homogeneity_score.html#sklearn.metrics.homogeneity_score" title="sklearn.metrics.homogeneity_score"><tt class="xref py py-func docutils literal"><span class="pre">homogeneity_score</span></tt></a>: both are bound by the relationship:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">homogeneity_score</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">completeness_score</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id17">
<h4>4.3.8.4.2. Advantages<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><strong>Bounded scores</strong>: 0.0 is as bad as it can be, 1.0 is a perfect score</li>
<li>Intuitive interpretation: clustering with bad V-measure can be
<strong>qualitatively analyzed in terms of homogeneity and completeness</strong>
to better feel what &#8216;kind&#8217; of mistakes is done by the assigmenent.</li>
<li><strong>No assumption is made on the cluster structure</strong>: can be used
to compare clustering algorithms such as k-means which assumes isotropic
blob shapes with results of spectral clustering algorithms which can
find cluster with &#8220;folded&#8221; shapes.</li>
</ul>
</div>
<div class="section" id="id18">
<h4>4.3.8.4.3. Drawbacks<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">The previously introduced metrics are <strong>not normalized w.r.t. random
labeling</strong>: this means that depending on the number of samples,
clusters and ground truth classes, a completely random labeling will
not always yield the same values for homogeneity, completeness and
hence v-measure. In particular <strong>random labeling won&#8217;t yield zero
scores especially when the number of clusters is large</strong>.</p>
<p>This problem can safely be ignored when the number of samples is more
than a thousand and the number of clusters is less than 10. <strong>For
smaller sample sizes or larger number of clusters it is safer to use
an adjusted index such as the Adjusted Rand Index (ARI)</strong>.</p>
</li>
</ul>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/cluster/plot_adjusted_for_chance_measures.html"><img alt="../_images/plot_adjusted_for_chance_measures_11.png" src="../_images/plot_adjusted_for_chance_measures_11.png" style="width: 800.0px; height: 600.0px;" /></a>
</div>
<ul class="simple">
<li>These metrics <strong>require the knowledge of the ground truth classes</strong> while
almost never available in practice or requires manual assignment by
human annotators (as in the supervised learning setting).</li>
</ul>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_adjusted_for_chance_measures.html#example-cluster-plot-adjusted-for-chance-measures-py"><em>Adjustment for chance in clustering performance evaluation</em></a>: Analysis of
the impact of the dataset size on the value of clustering measures
for random assignments.</li>
</ul>
</div>
</div>
<div class="section" id="id19">
<h4>4.3.8.4.4. Mathematical formulation<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<p>Homogeneity and completeness scores are formally given by:</p>
<div class="math">
<p><img src="../_images/math/53926d0bd09a86152fa4b7b14d8f5a684dda7853.png" alt="h = 1 - \frac{H(C|K)}{H(C)}"/></p>
</div><div class="math">
<p><img src="../_images/math/55975ea26cf392b41c918c2dcef3c36fe9886af3.png" alt="c = 1 - \frac{H(K|C)}{H(K)}"/></p>
</div><p>where <img class="math" src="../_images/math/976fac5556d77751e82233a8a296f4efbef5f060.png" alt="H(C|K)"/> is the <strong>conditional entropy of the classes given
the cluster assignments</strong> and is given by:</p>
<div class="math">
<p><img src="../_images/math/24b6947ba901314d82388a0d926ee619e5d2cb67.png" alt="H(C|K) = - \sum_{c=1}^{|C|} \sum_{k=1}^{|K|} \frac{n_{c,k}}{n}
\cdot \log\left(\frac{n_{c,k}}{n_k}\right)"/></p>
</div><p>and <img class="math" src="../_images/math/3f2e37b0747cc94e5dd4c29c36a54b580ce0e077.png" alt="H(C)"/> is the <strong>entropy of the classes</strong> and is given by:</p>
<div class="math">
<p><img src="../_images/math/058f2e56d641cdc1f98f1e42af46e958f9e6b9a8.png" alt="H(C) = - \sum_{c=1}^{|C|} \frac{n_c}{n} \cdot \log\left(\frac{n_c}{n}\right)"/></p>
</div><p>with <img class="math" src="../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n"/> the total number of samples, <img class="math" src="../_images/math/133f71ae4a4a8ad5cbe8e7b0ae7c2e4ec7fcbb97.png" alt="n_c"/> and <img class="math" src="../_images/math/a65540896dbfc5605e7767c8cacaa9d429e14d11.png" alt="n_k"/>
the number of samples respectively belonging to class <img class="math" src="../_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> and
cluster <img class="math" src="../_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k"/>, and finally <img class="math" src="../_images/math/07bb9b71a0a68471a5149655e023d5369a57c524.png" alt="n_{c,k}"/> the number of samples
from class <img class="math" src="../_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> assigned to cluster <img class="math" src="../_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k"/>.</p>
<p>The <strong>conditional entropy of clusters given class</strong> <img class="math" src="../_images/math/aab5ef760fd4ece3731183410278f75a2af93f4e.png" alt="H(K|C)"/> and the
<strong>entropy of clusters</strong> <img class="math" src="../_images/math/a6ae3434e3ba9eb79a2c9c94afb899cd3fda6e3b.png" alt="H(K)"/> are defined in a symmetric manner.</p>
<p>Rosenberg and Hirschberg further define <strong>V-measure</strong> as the <strong>harmonic
mean of homogeneity and completeness</strong>:</p>
<div class="math">
<p><img src="../_images/math/f8225cbdc0fe4975afb9c61b32ba0c9a9b78fa54.png" alt="v = 2 \cdot \frac{h \cdot c}{h + c}"/></p>
</div><div class="topic">
<p class="topic-title first">References</p>
<table class="docutils citation" frame="void" id="rh2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[RH2007]</td><td><a class="reference external" href="http://acl.ldc.upenn.edu/D/D07/D07-1043.pdf">V-Measure: A conditional entropy-based external cluster evaluation
measure</a>
Andrew Rosenberg and Julia Hirschberg, 2007</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="b2011" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[B2011]</a></td><td><a class="reference external" href="http://www.cs.columbia.edu/~hila/hila-thesis-distributed.pdf">Identication and Characterization of Events in Social Media</a>, Hila
Becker, PhD Thesis.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="silhouette-coefficient">
<span id="id20"></span><h3>4.3.8.5. Silhouette Coefficient<a class="headerlink" href="#silhouette-coefficient" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id21">
<h4>4.3.8.5.1. Presentation and usage<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<p>If the ground truth labels are not known, evaluation must be performed using
the model itself. The Silhouette Coefficient
(<a class="reference internal" href="generated/sklearn.metrics.silhouette_score.html#sklearn.metrics.silhouette_score" title="sklearn.metrics.silhouette_score"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.metrics.silhouette_score</span></tt></a>)
is an example of such an evaluation, where a
higher Silhouette Coefficient score relates to a model with better defined
clusters. The Silhouette Coefficient is defined for each sample and is composed
of two scores:</p>
<ul class="simple">
<li><strong>a</strong>: The mean distance between a sample and all other points in the same
class.</li>
<li><strong>b</strong>: The mean distance between a sample and all other points in the <em>next
nearest cluster</em>.</li>
</ul>
<p>The Silhoeutte Coefficient <em>s</em> for a single sample is then given as:</p>
<div class="math">
<p><img src="../_images/math/ca8a912edece0f32d9793b84c05636d34328590a.png" alt="s = \frac{b - a}{max(a, b)}"/></p>
</div><p>The Silhouette Coefficient for a set of samples is given as the mean of the
Silhouette Coefficient for each sample.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">pairwise_distances</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_iris</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">target</span>
</pre></div>
</div>
<p>In normal usage, the Silhouette Coefficient is applied to the results of a
cluster analysis.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kmeans_model</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">kmeans_model</span><span class="o">.</span><span class="n">labels_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">silhouette_score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s">&#39;euclidean&#39;</span><span class="p">)</span>
<span class="gp">... </span>                                                     
<span class="go">0.55...</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">References</p>
<ul class="simple">
<li>Peter J. Rousseeuw (1987). &#8220;Silhouettes: a Graphical Aid to the
Interpretation and Validation of Cluster Analysis&#8221;. Computational
and Applied Mathematics 20: 53–65. doi:10.1016/0377-0427(87)90125-7.</li>
</ul>
</div>
</div>
<div class="section" id="id22">
<h4>4.3.8.5.2. Advantages<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>The score is bounded between -1 for incorrect clustering and +1 for highly
dense clustering. Scores around zero indicate overlapping clusters.</li>
<li>The score is higher when clusters are dense and well separated, which relates
to a standard concept of a cluster.</li>
</ul>
</div>
<div class="section" id="id23">
<h4>4.3.8.5.3. Drawbacks<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>The Silhouette Coefficient is generally higher for convex clusters than other
concepts of clusters, such as density based clusters like those obtained
through DBSCAN.</li>
</ul>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer">
        &copy; 2010–2013, scikit-learn developers (BSD License).
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3. Design by <a href="http://desgrana.es">Desgrana</a>.
    <span style="padding-left: 5ex;">
    <a href="../_sources/modules/clustering.txt"
	    rel="nofollow">Show this page source</a>
    </span>
    </div>
     <div class="rel">
    
    <div class="buttonPrevious">
      <a href="manifold.html">
        Previous
      </a>
    </div>
    <div class="buttonNext">
      <a href="decomposition.html">
        Next
      </a>
    </div>
    
     </div>
     <script type="text/javascript">
       $("div.buttonNext, div.buttonPrevious").hover(
           function () {
               $(this).css('background-color', '#FF9C34');
           },
           function () {
               $(this).css('background-color', '#A7D6E2');
           }
       );
       var bodywrapper = $('.bodywrapper');
   	var sidebarbutton = $('#sidebarbutton');
        sidebarbutton.css({
	    'height': '900px'
       });
     </script>
  </body>
</html>