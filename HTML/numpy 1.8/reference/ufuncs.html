
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>Universal functions (ufunc) &mdash; NumPy v1.8 Manual</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.8.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/js/jquery.min.js"></script>
    <script type="text/javascript" src="../_static/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../about.html" >
    <link rel="top" title="NumPy v1.8 Manual" href="../index.html" >
    <link rel="up" title="NumPy Reference" href="index.html" >
    <link rel="next" title="numpy.setbufsize" href="generated/numpy.setbufsize.html" >
    <link rel="prev" title="Datetimes and Timedeltas" href="arrays.datetime.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        
        <li class="active"><a href="../index.html">NumPy v1.8 Manual</a></li>
        

          <li class="active"><a href="index.html" accesskey="U">NumPy Reference</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="generated/numpy.setbufsize.html" title="numpy.setbufsize"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="arrays.datetime.html" title="Datetimes and Timedeltas"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Universal functions (<tt class="docutils literal"><span class="pre">ufunc</span></tt>)</a><ul>
<li><a class="reference internal" href="#broadcasting">Broadcasting</a></li>
<li><a class="reference internal" href="#output-type-determination">Output type determination</a></li>
<li><a class="reference internal" href="#use-of-internal-buffers">Use of internal buffers</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#error-handling">Error handling</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#casting-rules">Casting Rules</a></li>
<li><a class="reference internal" href="#ufunc"><tt class="docutils literal"><span class="pre">ufunc</span></tt></a><ul>
<li><a class="reference internal" href="#optional-keyword-arguments">Optional keyword arguments</a></li>
<li><a class="reference internal" href="#attributes">Attributes</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#methods">Methods</a><ul>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#available-ufuncs">Available ufuncs</a><ul>
<li><a class="reference internal" href="#math-operations">Math operations</a></li>
<li><a class="reference internal" href="#trigonometric-functions">Trigonometric functions</a></li>
<li><a class="reference internal" href="#bit-twiddling-functions">Bit-twiddling functions</a></li>
<li><a class="reference internal" href="#comparison-functions">Comparison functions</a></li>
<li><a class="reference internal" href="#floating-functions">Floating functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="arrays.datetime.html"
                        title="previous chapter">Datetimes and Timedeltas</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="generated/numpy.setbufsize.html"
                        title="next chapter">numpy.setbufsize</a></p>


        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="universal-functions-ufunc">
<span id="ufuncs"></span><h1>Universal functions (<tt class="xref py py-class docutils literal"><span class="pre">ufunc</span></tt>)<a class="headerlink" href="#universal-functions-ufunc" title="Permalink to this headline">¶</a></h1>
<p>A universal function (or <a class="reference internal" href="../glossary.html#term-ufunc"><em class="xref std std-term">ufunc</em></a> for short) is a function that
operates on <a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><tt class="xref py py-class docutils literal"><span class="pre">ndarrays</span></tt></a> in an element-by-element fashion,
supporting <a class="reference internal" href="#ufuncs-broadcasting"><em>array broadcasting</em></a>, <a class="reference internal" href="#ufuncs-casting"><em>type
casting</em></a>, and several other standard features. That
is, a ufunc is a &#8220;<em class="xref std std-term">vectorized</em>&#8221; wrapper for a function that
takes a fixed number of scalar inputs and produces a fixed number of
scalar outputs.</p>
<p>In Numpy, universal functions are instances of the
<tt class="xref py py-class docutils literal"><span class="pre">numpy.ufunc</span></tt> class. Many of the built-in functions are
implemented in compiled C code, but <tt class="xref py py-class docutils literal"><span class="pre">ufunc</span></tt> instances can also
be produced using the <a class="reference internal" href="generated/numpy.frompyfunc.html#numpy.frompyfunc" title="numpy.frompyfunc"><tt class="xref py py-func docutils literal"><span class="pre">frompyfunc</span></tt></a> factory function.</p>
<div class="section" id="broadcasting">
<span id="ufuncs-broadcasting"></span><h2>Broadcasting<a class="headerlink" href="#broadcasting" title="Permalink to this headline">¶</a></h2>
<p id="index-0">Each universal function takes array inputs and produces array outputs
by performing the core function element-wise on the inputs. Standard
broadcasting rules are applied so that inputs not sharing exactly the
same shapes can still be usefully operated on. Broadcasting can be
understood by four rules:</p>
<ol class="arabic simple">
<li>All input arrays with <a class="reference internal" href="generated/numpy.ndarray.ndim.html#numpy.ndarray.ndim" title="numpy.ndarray.ndim"><tt class="xref py py-attr docutils literal"><span class="pre">ndim</span></tt></a> smaller than the
input array of largest <a class="reference internal" href="generated/numpy.ndarray.ndim.html#numpy.ndarray.ndim" title="numpy.ndarray.ndim"><tt class="xref py py-attr docutils literal"><span class="pre">ndim</span></tt></a>, have 1&#8217;s
prepended to their shapes.</li>
<li>The size in each dimension of the output shape is the maximum of all
the input sizes in that dimension.</li>
<li>An input can be used in the calculation if its size in a particular
dimension either matches the output size in that dimension, or has
value exactly 1.</li>
<li>If an input has a dimension size of 1 in its shape, the first data
entry in that dimension will be used for all calculations along
that dimension. In other words, the stepping machinery of the
<a class="reference internal" href="../glossary.html#term-ufunc"><em class="xref std std-term">ufunc</em></a> will simply not step along that dimension (the
<em class="xref std std-term">stride</em> will be 0 for that dimension).</li>
</ol>
<p>Broadcasting is used throughout NumPy to decide how to handle
disparately shaped arrays; for example, all arithmetic operations (<tt class="docutils literal"><span class="pre">+</span></tt>,
<tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, ...) between <a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><tt class="xref py py-class docutils literal"><span class="pre">ndarrays</span></tt></a> broadcast the
arrays before operation.</p>
<span class="target" id="arrays-broadcasting-broadcastable"></span><p id="index-1">A set of arrays is called &#8220;<em class="xref std std-term">broadcastable</em>&#8221; to the same shape if
the above rules produce a valid result, <em>i.e.</em>, one of the following
is true:</p>
<ol class="arabic simple">
<li>The arrays all have exactly the same shape.</li>
<li>The arrays all have the same number of dimensions and the length of
each dimensions is either a common length or 1.</li>
<li>The arrays that have too few dimensions can have their shapes prepended
with a dimension of length 1 to satisfy property 2.</li>
</ol>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<p>If <tt class="docutils literal"><span class="pre">a.shape</span></tt> is (5,1), <tt class="docutils literal"><span class="pre">b.shape</span></tt> is (1,6), <tt class="docutils literal"><span class="pre">c.shape</span></tt> is (6,)
and <tt class="docutils literal"><span class="pre">d.shape</span></tt> is () so that <em>d</em> is a scalar, then <em>a</em>, <em>b</em>, <em>c</em>,
and <em>d</em> are all broadcastable to dimension (5,6); and</p>
<ul class="last simple">
<li><em>a</em> acts like a (5,6) array where <tt class="docutils literal"><span class="pre">a[:,0]</span></tt> is broadcast to the other
columns,</li>
<li><em>b</em> acts like a (5,6) array where <tt class="docutils literal"><span class="pre">b[0,:]</span></tt> is broadcast
to the other rows,</li>
<li><em>c</em> acts like a (1,6) array and therefore like a (5,6) array
where <tt class="docutils literal"><span class="pre">c[:]</span></tt> is broadcast to every row, and finally,</li>
<li><em>d</em> acts like a (5,6) array where the single value is repeated.</li>
</ul>
</div>
</div>
<div class="section" id="output-type-determination">
<span id="ufuncs-output-type"></span><h2>Output type determination<a class="headerlink" href="#output-type-determination" title="Permalink to this headline">¶</a></h2>
<p>The output of the ufunc (and its methods) is not necessarily an
<a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><tt class="xref py py-class docutils literal"><span class="pre">ndarray</span></tt></a>, if all input arguments are not <a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><tt class="xref py py-class docutils literal"><span class="pre">ndarrays</span></tt></a>.</p>
<p>All output arrays will be passed to the <a class="reference internal" href="arrays.classes.html#numpy.__array_prepare__" title="numpy.__array_prepare__"><tt class="xref py py-obj docutils literal"><span class="pre">__array_prepare__</span></tt></a> and
<a class="reference internal" href="arrays.classes.html#numpy.__array_wrap__" title="numpy.__array_wrap__"><tt class="xref py py-obj docutils literal"><span class="pre">__array_wrap__</span></tt></a> methods of the input (besides
<a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><tt class="xref py py-class docutils literal"><span class="pre">ndarrays</span></tt></a>, and scalars) that defines it <strong>and</strong> has
the highest <a class="reference internal" href="arrays.classes.html#numpy.__array_priority__" title="numpy.__array_priority__"><tt class="xref py py-obj docutils literal"><span class="pre">__array_priority__</span></tt></a> of any other input to the
universal function. The default <a class="reference internal" href="arrays.classes.html#numpy.__array_priority__" title="numpy.__array_priority__"><tt class="xref py py-obj docutils literal"><span class="pre">__array_priority__</span></tt></a> of the
ndarray is 0.0, and the default <a class="reference internal" href="arrays.classes.html#numpy.__array_priority__" title="numpy.__array_priority__"><tt class="xref py py-obj docutils literal"><span class="pre">__array_priority__</span></tt></a> of a subtype
is 1.0. Matrices have <a class="reference internal" href="arrays.classes.html#numpy.__array_priority__" title="numpy.__array_priority__"><tt class="xref py py-obj docutils literal"><span class="pre">__array_priority__</span></tt></a> equal to 10.0.</p>
<p>All ufuncs can also take output arguments. If necessary, output will
be cast to the data-type(s) of the provided output array(s). If a class
with an <a class="reference internal" href="arrays.classes.html#numpy.__array__" title="numpy.__array__"><tt class="xref py py-obj docutils literal"><span class="pre">__array__</span></tt></a> method is used for the output, results will be
written to the object returned by <a class="reference internal" href="arrays.classes.html#numpy.__array__" title="numpy.__array__"><tt class="xref py py-obj docutils literal"><span class="pre">__array__</span></tt></a>. Then, if the class
also has an <a class="reference internal" href="arrays.classes.html#numpy.__array_prepare__" title="numpy.__array_prepare__"><tt class="xref py py-obj docutils literal"><span class="pre">__array_prepare__</span></tt></a> method, it is called so metadata
may be determined based on the context of the ufunc (the context
consisting of the ufunc itself, the arguments passed to the ufunc, and
the ufunc domain.) The array object returned by
<a class="reference internal" href="arrays.classes.html#numpy.__array_prepare__" title="numpy.__array_prepare__"><tt class="xref py py-obj docutils literal"><span class="pre">__array_prepare__</span></tt></a> is passed to the ufunc for computation.
Finally, if the class also has an <a class="reference internal" href="arrays.classes.html#numpy.__array_wrap__" title="numpy.__array_wrap__"><tt class="xref py py-obj docutils literal"><span class="pre">__array_wrap__</span></tt></a> method, the returned
<a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><tt class="xref py py-class docutils literal"><span class="pre">ndarray</span></tt></a> result will be passed to that method just before
passing control back to the caller.</p>
</div>
<div class="section" id="use-of-internal-buffers">
<h2>Use of internal buffers<a class="headerlink" href="#use-of-internal-buffers" title="Permalink to this headline">¶</a></h2>
<p id="index-2">Internally, buffers are used for misaligned data, swapped data, and
data that has to be converted from one data type to another. The size
of internal buffers is settable on a per-thread basis. There can
be up to <img class="math" src="../_images/math/1a57df21c894ace4d54b3dd7ce396a0ec73fcb21.png" alt="2 (n_{\mathrm{inputs}} + n_{\mathrm{outputs}})" style="vertical-align: -4px"/>
buffers of the specified size created to handle the data from all the
inputs and outputs of a ufunc. The default size of a buffer is
10,000 elements. Whenever buffer-based calculation would be needed,
but all input arrays are smaller than the buffer size, those
misbehaved or incorrectly-typed arrays will be copied before the
calculation proceeds. Adjusting the size of the buffer may therefore
alter the speed at which ufunc calculations of various sorts are
completed. A simple interface for setting this variable is accessible
using the function</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.setbufsize.html#numpy.setbufsize" title="numpy.setbufsize"><tt class="xref py py-obj docutils literal"><span class="pre">setbufsize</span></tt></a>(size)</td>
<td>Set the size of the buffer used in ufuncs.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="error-handling">
<h2>Error handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h2>
<p id="index-3">Universal functions can trip special floating-point status registers
in your hardware (such as divide-by-zero). If available on your
platform, these registers will be regularly checked during
calculation. Error handling is controlled on a per-thread basis,
and can be configured using the functions</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.seterr.html#numpy.seterr" title="numpy.seterr"><tt class="xref py py-obj docutils literal"><span class="pre">seterr</span></tt></a>([all,&nbsp;divide,&nbsp;over,&nbsp;under,&nbsp;invalid])</td>
<td>Set how floating-point errors are handled.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.seterrcall.html#numpy.seterrcall" title="numpy.seterrcall"><tt class="xref py py-obj docutils literal"><span class="pre">seterrcall</span></tt></a>(func)</td>
<td>Set the floating-point error callback function or log object.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="casting-rules">
<span id="ufuncs-casting"></span><h2>Casting Rules<a class="headerlink" href="#casting-rules" title="Permalink to this headline">¶</a></h2>
<div class="admonition note" id="index-4">
<p class="first admonition-title">Note</p>
<p class="last">In NumPy 1.6.0, a type promotion API was created to encapsulate the
mechansim for determining output types. See the functions
<a class="reference internal" href="generated/numpy.result_type.html#numpy.result_type" title="numpy.result_type"><tt class="xref py py-func docutils literal"><span class="pre">result_type</span></tt></a>, <a class="reference internal" href="generated/numpy.promote_types.html#numpy.promote_types" title="numpy.promote_types"><tt class="xref py py-func docutils literal"><span class="pre">promote_types</span></tt></a>, and
<a class="reference internal" href="generated/numpy.min_scalar_type.html#numpy.min_scalar_type" title="numpy.min_scalar_type"><tt class="xref py py-func docutils literal"><span class="pre">min_scalar_type</span></tt></a> for more details.</p>
</div>
<p>At the core of every ufunc is a one-dimensional strided loop that
implements the actual function for a specific type combination. When a
ufunc is created, it is given a static list of inner loops and a
corresponding list of type signatures over which the ufunc operates.
The ufunc machinery uses this list to determine which inner loop to
use for a particular case. You can inspect the <a class="reference internal" href="generated/numpy.ufunc.types.html#numpy.ufunc.types" title="numpy.ufunc.types"><tt class="xref py py-attr docutils literal"><span class="pre">.types</span></tt></a> attribute for a particular ufunc to see which type
combinations have a defined inner loop and which output type they
produce (<a class="reference internal" href="arrays.scalars.html#arrays-scalars-character-codes"><em>character codes</em></a> are used
in said output for brevity).</p>
<p>Casting must be done on one or more of the inputs whenever the ufunc
does not have a core loop implementation for the input types provided.
If an implementation for the input types cannot be found, then the
algorithm searches for an implementation with a type signature to
which all of the inputs can be cast &#8220;safely.&#8221; The first one it finds
in its internal list of loops is selected and performed, after all
necessary type casting. Recall that internal copies during ufuncs (even
for casting) are limited to the size of an internal buffer (which is user
settable).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Universal functions in NumPy are flexible enough to have mixed type
signatures. Thus, for example, a universal function could be defined
that works with floating-point and integer values. See <a class="reference internal" href="generated/numpy.ldexp.html#numpy.ldexp" title="numpy.ldexp"><tt class="xref py py-func docutils literal"><span class="pre">ldexp</span></tt></a>
for an example.</p>
</div>
<p>By the above description, the casting rules are essentially
implemented by the question of when a data type can be cast &#8220;safely&#8221;
to another data type. The answer to this question can be determined in
Python with a function call: <a class="reference internal" href="generated/numpy.can_cast.html#numpy.can_cast" title="numpy.can_cast"><tt class="xref py py-func docutils literal"><span class="pre">can_cast(fromtype,</span> <span class="pre">totype)</span></tt></a>. The Figure below shows the results of this call for
the 24 internally supported types on the author&#8217;s 64-bit system. You
can generate this table for your system with the code given in the Figure.</p>
<div class="admonition-figure admonition">
<p class="first admonition-title">Figure</p>
<p>Code segment showing the &#8220;can cast safely&#8221; table for a 32-bit system.</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_table</span><span class="p">(</span><span class="n">ntypes</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&#39;X&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">ntypes</span><span class="p">:</span> <span class="k">print</span> <span class="n">char</span><span class="p">,</span>
<span class="gp">... </span>    <span class="k">print</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ntypes</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span> <span class="n">row</span><span class="p">,</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">ntypes</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">print</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)),</span>
<span class="gp">... </span>        <span class="k">print</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_table</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">typecodes</span><span class="p">[</span><span class="s">&#39;All&#39;</span><span class="p">])</span>
<span class="go">X ? b h i l q p B H I L Q P e f d g F D G S U V O M m</span>
<span class="go">? 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span>
<span class="go">b 0 1 1 1 1 1 1 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0</span>
<span class="go">h 0 0 1 1 1 1 1 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0</span>
<span class="go">i 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 1 1 0 1 1 1 1 1 1 0 0</span>
<span class="go">l 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 1 1 0 1 1 1 1 1 1 0 0</span>
<span class="go">q 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 1 1 0 1 1 1 1 1 1 0 0</span>
<span class="go">p 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 1 1 0 1 1 1 1 1 1 0 0</span>
<span class="go">B 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0</span>
<span class="go">H 0 0 0 1 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 0 0</span>
<span class="go">I 0 0 0 0 1 1 1 0 0 1 1 1 1 0 0 1 1 0 1 1 1 1 1 1 0 0</span>
<span class="go">L 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 0 1 1 1 1 1 1 0 0</span>
<span class="go">Q 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 0 1 1 1 1 1 1 0 0</span>
<span class="go">P 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 0 1 1 1 1 1 1 0 0</span>
<span class="go">e 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0</span>
<span class="go">f 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0</span>
<span class="go">d 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 1 1 1 1 1 0 0</span>
<span class="go">g 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 1 1 1 0 0</span>
<span class="go">F 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0</span>
<span class="go">D 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0</span>
<span class="go">G 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0</span>
<span class="go">S 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0</span>
<span class="go">U 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0</span>
<span class="go">V 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0</span>
<span class="go">O 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0</span>
<span class="go">M 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0</span>
<span class="go">m 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1</span>
</pre></div>
</div>
</div>
<p>You should note that, while included in the table for completeness,
the &#8216;S&#8217;, &#8216;U&#8217;, and &#8216;V&#8217; types cannot be operated on by ufuncs. Also,
note that on a 32-bit system the integer types may have different
sizes, resulting in a slightly altered table.</p>
<p>Mixed scalar-array operations use a different set of casting rules
that ensure that a scalar cannot &#8220;upcast&#8221; an array unless the scalar is
of a fundamentally different kind of data (<em>i.e.</em>, under a different
hierarchy in the data-type hierarchy) than the array.  This rule
enables you to use scalar constants in your code (which, as Python
types, are interpreted accordingly in ufuncs) without worrying about
whether the precision of the scalar constant will cause upcasting on
your large (small precision) array.</p>
</div>
<div class="section" id="ufunc">
<h2><tt class="xref py py-class docutils literal"><span class="pre">ufunc</span></tt><a class="headerlink" href="#ufunc" title="Permalink to this headline">¶</a></h2>
<div class="section" id="optional-keyword-arguments">
<h3>Optional keyword arguments<a class="headerlink" href="#optional-keyword-arguments" title="Permalink to this headline">¶</a></h3>
<p>All ufuncs take optional keyword arguments. Most of these represent
advanced usage and will not typically be used.</p>
<p id="index-5"><em>out</em></p>
<blockquote>
<div><p class="versionadded">
<span class="versionmodified">New in version 1.6.</span></p>
<p>The first output can provided as either a positional or a keyword parameter.</p>
</div></blockquote>
<p><em>where</em></p>
<blockquote>
<div><p class="versionadded">
<span class="versionmodified">New in version 1.7.</span></p>
<p>Accepts a boolean array which is broadcast together with the operands.
Values of True indicate to calculate the ufunc at that position, values
of False indicate to leave the value in the output alone.</p>
</div></blockquote>
<p><em>casting</em></p>
<blockquote>
<div><p class="versionadded">
<span class="versionmodified">New in version 1.6.</span></p>
<p>Provides a policy for what kind of casting is permitted. For compatibility
with previous versions of NumPy, this defaults to &#8216;unsafe&#8217;. May be &#8216;no&#8217;,
&#8216;equiv&#8217;, &#8216;safe&#8217;, &#8216;same_kind&#8217;, or &#8216;unsafe&#8217;. See <a class="reference internal" href="generated/numpy.can_cast.html#numpy.can_cast" title="numpy.can_cast"><tt class="xref py py-func docutils literal"><span class="pre">can_cast</span></tt></a> for
explanations of the parameter values.</p>
<p>In a future version of numpy, this argument will default to
&#8216;same_kind&#8217;. As part of this transition, starting in version 1.7,
ufuncs will produce a DeprecationWarning for calls which are
allowed under the &#8216;unsafe&#8217; rules, but not under the &#8216;same_kind&#8217;
rules.</p>
</div></blockquote>
<p><em>order</em></p>
<blockquote>
<div><p class="versionadded">
<span class="versionmodified">New in version 1.6.</span></p>
<p>Specifies the calculation iteration order/memory layout of the output array.
Defaults to &#8216;K&#8217;. &#8216;C&#8217; means the output should be C-contiguous, &#8216;F&#8217; means
F-contiguous, &#8216;A&#8217; means F-contiguous if the inputs are F-contiguous and
not also not C-contiguous, C-contiguous otherwise, and &#8216;K&#8217; means to match
the element ordering of the inputs as closely as possible.</p>
</div></blockquote>
<p><em>dtype</em></p>
<blockquote>
<div><p class="versionadded">
<span class="versionmodified">New in version 1.6.</span></p>
<p>Overrides the dtype of the calculation and output arrays. Similar to <em>sig</em>.</p>
</div></blockquote>
<p><em>subok</em></p>
<blockquote>
<div><p class="versionadded">
<span class="versionmodified">New in version 1.6.</span></p>
<p>Defaults to true. If set to false, the output will always be a strict
array, not a subtype.</p>
</div></blockquote>
<p><em>sig</em></p>
<blockquote>
<div>Either a data-type, a tuple of data-types, or a special signature
string indicating the input and output types of a ufunc. This argument
allows you to provide a specific signature for the 1-d loop to use
in the underlying calculation. If the loop specified does not exist
for the ufunc, then a TypeError is raised. Normally, a suitable loop is
found automatically by comparing the input types with what is
available and searching for a loop with data-types to which all inputs
can be cast safely. This keyword argument lets you bypass that
search and choose a particular loop. A list of available signatures is
provided by the <strong>types</strong> attribute of the ufunc object.</div></blockquote>
<p><em>extobj</em></p>
<blockquote>
<div>a list of length 1, 2, or 3 specifying the ufunc buffer-size, the
error mode integer, and the error call-back function. Normally, these
values are looked up in a thread-specific dictionary. Passing them
here circumvents that look up and uses the low-level specification
provided for the error mode. This may be useful, for example, as an
optimization for calculations requiring many ufunc calls on small arrays
in a loop.</div></blockquote>
</div>
<div class="section" id="attributes">
<h3>Attributes<a class="headerlink" href="#attributes" title="Permalink to this headline">¶</a></h3>
<p>There are some informational attributes that universal functions
possess. None of the attributes can be set.</p>
<table border="1" class="docutils" id="index-6">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>__doc__</strong></td>
<td>A docstring for each ufunc. The first part of the docstring is
dynamically generated from the number of outputs, the name, and
the number of inputs. The second part of the docstring is
provided at creation time and stored with the ufunc.</td>
</tr>
<tr class="row-even"><td><strong>__name__</strong></td>
<td>The name of the ufunc.</td>
</tr>
</tbody>
</table>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.ufunc.nin.html#numpy.ufunc.nin" title="numpy.ufunc.nin"><tt class="xref py py-obj docutils literal"><span class="pre">ufunc.nin</span></tt></a></td>
<td>The number of inputs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.ufunc.nout.html#numpy.ufunc.nout" title="numpy.ufunc.nout"><tt class="xref py py-obj docutils literal"><span class="pre">ufunc.nout</span></tt></a></td>
<td>The number of outputs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.ufunc.nargs.html#numpy.ufunc.nargs" title="numpy.ufunc.nargs"><tt class="xref py py-obj docutils literal"><span class="pre">ufunc.nargs</span></tt></a></td>
<td>The number of arguments.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.ufunc.ntypes.html#numpy.ufunc.ntypes" title="numpy.ufunc.ntypes"><tt class="xref py py-obj docutils literal"><span class="pre">ufunc.ntypes</span></tt></a></td>
<td>The number of types.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.ufunc.types.html#numpy.ufunc.types" title="numpy.ufunc.types"><tt class="xref py py-obj docutils literal"><span class="pre">ufunc.types</span></tt></a></td>
<td>Returns a list with types grouped input-&gt;output.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.ufunc.identity.html#numpy.ufunc.identity" title="numpy.ufunc.identity"><tt class="xref py py-obj docutils literal"><span class="pre">ufunc.identity</span></tt></a></td>
<td>The identity value.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="methods">
<h3>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h3>
<p>All ufuncs have four methods. However, these methods only make sense on
ufuncs that take two input arguments and return one output argument.
Attempting to call these methods on other ufuncs will cause a
<a class="reference external" href="http://docs.python.org/dev/library/exceptions.html#ValueError" title="(in Python v3.4)"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a>. The reduce-like methods all take an <em>axis</em> keyword
and a <em>dtype</em> keyword, and the arrays must all have dimension &gt;= 1.
The <em>axis</em> keyword specifies the axis of the array over which the reduction
will take place and may be negative, but must be an integer. The
<em>dtype</em> keyword allows you to manage a very common problem that arises
when naively using <em class="xref std std-ref">{op}.reduce</em>. Sometimes you may
have an array of a certain data type and wish to add up all of its
elements, but the result does not fit into the data type of the
array. This commonly happens if you have an array of single-byte
integers. The <em>dtype</em> keyword allows you to alter the data type over which
the reduction takes place (and therefore the type of the output). Thus,
you can ensure that the output is a data type with precision large enough
to handle your output. The responsibility of altering the reduce type is
mostly up to you. There is one exception: if no <em>dtype</em> is given for a
reduction on the &#8220;add&#8221; or &#8220;multiply&#8221; operations, then if the input type is
an integer (or Boolean) data-type and smaller than the size of the
<tt class="xref py py-class docutils literal"><span class="pre">int_</span></tt> data type, it will be internally upcast to the <tt class="xref py py-class docutils literal"><span class="pre">int_</span></tt>
(or <tt class="xref py py-class docutils literal"><span class="pre">uint</span></tt>) data-type.</p>
<p>Ufuncs also have a fifth method that allows in place operations to be
performed using fancy indexing. No buffering is used on the dimensions where
fancy indexing is used, so the fancy index can list an item more than once and
the operation will be performed on the result of the previous operation for
that item.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce" title="numpy.ufunc.reduce"><tt class="xref py py-obj docutils literal"><span class="pre">ufunc.reduce</span></tt></a>(a[,&nbsp;axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Reduces <em class="xref py py-obj">a</em>&#8216;s dimension by one, by applying ufunc along one axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.ufunc.accumulate.html#numpy.ufunc.accumulate" title="numpy.ufunc.accumulate"><tt class="xref py py-obj docutils literal"><span class="pre">ufunc.accumulate</span></tt></a>(array[,&nbsp;axis,&nbsp;dtype,&nbsp;out])</td>
<td>Accumulate the result of applying the operator to all elements.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.ufunc.reduceat.html#numpy.ufunc.reduceat" title="numpy.ufunc.reduceat"><tt class="xref py py-obj docutils literal"><span class="pre">ufunc.reduceat</span></tt></a>(a,&nbsp;indices[,&nbsp;axis,&nbsp;dtype,&nbsp;out])</td>
<td>Performs a (local) reduce with specified slices over a single axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.ufunc.outer.html#numpy.ufunc.outer" title="numpy.ufunc.outer"><tt class="xref py py-obj docutils literal"><span class="pre">ufunc.outer</span></tt></a>(A,&nbsp;B)</td>
<td>Apply the ufunc <em class="xref py py-obj">op</em> to all pairs (a, b) with a in <em class="xref py py-obj">A</em> and b in <em class="xref py py-obj">B</em>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.ufunc.at.html#numpy.ufunc.at" title="numpy.ufunc.at"><tt class="xref py py-obj docutils literal"><span class="pre">ufunc.at</span></tt></a>(a,&nbsp;indices[,&nbsp;b])</td>
<td>Performs unbuffered in place operation on operand &#8216;a&#8217; for elements specified by &#8216;indices&#8217;.</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">A reduce-like operation on an array with a data-type that has a
range &#8220;too small&#8221; to handle the result will silently wrap. One
should use <a class="reference internal" href="generated/numpy.dtype.html#numpy.dtype" title="numpy.dtype"><tt class="xref py py-obj docutils literal"><span class="pre">dtype</span></tt></a> to increase the size of the data-type over which
reduction takes place.</p>
</div>
</div>
</div>
<div class="section" id="available-ufuncs">
<h2>Available ufuncs<a class="headerlink" href="#available-ufuncs" title="Permalink to this headline">¶</a></h2>
<p>There are currently more than 60 universal functions defined in
<a class="reference internal" href="index.html#module-numpy" title="numpy"><tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt></a> on one or more types, covering a wide variety of
operations. Some of these ufuncs are called automatically on arrays
when the relevant infix notation is used (<em>e.g.</em>, <a class="reference internal" href="generated/numpy.add.html#numpy.add" title="numpy.add"><tt class="xref py py-func docutils literal"><span class="pre">add(a,</span> <span class="pre">b)</span></tt></a>
is called internally when <tt class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></tt> is written and <em>a</em> or <em>b</em> is an
<a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><tt class="xref py py-class docutils literal"><span class="pre">ndarray</span></tt></a>). Nevertheless, you may still want to use the ufunc
call in order to use the optional output argument(s) to place the
output(s) in an object (or objects) of your choice.</p>
<p>Recall that each ufunc operates element-by-element. Therefore, each
ufunc will be described as if acting on a set of scalar inputs to
return a set of scalar outputs.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The ufunc still returns its output(s) even if you use the optional
output argument(s).</p>
</div>
<div class="section" id="math-operations">
<h3>Math operations<a class="headerlink" href="#math-operations" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.add.html#numpy.add" title="numpy.add"><tt class="xref py py-obj docutils literal"><span class="pre">add</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Add arguments element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.subtract.html#numpy.subtract" title="numpy.subtract"><tt class="xref py py-obj docutils literal"><span class="pre">subtract</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Subtract arguments, element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.multiply.html#numpy.multiply" title="numpy.multiply"><tt class="xref py py-obj docutils literal"><span class="pre">multiply</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Multiply arguments element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.divide.html#numpy.divide" title="numpy.divide"><tt class="xref py py-obj docutils literal"><span class="pre">divide</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Divide arguments element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.logaddexp.html#numpy.logaddexp" title="numpy.logaddexp"><tt class="xref py py-obj docutils literal"><span class="pre">logaddexp</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Logarithm of the sum of exponentiations of the inputs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.logaddexp2.html#numpy.logaddexp2" title="numpy.logaddexp2"><tt class="xref py py-obj docutils literal"><span class="pre">logaddexp2</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Logarithm of the sum of exponentiations of the inputs in base-2.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.true_divide.html#numpy.true_divide" title="numpy.true_divide"><tt class="xref py py-obj docutils literal"><span class="pre">true_divide</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Returns a true division of the inputs, element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.floor_divide.html#numpy.floor_divide" title="numpy.floor_divide"><tt class="xref py py-obj docutils literal"><span class="pre">floor_divide</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Return the largest integer smaller or equal to the division of the inputs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.negative.html#numpy.negative" title="numpy.negative"><tt class="xref py py-obj docutils literal"><span class="pre">negative</span></tt></a>(x[,&nbsp;out])</td>
<td>Returns an array with the negative of each element of the original array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.power.html#numpy.power" title="numpy.power"><tt class="xref py py-obj docutils literal"><span class="pre">power</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>First array elements raised to powers from second array, element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.remainder.html#numpy.remainder" title="numpy.remainder"><tt class="xref py py-obj docutils literal"><span class="pre">remainder</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Return element-wise remainder of division.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.mod.html#numpy.mod" title="numpy.mod"><tt class="xref py py-obj docutils literal"><span class="pre">mod</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Return element-wise remainder of division.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.fmod.html#numpy.fmod" title="numpy.fmod"><tt class="xref py py-obj docutils literal"><span class="pre">fmod</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Return the element-wise remainder of division.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.absolute.html#numpy.absolute" title="numpy.absolute"><tt class="xref py py-obj docutils literal"><span class="pre">absolute</span></tt></a>(x[,&nbsp;out])</td>
<td>Calculate the absolute value element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.rint.html#numpy.rint" title="numpy.rint"><tt class="xref py py-obj docutils literal"><span class="pre">rint</span></tt></a>(x[,&nbsp;out])</td>
<td>Round elements of the array to the nearest integer.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.sign.html#numpy.sign" title="numpy.sign"><tt class="xref py py-obj docutils literal"><span class="pre">sign</span></tt></a>(x[,&nbsp;out])</td>
<td>Returns an element-wise indication of the sign of a number.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.conj.html#numpy.conj" title="numpy.conj"><tt class="xref py py-obj docutils literal"><span class="pre">conj</span></tt></a>(x[,&nbsp;out])</td>
<td>Return the complex conjugate, element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.exp.html#numpy.exp" title="numpy.exp"><tt class="xref py py-obj docutils literal"><span class="pre">exp</span></tt></a>(x[,&nbsp;out])</td>
<td>Calculate the exponential of all elements in the input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.exp2.html#numpy.exp2" title="numpy.exp2"><tt class="xref py py-obj docutils literal"><span class="pre">exp2</span></tt></a>(x[,&nbsp;out])</td>
<td>Calculate <em class="xref py py-obj">2**p</em> for all <em class="xref py py-obj">p</em> in the input array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.log.html#numpy.log" title="numpy.log"><tt class="xref py py-obj docutils literal"><span class="pre">log</span></tt></a>(x[,&nbsp;out])</td>
<td>Natural logarithm, element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.log2.html#numpy.log2" title="numpy.log2"><tt class="xref py py-obj docutils literal"><span class="pre">log2</span></tt></a>(x[,&nbsp;out])</td>
<td>Base-2 logarithm of <em class="xref py py-obj">x</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.log10.html#numpy.log10" title="numpy.log10"><tt class="xref py py-obj docutils literal"><span class="pre">log10</span></tt></a>(x[,&nbsp;out])</td>
<td>Return the base 10 logarithm of the input array, element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.expm1.html#numpy.expm1" title="numpy.expm1"><tt class="xref py py-obj docutils literal"><span class="pre">expm1</span></tt></a>(x[,&nbsp;out])</td>
<td>Calculate <tt class="docutils literal"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></tt> for all elements in the array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.log1p.html#numpy.log1p" title="numpy.log1p"><tt class="xref py py-obj docutils literal"><span class="pre">log1p</span></tt></a>(x[,&nbsp;out])</td>
<td>Return the natural logarithm of one plus the input array, element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.sqrt.html#numpy.sqrt" title="numpy.sqrt"><tt class="xref py py-obj docutils literal"><span class="pre">sqrt</span></tt></a>(x[,&nbsp;out])</td>
<td>Return the positive square-root of an array, element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.square.html#numpy.square" title="numpy.square"><tt class="xref py py-obj docutils literal"><span class="pre">square</span></tt></a>(x[,&nbsp;out])</td>
<td>Return the element-wise square of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.reciprocal.html#numpy.reciprocal" title="numpy.reciprocal"><tt class="xref py py-obj docutils literal"><span class="pre">reciprocal</span></tt></a>(x[,&nbsp;out])</td>
<td>Return the reciprocal of the argument, element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.ones_like.html#numpy.ones_like" title="numpy.ones_like"><tt class="xref py py-obj docutils literal"><span class="pre">ones_like</span></tt></a>(a[,&nbsp;dtype,&nbsp;order,&nbsp;subok])</td>
<td>Return an array of ones with the same shape and type as a given array.</td>
</tr>
</tbody>
</table>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">The optional output arguments can be used to help you save memory
for large calculations. If your arrays are large, complicated
expressions can take longer than absolutely necessary due to the
creation and (later) destruction of temporary calculation
spaces. For example, the expression <tt class="docutils literal"><span class="pre">G</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">c</span></tt> is equivalent to
<tt class="docutils literal"><span class="pre">t1</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">*</span> <span class="pre">B;</span> <span class="pre">G</span> <span class="pre">=</span> <span class="pre">T1</span> <span class="pre">+</span> <span class="pre">C;</span> <span class="pre">del</span> <span class="pre">t1</span></tt>. It will be more quickly executed
as <tt class="docutils literal"><span class="pre">G</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">*</span> <span class="pre">B;</span> <span class="pre">add(G,</span> <span class="pre">C,</span> <span class="pre">G)</span></tt> which is the same as
<tt class="docutils literal"><span class="pre">G</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">*</span> <span class="pre">B;</span> <span class="pre">G</span> <span class="pre">+=</span> <span class="pre">C</span></tt>.</p>
</div>
</div>
<div class="section" id="trigonometric-functions">
<h3>Trigonometric functions<a class="headerlink" href="#trigonometric-functions" title="Permalink to this headline">¶</a></h3>
<p>All trigonometric functions use radians when an angle is called for.
The ratio of degrees to radians is <img class="math" src="../_images/math/8c88a764b0fdbe42f81ed176af674fd96bf787e1.png" alt="180^{\circ}/\pi." style="vertical-align: -4px"/></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.sin.html#numpy.sin" title="numpy.sin"><tt class="xref py py-obj docutils literal"><span class="pre">sin</span></tt></a>(x[,&nbsp;out])</td>
<td>Trigonometric sine, element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.cos.html#numpy.cos" title="numpy.cos"><tt class="xref py py-obj docutils literal"><span class="pre">cos</span></tt></a>(x[,&nbsp;out])</td>
<td>Cosine elementwise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.tan.html#numpy.tan" title="numpy.tan"><tt class="xref py py-obj docutils literal"><span class="pre">tan</span></tt></a>(x[,&nbsp;out])</td>
<td>Compute tangent element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.arcsin.html#numpy.arcsin" title="numpy.arcsin"><tt class="xref py py-obj docutils literal"><span class="pre">arcsin</span></tt></a>(x[,&nbsp;out])</td>
<td>Inverse sine, element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.arccos.html#numpy.arccos" title="numpy.arccos"><tt class="xref py py-obj docutils literal"><span class="pre">arccos</span></tt></a>(x[,&nbsp;out])</td>
<td>Trigonometric inverse cosine, element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.arctan.html#numpy.arctan" title="numpy.arctan"><tt class="xref py py-obj docutils literal"><span class="pre">arctan</span></tt></a>(x[,&nbsp;out])</td>
<td>Trigonometric inverse tangent, element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.arctan2.html#numpy.arctan2" title="numpy.arctan2"><tt class="xref py py-obj docutils literal"><span class="pre">arctan2</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Element-wise arc tangent of <tt class="docutils literal"><span class="pre">x1/x2</span></tt> choosing the quadrant correctly.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.hypot.html#numpy.hypot" title="numpy.hypot"><tt class="xref py py-obj docutils literal"><span class="pre">hypot</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Given the &#8220;legs&#8221; of a right triangle, return its hypotenuse.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.sinh.html#numpy.sinh" title="numpy.sinh"><tt class="xref py py-obj docutils literal"><span class="pre">sinh</span></tt></a>(x[,&nbsp;out])</td>
<td>Hyperbolic sine, element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.cosh.html#numpy.cosh" title="numpy.cosh"><tt class="xref py py-obj docutils literal"><span class="pre">cosh</span></tt></a>(x[,&nbsp;out])</td>
<td>Hyperbolic cosine, element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.tanh.html#numpy.tanh" title="numpy.tanh"><tt class="xref py py-obj docutils literal"><span class="pre">tanh</span></tt></a>(x[,&nbsp;out])</td>
<td>Compute hyperbolic tangent element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.arcsinh.html#numpy.arcsinh" title="numpy.arcsinh"><tt class="xref py py-obj docutils literal"><span class="pre">arcsinh</span></tt></a>(x[,&nbsp;out])</td>
<td>Inverse hyperbolic sine elementwise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.arccosh.html#numpy.arccosh" title="numpy.arccosh"><tt class="xref py py-obj docutils literal"><span class="pre">arccosh</span></tt></a>(x[,&nbsp;out])</td>
<td>Inverse hyperbolic cosine, elementwise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.arctanh.html#numpy.arctanh" title="numpy.arctanh"><tt class="xref py py-obj docutils literal"><span class="pre">arctanh</span></tt></a>(x[,&nbsp;out])</td>
<td>Inverse hyperbolic tangent elementwise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.deg2rad.html#numpy.deg2rad" title="numpy.deg2rad"><tt class="xref py py-obj docutils literal"><span class="pre">deg2rad</span></tt></a>(x[,&nbsp;out])</td>
<td>Convert angles from degrees to radians.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.rad2deg.html#numpy.rad2deg" title="numpy.rad2deg"><tt class="xref py py-obj docutils literal"><span class="pre">rad2deg</span></tt></a>(x[,&nbsp;out])</td>
<td>Convert angles from radians to degrees.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="bit-twiddling-functions">
<h3>Bit-twiddling functions<a class="headerlink" href="#bit-twiddling-functions" title="Permalink to this headline">¶</a></h3>
<p>These function all require integer arguments and they manipulate the
bit-pattern of those arguments.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.bitwise_and.html#numpy.bitwise_and" title="numpy.bitwise_and"><tt class="xref py py-obj docutils literal"><span class="pre">bitwise_and</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Compute the bit-wise AND of two arrays element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.bitwise_or.html#numpy.bitwise_or" title="numpy.bitwise_or"><tt class="xref py py-obj docutils literal"><span class="pre">bitwise_or</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Compute the bit-wise OR of two arrays element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.bitwise_xor.html#numpy.bitwise_xor" title="numpy.bitwise_xor"><tt class="xref py py-obj docutils literal"><span class="pre">bitwise_xor</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Compute the bit-wise XOR of two arrays element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.invert.html#numpy.invert" title="numpy.invert"><tt class="xref py py-obj docutils literal"><span class="pre">invert</span></tt></a>(x[,&nbsp;out])</td>
<td>Compute bit-wise inversion, or bit-wise NOT, element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.left_shift.html#numpy.left_shift" title="numpy.left_shift"><tt class="xref py py-obj docutils literal"><span class="pre">left_shift</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Shift the bits of an integer to the left.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.right_shift.html#numpy.right_shift" title="numpy.right_shift"><tt class="xref py py-obj docutils literal"><span class="pre">right_shift</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Shift the bits of an integer to the right.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="comparison-functions">
<h3>Comparison functions<a class="headerlink" href="#comparison-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.greater.html#numpy.greater" title="numpy.greater"><tt class="xref py py-obj docutils literal"><span class="pre">greater</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Return the truth value of (x1 &gt; x2) element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.greater_equal.html#numpy.greater_equal" title="numpy.greater_equal"><tt class="xref py py-obj docutils literal"><span class="pre">greater_equal</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Return the truth value of (x1 &gt;= x2) element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.less.html#numpy.less" title="numpy.less"><tt class="xref py py-obj docutils literal"><span class="pre">less</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Return the truth value of (x1 &lt; x2) element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.less_equal.html#numpy.less_equal" title="numpy.less_equal"><tt class="xref py py-obj docutils literal"><span class="pre">less_equal</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Return the truth value of (x1 =&lt; x2) element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.not_equal.html#numpy.not_equal" title="numpy.not_equal"><tt class="xref py py-obj docutils literal"><span class="pre">not_equal</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Return (x1 != x2) element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.equal.html#numpy.equal" title="numpy.equal"><tt class="xref py py-obj docutils literal"><span class="pre">equal</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Return (x1 == x2) element-wise.</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Do not use the Python keywords <tt class="docutils literal"><span class="pre">and</span></tt> and <tt class="docutils literal"><span class="pre">or</span></tt> to combine
logical array expressions. These keywords will test the truth
value of the entire array (not element-by-element as you might
expect). Use the bitwise operators &amp; and | instead.</p>
</div>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.logical_and.html#numpy.logical_and" title="numpy.logical_and"><tt class="xref py py-obj docutils literal"><span class="pre">logical_and</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Compute the truth value of x1 AND x2 elementwise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.logical_or.html#numpy.logical_or" title="numpy.logical_or"><tt class="xref py py-obj docutils literal"><span class="pre">logical_or</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Compute the truth value of x1 OR x2 elementwise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.logical_xor.html#numpy.logical_xor" title="numpy.logical_xor"><tt class="xref py py-obj docutils literal"><span class="pre">logical_xor</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Compute the truth value of x1 XOR x2, element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.logical_not.html#numpy.logical_not" title="numpy.logical_not"><tt class="xref py py-obj docutils literal"><span class="pre">logical_not</span></tt></a>(x[,&nbsp;out])</td>
<td>Compute the truth value of NOT x elementwise.</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The bit-wise operators &amp; and | are the proper way to perform
element-by-element array comparisons. Be sure you understand the
operator precedence: <tt class="docutils literal"><span class="pre">(a</span> <span class="pre">&gt;</span> <span class="pre">2)</span> <span class="pre">&amp;</span> <span class="pre">(a</span> <span class="pre">&lt;</span> <span class="pre">5)</span></tt> is the proper syntax because
<tt class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">2</span> <span class="pre">&amp;</span> <span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">5</span></tt> will result in an error due to the fact that <tt class="docutils literal"><span class="pre">2</span> <span class="pre">&amp;</span> <span class="pre">a</span></tt>
is evaluated first.</p>
</div>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.maximum.html#numpy.maximum" title="numpy.maximum"><tt class="xref py py-obj docutils literal"><span class="pre">maximum</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Element-wise maximum of array elements.</td>
</tr>
</tbody>
</table>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">The Python function <tt class="docutils literal"><span class="pre">max()</span></tt> will find the maximum over a one-dimensional
array, but it will do so using a slower sequence interface. The reduce
method of the maximum ufunc is much faster. Also, the <tt class="docutils literal"><span class="pre">max()</span></tt> method
will not give answers you might expect for arrays with greater than
one dimension. The reduce method of minimum also allows you to compute
a total minimum over an array.</p>
</div>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.minimum.html#numpy.minimum" title="numpy.minimum"><tt class="xref py py-obj docutils literal"><span class="pre">minimum</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Element-wise minimum of array elements.</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">the behavior of <tt class="docutils literal"><span class="pre">maximum(a,</span> <span class="pre">b)</span></tt> is different than that of <tt class="docutils literal"><span class="pre">max(a,</span> <span class="pre">b)</span></tt>.
As a ufunc, <tt class="docutils literal"><span class="pre">maximum(a,</span> <span class="pre">b)</span></tt> performs an element-by-element comparison
of <em class="xref py py-obj">a</em> and <em class="xref py py-obj">b</em> and chooses each element of the result according to which
element in the two arrays is larger. In contrast, <tt class="docutils literal"><span class="pre">max(a,</span> <span class="pre">b)</span></tt> treats
the objects <em class="xref py py-obj">a</em> and <em class="xref py py-obj">b</em> as a whole, looks at the (total) truth value of
<tt class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></tt> and uses it to return either <em class="xref py py-obj">a</em> or <em class="xref py py-obj">b</em> (as a whole). A similar
difference exists between <tt class="docutils literal"><span class="pre">minimum(a,</span> <span class="pre">b)</span></tt> and <tt class="docutils literal"><span class="pre">min(a,</span> <span class="pre">b)</span></tt>.</p>
</div>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.fmax.html#numpy.fmax" title="numpy.fmax"><tt class="xref py py-obj docutils literal"><span class="pre">fmax</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Element-wise maximum of array elements.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.fmin.html#numpy.fmin" title="numpy.fmin"><tt class="xref py py-obj docutils literal"><span class="pre">fmin</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Element-wise minimum of array elements.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="floating-functions">
<h3>Floating functions<a class="headerlink" href="#floating-functions" title="Permalink to this headline">¶</a></h3>
<p>Recall that all of these functions work element-by-element over an
array, returning an array output. The description details only a
single operation.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.isreal.html#numpy.isreal" title="numpy.isreal"><tt class="xref py py-obj docutils literal"><span class="pre">isreal</span></tt></a>(x)</td>
<td>Returns a bool array, where True if input element is real.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.iscomplex.html#numpy.iscomplex" title="numpy.iscomplex"><tt class="xref py py-obj docutils literal"><span class="pre">iscomplex</span></tt></a>(x)</td>
<td>Returns a bool array, where True if input element is complex.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.isfinite.html#numpy.isfinite" title="numpy.isfinite"><tt class="xref py py-obj docutils literal"><span class="pre">isfinite</span></tt></a>(x[,&nbsp;out])</td>
<td>Test element-wise for finite-ness (not infinity or not Not a Number).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.isinf.html#numpy.isinf" title="numpy.isinf"><tt class="xref py py-obj docutils literal"><span class="pre">isinf</span></tt></a>(x[,&nbsp;out])</td>
<td>Test element-wise for positive or negative infinity.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.isnan.html#numpy.isnan" title="numpy.isnan"><tt class="xref py py-obj docutils literal"><span class="pre">isnan</span></tt></a>(x[,&nbsp;out])</td>
<td>Test element-wise for Not a Number (NaN), return result as a bool array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.signbit.html#numpy.signbit" title="numpy.signbit"><tt class="xref py py-obj docutils literal"><span class="pre">signbit</span></tt></a>(x[,&nbsp;out])</td>
<td>Returns element-wise True where signbit is set (less than zero).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.copysign.html#numpy.copysign" title="numpy.copysign"><tt class="xref py py-obj docutils literal"><span class="pre">copysign</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Change the sign of x1 to that of x2, element-wise.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">nextafter</span></tt>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Return the next representable floating-point value after x1 in the direction of x2 element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.modf.html#numpy.modf" title="numpy.modf"><tt class="xref py py-obj docutils literal"><span class="pre">modf</span></tt></a>(x[,&nbsp;out1,&nbsp;out2])</td>
<td>Return the fractional and integral parts of an array, element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.ldexp.html#numpy.ldexp" title="numpy.ldexp"><tt class="xref py py-obj docutils literal"><span class="pre">ldexp</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Compute y = x1 * 2**x2.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.frexp.html#numpy.frexp" title="numpy.frexp"><tt class="xref py py-obj docutils literal"><span class="pre">frexp</span></tt></a>(x[,&nbsp;out1,&nbsp;out2])</td>
<td>Split the number, x, into a normalized fraction (y1) and exponent (y2)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.fmod.html#numpy.fmod" title="numpy.fmod"><tt class="xref py py-obj docutils literal"><span class="pre">fmod</span></tt></a>(x1,&nbsp;x2[,&nbsp;out])</td>
<td>Return the element-wise remainder of division.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.floor.html#numpy.floor" title="numpy.floor"><tt class="xref py py-obj docutils literal"><span class="pre">floor</span></tt></a>(x[,&nbsp;out])</td>
<td>Return the floor of the input, element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.ceil.html#numpy.ceil" title="numpy.ceil"><tt class="xref py py-obj docutils literal"><span class="pre">ceil</span></tt></a>(x[,&nbsp;out])</td>
<td>Return the ceiling of the input, element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.trunc.html#numpy.trunc" title="numpy.trunc"><tt class="xref py py-obj docutils literal"><span class="pre">trunc</span></tt></a>(x[,&nbsp;out])</td>
<td>Return the truncated value of the input, element-wise.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2009, The Scipy community.
      </li>
      <li>
      Last updated on Nov 10, 2013.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>