
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>numpy.polynomial.polynomial.polyfit &mdash; NumPy v1.8 Manual</title>
    
    <link rel="stylesheet" type="text/css" href="../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.8.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/js/jquery.min.js"></script>
    <script type="text/javascript" src="../../_static/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" >
    <link rel="top" title="NumPy v1.8 Manual" href="../../index.html" >
    <link rel="up" title="Polynomial Module (numpy.polynomial.polynomial)" href="../routines.polynomials.polynomial.html" >
    <link rel="next" title="numpy.polynomial.polynomial.polyvander" href="numpy.polynomial.polynomial.polyvander.html" >
    <link rel="prev" title="numpy.polynomial.polynomial.polyfromroots" href="numpy.polynomial.polynomial.polyfromroots.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        
        <li class="active"><a href="../../index.html">NumPy v1.8 Manual</a></li>
        

          <li class="active"><a href="../index.html" >NumPy Reference</a></li>
          <li class="active"><a href="../routines.html" >Routines</a></li>
          <li class="active"><a href="../routines.polynomials.html" >Polynomials</a></li>
          <li class="active"><a href="../routines.polynomials.package.html" >Polynomial Package</a></li>
          <li class="active"><a href="../routines.polynomials.polynomial.html" accesskey="U">Polynomial Module (<tt class="docutils literal"><span class="pre">numpy.polynomial.polynomial</span></tt>)</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="numpy.polynomial.polynomial.polyvander.html" title="numpy.polynomial.polynomial.polyvander"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="numpy.polynomial.polynomial.polyfromroots.html" title="numpy.polynomial.polynomial.polyfromroots"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="numpy.polynomial.polynomial.polyfromroots.html"
                        title="previous chapter">numpy.polynomial.polynomial.polyfromroots</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="numpy.polynomial.polynomial.polyvander.html"
                        title="next chapter">numpy.polynomial.polynomial.polyvander</a></p>


        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="numpy-polynomial-polynomial-polyfit">
<h1>numpy.polynomial.polynomial.polyfit<a class="headerlink" href="#numpy-polynomial-polynomial-polyfit" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="numpy.polynomial.polynomial.polyfit">
<tt class="descclassname">numpy.polynomial.polynomial.</tt><tt class="descname">polyfit</tt><big>(</big><em>x</em>, <em>y</em>, <em>deg</em>, <em>rcond=None</em>, <em>full=False</em>, <em>w=None</em><big>)</big><a class="reference external" href="http://github.com/numpy/numpy/blob/v1.8.0/numpy/polynomial/polynomial.py#L1195"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#numpy.polynomial.polynomial.polyfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares fit of a polynomial to data.</p>
<p>Return the coefficients of a polynomial of degree <em class="xref py py-obj">deg</em> that is the
least squares fit to the data values <em class="xref py py-obj">y</em> given at points <em class="xref py py-obj">x</em>. If <em class="xref py py-obj">y</em> is
1-D the returned coefficients will also be 1-D. If <em class="xref py py-obj">y</em> is 2-D multiple
fits are done, one for each column of <em class="xref py py-obj">y</em>, and the resulting
coefficients are stored in the corresponding columns of a 2-D return.
The fitted polynomial(s) are in the form</p>
<div class="math">
<p><img src="../../_images/math/612096ef4df722832138c7bf5032b4fa1d5f4b45.png" alt="p(x) = c_0 + c_1 * x + ... + c_n * x^n,"/></p>
</div><p>where <em class="xref py py-obj">n</em> is <em class="xref py py-obj">deg</em>.</p>
<p>Since numpy version 1.7.0, polyfit also supports NA. If any of the
elements of <em class="xref py py-obj">x</em>, <em class="xref py py-obj">y</em>, or <em class="xref py py-obj">w</em> are NA, then the corresponding rows of the
linear least squares problem (see Notes) are set to 0. If <em class="xref py py-obj">y</em> is 2-D,
then an NA in any row of <em class="xref py py-obj">y</em> invalidates that whole row.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>x</strong> : array_like, shape (<em class="xref py py-obj">M</em>,)</p>
<blockquote>
<div><p>x-coordinates of the <em class="xref py py-obj">M</em> sample (data) points <tt class="docutils literal"><span class="pre">(x[i],</span> <span class="pre">y[i])</span></tt>.</p>
</div></blockquote>
<p><strong>y</strong> : array_like, shape (<em class="xref py py-obj">M</em>,) or (<em class="xref py py-obj">M</em>, <em class="xref py py-obj">K</em>)</p>
<blockquote>
<div><p>y-coordinates of the sample points.  Several sets of sample points
sharing the same x-coordinates can be (independently) fit with one
call to <a class="reference internal" href="#numpy.polynomial.polynomial.polyfit" title="numpy.polynomial.polynomial.polyfit"><tt class="xref py py-obj docutils literal"><span class="pre">polyfit</span></tt></a> by passing in for <em class="xref py py-obj">y</em> a 2-D array that contains
one data set per column.</p>
</div></blockquote>
<p><strong>deg</strong> : int</p>
<blockquote>
<div><p>Degree of the polynomial(s) to be fit.</p>
</div></blockquote>
<p><strong>rcond</strong> : float, optional</p>
<blockquote>
<div><p>Relative condition number of the fit.  Singular values smaller
than <em class="xref py py-obj">rcond</em>, relative to the largest singular value, will be
ignored.  The default value is <tt class="docutils literal"><span class="pre">len(x)*eps</span></tt>, where <em class="xref py py-obj">eps</em> is the
relative precision of the platform&#8217;s float type, about 2e-16 in
most cases.</p>
</div></blockquote>
<p><strong>full</strong> : bool, optional</p>
<blockquote>
<div><p>Switch determining the nature of the return value.  When <tt class="docutils literal"><span class="pre">False</span></tt>
(the default) just the coefficients are returned; when <tt class="docutils literal"><span class="pre">True</span></tt>,
diagnostic information from the singular value decomposition (used
to solve the fit&#8217;s matrix equation) is also returned.</p>
</div></blockquote>
<p><strong>w</strong> : array_like, shape (<em class="xref py py-obj">M</em>,), optional</p>
<blockquote>
<div><p>Weights. If not None, the contribution of each point
<tt class="docutils literal"><span class="pre">(x[i],y[i])</span></tt> to the fit is weighted by <em class="xref py py-obj">w[i]</em>. Ideally the
weights are chosen so that the errors of the products <tt class="docutils literal"><span class="pre">w[i]*y[i]</span></tt>
all have the same variance.  The default value is None.</p>
<p class="versionadded">
<span class="versionmodified">New in version 1.5.0.</span></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>coef</strong> : ndarray, shape (<em class="xref py py-obj">deg</em> + 1,) or (<em class="xref py py-obj">deg</em> + 1, <em class="xref py py-obj">K</em>)</p>
<blockquote>
<div><p>Polynomial coefficients ordered from low to high.  If <em class="xref py py-obj">y</em> was 2-D,
the coefficients in column <em class="xref py py-obj">k</em> of <em class="xref py py-obj">coef</em> represent the polynomial
fit to the data in <em class="xref py py-obj">y</em>&#8216;s <em class="xref py py-obj">k</em>-th column.</p>
</div></blockquote>
<p><strong>[residuals, rank, singular_values, rcond]</strong> : present when <em class="xref py py-obj">full</em> == True</p>
<blockquote>
<div><p>Sum of the squared residuals (SSR) of the least-squares fit; the
effective rank of the scaled Vandermonde matrix; its singular
values; and the specified value of <em class="xref py py-obj">rcond</em>.  For more information,
see <em class="xref py py-obj">linalg.lstsq</em>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first"><strong>RankWarning</strong></p>
<blockquote class="last">
<div><p>Raised if the matrix in the least-squares fit is rank deficient.
The warning is only raised if <em class="xref py py-obj">full</em> == False.  The warnings can
be turned off by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">RankWarning</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p><tt class="xref py py-obj docutils literal"><span class="pre">chebfit</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">legfit</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">lagfit</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">hermfit</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">hermefit</span></tt></p>
<dl class="last docutils">
<dt><a class="reference internal" href="numpy.polynomial.polynomial.polyval.html#numpy.polynomial.polynomial.polyval" title="numpy.polynomial.polynomial.polyval"><tt class="xref py py-obj docutils literal"><span class="pre">polyval</span></tt></a></dt>
<dd>Evaluates a polynomial.</dd>
<dt><a class="reference internal" href="numpy.polynomial.polynomial.polyvander.html#numpy.polynomial.polynomial.polyvander" title="numpy.polynomial.polynomial.polyvander"><tt class="xref py py-obj docutils literal"><span class="pre">polyvander</span></tt></a></dt>
<dd>Vandermonde matrix for powers.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">linalg.lstsq</span></tt></dt>
<dd>Computes a least-squares fit from the matrix.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">scipy.interpolate.UnivariateSpline</span></tt></dt>
<dd>Computes spline fits.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The solution is the coefficients of the polynomial <em class="xref py py-obj">p</em> that minimizes
the sum of the weighted squared errors</p>
<div class="math">
<p><img src="../../_images/math/093ce911a4cb05f6b9d82dacb90900dbc911224d.png" alt="E = \sum_j w_j^2 * |y_j - p(x_j)|^2,"/></p>
</div><p>where the <img class="math" src="../../_images/math/70e112d63216392d128e6b9fbe5a09c2d5d6bd48.png" alt="w_j" style="vertical-align: -4px"/> are the weights. This problem is solved by
setting up the (typically) over-determined matrix equation:</p>
<div class="math">
<p><img src="../../_images/math/8c57e1ac91c213b73a81ddc29b2bb7e3353ea67f.png" alt="V(x) * c = w * y,"/></p>
</div><p>where <em class="xref py py-obj">V</em> is the weighted pseudo Vandermonde matrix of <em class="xref py py-obj">x</em>, <em class="xref py py-obj">c</em> are the
coefficients to be solved for, <em class="xref py py-obj">w</em> are the weights, and <em class="xref py py-obj">y</em> are the
observed values.  This equation is then solved using the singular value
decomposition of <em class="xref py py-obj">V</em>.</p>
<p>If some of the singular values of <em class="xref py py-obj">V</em> are so small that they are
neglected (and <em class="xref py py-obj">full</em> == <tt class="docutils literal"><span class="pre">False</span></tt>), a <em class="xref py py-obj">RankWarning</em> will be raised.
This means that the coefficient values may be poorly determined.
Fitting to a lower order polynomial will usually get rid of the warning
(but may not be what you want, of course; if you have independent
reason(s) for choosing the degree which isn&#8217;t working, you may have to:
a) reconsider those reasons, and/or b) reconsider the quality of your
data).  The <em class="xref py py-obj">rcond</em> parameter can also be set to a value smaller than
its default, but the resulting fit may be spurious and have large
contributions from roundoff error.</p>
<p>Polynomial fits using double precision tend to &#8220;fail&#8221; at about
(polynomial) degree 20. Fits using Chebyshev or Legendre series are
generally better conditioned, but much can still depend on the
distribution of the sample points and the smoothness of the data.  If
the quality of the fit is inadequate, splines may be a good
alternative.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">polynomial</span> <span class="k">as</span> <span class="n">P</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">51</span><span class="p">)</span> <span class="c"># x &quot;data&quot;: [-1, -0.96, ..., 0.96, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c"># x^3 - x + N(0,1) &quot;noise&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">full</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="c"># c[0], c[2] should be approx. 0, c[1] approx. -1, c[3] approx. 1</span>
<span class="go">array([ 0.01909725, -1.30598256, -0.00577963,  1.02644286])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span> <span class="c"># note the large SSR, explaining the rather poor results</span>
<span class="go">[array([ 38.06116253]), 4, array([ 1.38446749,  1.32119158,  0.50443316,</span>
<span class="go">0.28853036]), 1.1324274851176597e-014]</span>
</pre></div>
</div>
<p>Same thing without the added noise</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">full</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="c"># c[0], c[2] should be &quot;very close to 0&quot;, c[1] ~= -1, c[3] ~= 1</span>
<span class="go">array([ -1.73362882e-17,  -1.00000000e+00,  -2.67471909e-16,</span>
<span class="go">         1.00000000e+00])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span> <span class="c"># note the minuscule SSR</span>
<span class="go">[array([  7.46346754e-31]), 4, array([ 1.38446749,  1.32119158,</span>
<span class="go">0.50443316,  0.28853036]), 1.1324274851176597e-014]</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2009, The Scipy community.
      </li>
      <li>
      Last updated on Nov 10, 2013.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>