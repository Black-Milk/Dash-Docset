
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
  
    <title>1.3. Stochastic Gradient Descent &mdash; scikit-learn 0.14.1 documentation</title>
  <!-- htmltitle is before nature.css - we use this hack to load bootstrap first -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="../_static/css/bootstrap.min.css" media="screen" />
  <link rel="stylesheet" href="../_static/css/bootstrap-responsive.css"/>

    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.14.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="top" title="scikit-learn 0.14.1 documentation" href="../index.html" />
    <link rel="up" title="1. Supervised learning" href="../supervised_learning.html" />
    <link rel="next" title="1.4. Nearest Neighbors" href="neighbors.html" />
    <link rel="prev" title="1.2. Support Vector Machines" href="svm.html" />
  
   
       <script type="text/javascript" src="../_static/sidebar.js"></script>
   
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="../_static/js/bootstrap.min.js" type="text/javascript"></script>
  <link rel="canonical" href="http://scikit-learn.org/stable/modules/sgd.html" />

  <script type="text/javascript">
    $("div.buttonNext, div.buttonPrevious").hover(
       function () {
           $(this).css('background-color', '#FF9C34');
       },
       function () {
           $(this).css('background-color', '#A7D6E2');
       }
    );
    var bodywrapper = $('.bodywrapper');
    var sidebarbutton = $('#sidebarbutton');
    sidebarbutton.css({'height': '900px'});
  </script>

  </head>
  <body>

<div class="header-wrapper">
    <div class="header">
        <p class="logo"><a href="../index.html">
            <img src="../_static/scikit-learn-logo-small.png" alt="Logo"/>
        </a>
        </p><div class="navbar">
            <ul>
                <li><a href="../../stable/index.html">Home</a></li>
                <li><a href="../../stable/install.html">Installation</a></li>
                <li class="btn-li"><div class="btn-group">
		      <a href="../documentation.html">Documentation</a>
		      <a class="btn dropdown-toggle" data-toggle="dropdown">
			     <span class="caret"></span>
		      </a>
		      <ul class="dropdown-menu">
			<li class="link-title">Scikit-learn 0.14 (stable)</li>
			<li><a href="../tutorial/index.html">Tutorials</a></li>
			<li><a href="../user_guide.html">User guide</a></li>
			<li><a href="classes.html">API</a></li>
			<li class="divider"></li>
		        <li><a href="http://scikit-learn.org/dev/documentation.html">Development</a></li>
		        <li><a href="http://scikit-learn.org/0.13/">Scikit-learn 0.13</a></li>
		        <li><a href="http://scikit-learn.org/0.12/">Scikit-learn 0.12</a></li>
		        <li><a href="http://scikit-learn.org/0.11/">Scikit-learn 0.11</a></li>
		        <li><a href="../documentation.html">More versions...</a></li>
		      </ul>
		    </div>
		</li>
            <li><a href="../auto_examples/index.html">Examples</a></li>
            </ul>

            <div class="search_form">
                <div id="cse" style="width: 100%;"></div>
            </div>
        </div> <!-- end navbar --></div>
</div>


<!-- Github "fork me" ribbon -->
<a href="https://github.com/scikit-learn/scikit-learn">
  <img class="fork-me"
       style="position: absolute; top: 0; right: 0; border: 0;"
       src="../_static/img/forkme.png"
       alt="Fork me on GitHub" />
</a>

<div class="content-wrapper">
    <div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
        <div class="rel">
    

  <!-- rellinks[1:] is an ugly hack to avoid link to module
  index -->
        <div class="rellink">
        <a href="svm.html"
        accesskey="P">Previous
        <br/>
        <span class="smallrellink">
        1.2. Support Vec...
        </span>
            <span class="hiddenrellink">
            1.2. Support Vector Machines
            </span>
        </a>
        </div>
            <div class="spacer">
            &nbsp;
            </div>
        <div class="rellink">
        <a href="neighbors.html"
        accesskey="N">Next
        <br/>
        <span class="smallrellink">
        1.4. Nearest Nei...
        </span>
            <span class="hiddenrellink">
            1.4. Nearest Neighbors
            </span>
        </a>
        </div>
            <div class="spacer">
            &nbsp;
            </div>
        <div class="rellink">
        <a href="../np-modindex.html"
        >Modules
        <br/>
        <span class="smallrellink">
        Python Module In...
        </span>
            <span class="hiddenrellink">
            Python Module Index
            </span>
        </a>
        </div>
            <div class="spacer">
            &nbsp;
            </div>
        <div class="rellink">
        <a href="../py-modindex.html"
        >Modules
        <br/>
        <span class="smallrellink">
        Python Module In...
        </span>
            <span class="hiddenrellink">
            Python Module Index
            </span>
        </a>
        </div>

    <!-- Ad a link to the 'up' page -->
        <div class="spacer">
        &nbsp;
        </div>
        <div class="rellink">
        <a href="../supervised_learning.html">
        Up
        <br/>
        <span class="smallrellink">
        1. Supervised le...
        </span>
            <span class="hiddenrellink">
            1. Supervised learning
            </span>
            
        </a>
        </div>
    </div>
    
      <p class="doc-version">This documentation is for scikit-learn <strong>version 0.14.1</strong> &mdash; <a href="http://scikit-learn.org/stable/support.html#documentation-resources">Other versions</a></p>
    <p class="citing">If you use the software, please consider <a href="../about.html#citing-scikit-learn">citing scikit-learn</a>.</p>
    <ul>
<li><a class="reference internal" href="#">1.3. Stochastic Gradient Descent</a><ul>
<li><a class="reference internal" href="#classification">1.3.1. Classification</a></li>
<li><a class="reference internal" href="#regression">1.3.2. Regression</a></li>
<li><a class="reference internal" href="#stochastic-gradient-descent-for-sparse-data">1.3.3. Stochastic Gradient Descent for sparse data</a></li>
<li><a class="reference internal" href="#complexity">1.3.4. Complexity</a></li>
<li><a class="reference internal" href="#tips-on-practical-use">1.3.5. Tips on Practical Use</a></li>
<li><a class="reference internal" href="#mathematical-formulation">1.3.6. Mathematical formulation</a><ul>
<li><a class="reference internal" href="#id1">1.3.6.1. SGD</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-details">1.3.7. Implementation details</a></li>
</ul>
</li>
</ul>

    </div>
</div>



      <div class="content">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="stochastic-gradient-descent">
<span id="sgd"></span><h1>1.3. Stochastic Gradient Descent<a class="headerlink" href="#stochastic-gradient-descent" title="Permalink to this headline">¶</a></h1>
<p><strong>Stochastic Gradient Descent (SGD)</strong> is a simple yet very efficient
approach to discriminative learning of linear classifiers under
convex loss functions such as (linear) <a class="reference external" href="http://en.wikipedia.org/wiki/Support_vector_machine">Support Vector Machines</a> and <a class="reference external" href="http://en.wikipedia.org/wiki/Logistic_regression">Logistic
Regression</a>.
Even though SGD has been around in the machine learning community for
a long time, it has received a considerable amount of attention just
recently in the context of large-scale learning.</p>
<p>SGD has been successfully applied to large-scale and sparse machine
learning problems often encountered in text classification and natural
language processing.  Given that the data is sparse, the classifiers
in this module easily scale to problems with more than 10^5 training
examples and more than 10^5 features.</p>
<p>The advantages of Stochastic Gradient Descent are:</p>
<blockquote>
<div><ul class="simple">
<li>Efficiency.</li>
<li>Ease of implementation (lots of opportunities for code tuning).</li>
</ul>
</div></blockquote>
<p>The disadvantages of Stochastic Gradient Descent include:</p>
<blockquote>
<div><ul class="simple">
<li>SGD requires a number of hyperparameters such as the regularization
parameter and the number of iterations.</li>
<li>SGD is sensitive to feature scaling.</li>
</ul>
</div></blockquote>
<div class="section" id="classification">
<h2>1.3.1. Classification<a class="headerlink" href="#classification" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Make sure you permute (shuffle) your training data before fitting the
model or use <tt class="docutils literal"><span class="pre">shuffle=True</span></tt> to shuffle after each iterations.</p>
</div>
<p>The class <a class="reference internal" href="generated/sklearn.linear_model.SGDClassifier.html#sklearn.linear_model.SGDClassifier" title="sklearn.linear_model.SGDClassifier"><tt class="xref py py-class docutils literal"><span class="pre">SGDClassifier</span></tt></a> implements a plain stochastic gradient
descent learning routine which supports different loss functions and
penalties for classification.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/linear_model/plot_sgd_separating_hyperplane.html"><img alt="../_images/plot_sgd_separating_hyperplane_11.png" src="../_images/plot_sgd_separating_hyperplane_11.png" style="width: 600.0px; height: 450.0px;" /></a>
</div>
<p>As other classifiers, SGD has to be fitted with two arrays: an array X
of size [n_samples, n_features] holding the training samples, and an
array Y of size [n_samples] holding the target values (class labels)
for the training samples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">SGDClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">SGDClassifier</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="s">&quot;hinge&quot;</span><span class="p">,</span> <span class="n">penalty</span><span class="o">=</span><span class="s">&quot;l2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">SGDClassifier(alpha=0.0001, class_weight=None, epsilon=0.1, eta0=0.0,</span>
<span class="go">       fit_intercept=True, l1_ratio=0.15, learning_rate=&#39;optimal&#39;,</span>
<span class="go">       loss=&#39;hinge&#39;, n_iter=5, n_jobs=1, penalty=&#39;l2&#39;, power_t=0.5,</span>
<span class="go">       random_state=None, shuffle=False, verbose=0, warm_start=False)</span>
</pre></div>
</div>
<p>After being fitted, the model can then be used to predict new values:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">([[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]])</span>
<span class="go">array([1])</span>
</pre></div>
</div>
<p>SGD fits a linear model to the training data. The member <tt class="docutils literal"><span class="pre">coef_</span></tt> holds
the model parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">coef_</span>
<span class="go">array([[ 9.91080278,  9.91080278]])</span>
</pre></div>
</div>
<p>Member <tt class="docutils literal"><span class="pre">intercept_</span></tt> holds the intercept (aka offset or bias):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">intercept_</span>                                    
<span class="go">array([-9.990...])</span>
</pre></div>
</div>
<p>Whether or not the model should use an intercept, i.e. a biased
hyperplane, is controlled by the parameter <tt class="docutils literal"><span class="pre">fit_intercept</span></tt>.</p>
<p>To get the signed distance to the hyperplane use <a class="reference internal" href="generated/sklearn.linear_model.SGDClassifier.html#sklearn.linear_model.SGDClassifier.decision_function" title="sklearn.linear_model.SGDClassifier.decision_function"><tt class="xref py py-meth docutils literal"><span class="pre">SGDClassifier.decision_function</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">decision_function</span><span class="p">([[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]])</span>
<span class="go">array([ 29.65318117])</span>
</pre></div>
</div>
<p>The concrete loss function can be set via the <tt class="docutils literal"><span class="pre">loss</span></tt>
parameter. <a class="reference internal" href="generated/sklearn.linear_model.SGDClassifier.html#sklearn.linear_model.SGDClassifier" title="sklearn.linear_model.SGDClassifier"><tt class="xref py py-class docutils literal"><span class="pre">SGDClassifier</span></tt></a> supports the following loss functions:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">loss=&quot;hinge&quot;</span></tt>: (soft-margin) linear Support Vector Machine,</li>
<li><tt class="docutils literal"><span class="pre">loss=&quot;modified_huber&quot;</span></tt>: smoothed hinge loss,</li>
<li><tt class="docutils literal"><span class="pre">loss=&quot;log&quot;</span></tt>: logistic regression,</li>
<li>and all regression losses below.</li>
</ul>
</div></blockquote>
<p>The first two loss functions are lazy, they only update the model
parameters if an example violates the margin constraint, which makes
training very efficient and may result in sparser models, even when L2 penalty
is used.</p>
<p>Using <tt class="docutils literal"><span class="pre">loss=&quot;log&quot;</span></tt> or <tt class="docutils literal"><span class="pre">loss=&quot;modified_huber&quot;</span></tt> enables the
<tt class="docutils literal"><span class="pre">predict_proba</span></tt> method, which gives a vector of probability estimates
<img class="math" src="../_images/math/25a9728b809a691ce3374eaeab6255410cbff5d9.png" alt="P(y|x)"/> per sample <img class="math" src="../_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">SGDClassifier</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="s">&quot;log&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
<span class="go">array([[ 0.0000005,  0.9999995]])</span>
</pre></div>
</div>
<p>The concrete penalty can be set via the <tt class="docutils literal"><span class="pre">penalty</span></tt> parameter.
SGD supports the following penalties:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">penalty=&quot;l2&quot;</span></tt>: L2 norm penalty on <tt class="docutils literal"><span class="pre">coef_</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">penalty=&quot;l1&quot;</span></tt>: L1 norm penalty on <tt class="docutils literal"><span class="pre">coef_</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">penalty=&quot;elasticnet&quot;</span></tt>: Convex combination of L2 and L1; <cite>(1 - l1_ratio) * L2 + l1_ratio * L1</cite>.</li>
</ul>
</div></blockquote>
<p>The default setting is <tt class="docutils literal"><span class="pre">penalty=&quot;l2&quot;</span></tt>. The L1 penalty leads to sparse
solutions, driving most coefficients to zero. The Elastic Net solves
some deficiencies of the L1 penalty in the presence of highly correlated
attributes. The parameter <tt class="docutils literal"><span class="pre">l1_ratio</span></tt> controls the convex combination
of L1 and L2 penalty.</p>
<p><a class="reference internal" href="generated/sklearn.linear_model.SGDClassifier.html#sklearn.linear_model.SGDClassifier" title="sklearn.linear_model.SGDClassifier"><tt class="xref py py-class docutils literal"><span class="pre">SGDClassifier</span></tt></a> supports multi-class classification by combining
multiple binary classifiers in a &#8220;one versus all&#8221; (OVA) scheme. For each
of the <cite>K</cite> classes, a binary classifier is learned that discriminates
between that and all other <cite>K-1</cite> classes. At testing time, we compute the
confidence score (i.e. the signed distances to the hyperplane) for each
classifier and choose the class with the highest confidence. The Figure
below illustrates the OVA approach on the iris dataset.  The dashed
lines represent the three OVA classifiers; the background colors show
the decision surface induced by the three classifiers.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/linear_model/plot_sgd_iris.html"><img alt="../_images/plot_sgd_iris_11.png" src="../_images/plot_sgd_iris_11.png" style="width: 600.0px; height: 450.0px;" /></a>
</div>
<p>In the case of multi-class classification <tt class="docutils literal"><span class="pre">coef_</span></tt> is a two-dimensionally
array of <tt class="docutils literal"><span class="pre">shape=[n_classes,</span> <span class="pre">n_features]</span></tt> and <tt class="docutils literal"><span class="pre">intercept_</span></tt> is a one
dimensional array of <tt class="docutils literal"><span class="pre">shape=[n_classes]</span></tt>. The i-th row of <tt class="docutils literal"><span class="pre">coef_</span></tt> holds
the weight vector of the OVA classifier for the i-th class; classes are
indexed in ascending order (see attribute <tt class="docutils literal"><span class="pre">classes_</span></tt>).
Note that, in principle, since they allow to create a probability model,
<tt class="docutils literal"><span class="pre">loss=&quot;log&quot;</span></tt> and <tt class="docutils literal"><span class="pre">loss=&quot;modified_huber&quot;</span></tt> are more suitable for
one-vs-all classification.</p>
<p><a class="reference internal" href="generated/sklearn.linear_model.SGDClassifier.html#sklearn.linear_model.SGDClassifier" title="sklearn.linear_model.SGDClassifier"><tt class="xref py py-class docutils literal"><span class="pre">SGDClassifier</span></tt></a> supports both weighted classes and weighted
instances via the fit parameters <tt class="docutils literal"><span class="pre">class_weight</span></tt> and <tt class="docutils literal"><span class="pre">sample_weight</span></tt>. See
the examples below and the doc string of <a class="reference internal" href="generated/sklearn.linear_model.SGDClassifier.html#sklearn.linear_model.SGDClassifier.fit" title="sklearn.linear_model.SGDClassifier.fit"><tt class="xref py py-meth docutils literal"><span class="pre">SGDClassifier.fit</span></tt></a> for
further information.</p>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/linear_model/plot_sgd_separating_hyperplane.html#example-linear-model-plot-sgd-separating-hyperplane-py"><em>SGD: Maximum margin separating hyperplane</em></a>,</li>
<li><a class="reference internal" href="../auto_examples/linear_model/plot_sgd_iris.html#example-linear-model-plot-sgd-iris-py"><em>Plot multi-class SGD on the iris dataset</em></a></li>
<li><a class="reference internal" href="../auto_examples/linear_model/plot_sgd_weighted_samples.html#example-linear-model-plot-sgd-weighted-samples-py"><em>SGD: Weighted samples</em></a></li>
<li><a class="reference internal" href="../auto_examples/svm/plot_separating_hyperplane_unbalanced.html#example-svm-plot-separating-hyperplane-unbalanced-py"><em>SVM: Separating hyperplane for unbalanced classes</em></a> (See the <cite>Note</cite>)</li>
</ul>
</div>
</div>
<div class="section" id="regression">
<h2>1.3.2. Regression<a class="headerlink" href="#regression" title="Permalink to this headline">¶</a></h2>
<p>The class <a class="reference internal" href="generated/sklearn.linear_model.SGDRegressor.html#sklearn.linear_model.SGDRegressor" title="sklearn.linear_model.SGDRegressor"><tt class="xref py py-class docutils literal"><span class="pre">SGDRegressor</span></tt></a> implements a plain stochastic gradient
descent learning routine which supports different loss functions and
penalties to fit linear regression models. <a class="reference internal" href="generated/sklearn.linear_model.SGDRegressor.html#sklearn.linear_model.SGDRegressor" title="sklearn.linear_model.SGDRegressor"><tt class="xref py py-class docutils literal"><span class="pre">SGDRegressor</span></tt></a> is
well suited for regression problems with a large number of training
samples (&gt; 10.000), for other problems we recommend <a class="reference internal" href="generated/sklearn.linear_model.Ridge.html#sklearn.linear_model.Ridge" title="sklearn.linear_model.Ridge"><tt class="xref py py-class docutils literal"><span class="pre">Ridge</span></tt></a>,
<a class="reference internal" href="generated/sklearn.linear_model.Lasso.html#sklearn.linear_model.Lasso" title="sklearn.linear_model.Lasso"><tt class="xref py py-class docutils literal"><span class="pre">Lasso</span></tt></a>, or <a class="reference internal" href="generated/sklearn.linear_model.ElasticNet.html#sklearn.linear_model.ElasticNet" title="sklearn.linear_model.ElasticNet"><tt class="xref py py-class docutils literal"><span class="pre">ElasticNet</span></tt></a>.</p>
<p>The concrete loss function can be set via the <tt class="docutils literal"><span class="pre">loss</span></tt>
parameter. <a class="reference internal" href="generated/sklearn.linear_model.SGDRegressor.html#sklearn.linear_model.SGDRegressor" title="sklearn.linear_model.SGDRegressor"><tt class="xref py py-class docutils literal"><span class="pre">SGDRegressor</span></tt></a> supports the following loss functions:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">loss=&quot;squared_loss&quot;</span></tt>: Ordinary least squares,</li>
<li><tt class="docutils literal"><span class="pre">loss=&quot;huber&quot;</span></tt>: Huber loss for robust regression,</li>
<li><tt class="docutils literal"><span class="pre">loss=&quot;epsilon_insensitive&quot;</span></tt>: linear Support Vector Regression.</li>
</ul>
</div></blockquote>
<p>The Huber and epsilon-insensitive loss functions can be used for
robust regression. The width of the insensitive region has to be
specified via the parameter <tt class="docutils literal"><span class="pre">epsilon</span></tt>. This parameter depends on the
scale of the target variables.</p>
</div>
<div class="section" id="stochastic-gradient-descent-for-sparse-data">
<h2>1.3.3. Stochastic Gradient Descent for sparse data<a class="headerlink" href="#stochastic-gradient-descent-for-sparse-data" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The sparse implementation produces slightly different results
than the dense implementation due to a shrunk learning rate for the
intercept.</p>
</div>
<p>There is built-in support for sparse data given in any matrix in a format
supported by <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.html">scipy.sparse</a>. For maximum efficiency, however, use the CSR
matrix format as defined in <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html">scipy.sparse.csr_matrix</a>.</p>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/document_classification_20newsgroups.html#example-document-classification-20newsgroups-py"><em>Classification of text documents using sparse features</em></a></li>
</ul>
</div>
</div>
<div class="section" id="complexity">
<h2>1.3.4. Complexity<a class="headerlink" href="#complexity" title="Permalink to this headline">¶</a></h2>
<p>The major advantage of SGD is its efficiency, which is basically
linear in the number of training examples. If X is a matrix of size (n, p)
training has a cost of <img class="math" src="../_images/math/93aa7f61c5ca120b643faa21a01cf5c504851f8c.png" alt="O(k n \bar p)"/>, where k is the number
of iterations (epochs) and <img class="math" src="../_images/math/2c5d2ee447e5be49d4e3b1e7d40c49c76329e686.png" alt="\bar p"/> is the average number of
non-zero attributes per sample.</p>
<p>Recent theoretical results, however, show that the runtime to get some
desired optimization accuracy does not increase as the training set size increases.</p>
</div>
<div class="section" id="tips-on-practical-use">
<h2>1.3.5. Tips on Practical Use<a class="headerlink" href="#tips-on-practical-use" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul>
<li><p class="first">Stochastic Gradient Descent is sensitive to feature scaling, so it
is highly recommended to scale your data. For example, scale each
attribute on the input vector X to [0,1] or [-1,+1], or standardize
it to have mean 0 and variance 1. Note that the <em>same</em> scaling
must be applied to the test vector to obtain meaningful
results. This can be easily done using <tt class="xref py py-class docutils literal"><span class="pre">StandardScaler</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
<span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>  <span class="c"># Don&#39;t cheat - fit only on training data</span>
<span class="n">X_train</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>  <span class="c"># apply same transformation to test data</span>
</pre></div>
</div>
<p>If your attributes have an intrinsic scale (e.g. word frequencies or
indicator features) scaling is not needed.</p>
</li>
<li><p class="first">Finding a reasonable regularization term <img class="math" src="../_images/math/ad59b6e24a4a00ac621801f8d7513d68be654ab5.png" alt="\alpha"/> is
best done using <tt class="xref py py-class docutils literal"><span class="pre">GridSearchCV</span></tt>, usually in the
range <tt class="docutils literal"><span class="pre">10.0**-np.arange(1,7)</span></tt>.</p>
</li>
<li><p class="first">Empirically, we found that SGD converges after observing
approx. 10^6 training samples. Thus, a reasonable first guess
for the number of iterations is <tt class="docutils literal"><span class="pre">n_iter</span> <span class="pre">=</span> <span class="pre">np.ceil(10**6</span> <span class="pre">/</span> <span class="pre">n)</span></tt>,
where <tt class="docutils literal"><span class="pre">n</span></tt> is the size of the training set.</p>
</li>
<li><p class="first">If you apply SGD to features extracted using PCA we found that
it is often wise to scale the feature values by some constant <cite>c</cite>
such that the average L2 norm of the training data equals one.</p>
</li>
</ul>
</div></blockquote>
<div class="topic">
<p class="topic-title first">References:</p>
<ul class="simple">
<li><a class="reference external" href="yann.lecun.com/exdb/publis/pdf/lecun-98b.pdf">&#8220;Efficient BackProp&#8221;</a>
Y. LeCun, L. Bottou, G. Orr, K. Müller - In Neural Networks: Tricks
of the Trade 1998.</li>
</ul>
</div>
</div>
<div class="section" id="mathematical-formulation">
<span id="sgd-mathematical-formulation"></span><h2>1.3.6. Mathematical formulation<a class="headerlink" href="#mathematical-formulation" title="Permalink to this headline">¶</a></h2>
<p>Given a set of training examples <img class="math" src="../_images/math/4af6492b1bf93d4be0e1f0c75f85f65170ed94c0.png" alt="(x_1, y_1), \ldots, (x_n, y_n)"/> where
<img class="math" src="../_images/math/ed7238746ec0fb27be38187ff0576c83ecc0df8f.png" alt="x_i \in \mathbf{R}^n"/> and <img class="math" src="../_images/math/bb280b0cec96f69df3ad1c8befd46a0a95e843ac.png" alt="y_i \in \{-1,1\}"/>, our goal is to
learn a linear scoring function <img class="math" src="../_images/math/3bd8e83af63059e1332f577c656fdff3e8158e74.png" alt="f(x) = w^T x + b"/> with model parameters
<img class="math" src="../_images/math/e0f293430b347291b63495a02f47d30e35fa7229.png" alt="w \in \mathbf{R}^m"/> and intercept <img class="math" src="../_images/math/8b75b89abc229b96382c47277d6f475f634940d9.png" alt="b \in \mathbf{R}"/>. In order
to make predictions, we simply look at the sign of <img class="math" src="../_images/math/14546c27a7b929642f7840acca5f851c503ea109.png" alt="f(x)"/>.
A common choice to find the model parameters is by minimizing the regularized
training error given by</p>
<div class="math">
<p><img src="../_images/math/4782697c94f74995ee99624f00633bba53f5245f.png" alt="E(w,b) = \frac{1}{n}\sum_{i=1}^{n} L(y_i, f(x_i)) + \alpha R(w)"/></p>
</div><p>where <img class="math" src="../_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/> is a loss function that measures model (mis)fit and
<img class="math" src="../_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/> is a regularization term (aka penalty) that penalizes model
complexity; <img class="math" src="../_images/math/7f2c98bf462cba6083cf18483ba9510e3c2fd3d3.png" alt="\alpha &gt; 0"/> is a non-negative hyperparameter.</p>
<p>Different choices for <img class="math" src="../_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/> entail different classifiers such as</p>
<blockquote>
<div><ul class="simple">
<li>Hinge: (soft-margin) Support Vector Machines.</li>
<li>Log:   Logistic Regression.</li>
<li>Least-Squares: Ridge Regression.</li>
<li>Epsilon-Insensitive: (soft-margin) Support Vector Regression.</li>
</ul>
</div></blockquote>
<p>All of the above loss functions can be regarded as an upper bound on the
misclassification error (Zero-one loss) as shown in the Figure below.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/plot_sgd_loss_functions_11.png"><img alt="../_images/plot_sgd_loss_functions_11.png" src="../_images/plot_sgd_loss_functions_11.png" style="width: 600.0px; height: 450.0px;" /></a>
</div>
<p>Popular choices for the regularization term <img class="math" src="../_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/> include:</p>
<blockquote>
<div><ul class="simple">
<li>L2 norm: <img class="math" src="../_images/math/a16847a5124181d9b7752831345def32c7688718.png" alt="R(w) := \frac{1}{2} \sum_{i=1}^{n} w_i^2"/>,</li>
<li>L1 norm: <img class="math" src="../_images/math/9dcd00d73a520a96fcccfa317471aab11d8b1ce7.png" alt="R(w) := \sum_{i=1}^{n} |w_i|"/>, which leads to sparse
solutions.</li>
<li>Elastic Net: <img class="math" src="../_images/math/6d786bc0d556134fd2cd2ff743dd4b1a711bb541.png" alt="R(w) := \frac{\rho}{2} \sum_{i=1}^{n} w_i^2 + (1-\rho) \sum_{i=1}^{n} |w_i|"/>, a convex combination of L2 and L1, where <img class="math" src="../_images/math/f574498915fa9e02eeb5141c24835d077eba3e75.png" alt="\rho"/> is given by <tt class="docutils literal"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">l1_ratio</span></tt>.</li>
</ul>
</div></blockquote>
<p>The Figure below shows the contours of the different regularization terms
in the parameter space when <img class="math" src="../_images/math/c12181d671649ed5892696252202bba516d28d3a.png" alt="R(w) = 1"/>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/plot_sgd_penalties_11.png"><img alt="../_images/plot_sgd_penalties_11.png" src="../_images/plot_sgd_penalties_11.png" style="width: 600.0px; height: 450.0px;" /></a>
</div>
<div class="section" id="id1">
<h3>1.3.6.1. SGD<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Stochastic gradient descent is an optimization method for unconstrained
optimization problems. In contrast to (batch) gradient descent, SGD
approximates the true gradient of <img class="math" src="../_images/math/d5d48823181b7f7a9e96c9cbd3bb70d04abdbd9d.png" alt="E(w,b)"/> by considering a
single training example at a time.</p>
<p>The class <a class="reference internal" href="generated/sklearn.linear_model.SGDClassifier.html#sklearn.linear_model.SGDClassifier" title="sklearn.linear_model.SGDClassifier"><tt class="xref py py-class docutils literal"><span class="pre">SGDClassifier</span></tt></a> implements a first-order SGD learning
routine.  The algorithm iterates over the training examples and for each
example updates the model parameters according to the update rule given by</p>
<div class="math">
<p><img src="../_images/math/98cdc3aed40cb93594dbaaf045ea3e1abbd8edcb.png" alt="w \leftarrow w - \eta (\alpha \frac{\partial R(w)}{\partial w}
+ \frac{\partial L(w^T x_i + b, y_i)}{\partial w})"/></p>
</div><p>where <img class="math" src="../_images/math/9172efc523d7488d4c3ed299d0be813de01503b8.png" alt="\eta"/> is the learning rate which controls the step-size in
the parameter space.  The intercept <img class="math" src="../_images/math/5e87bf41a96deddf6cb485ff530f153f2590e9cc.png" alt="b"/> is updated similarly but
without regularization.</p>
<p>The learning rate <img class="math" src="../_images/math/9172efc523d7488d4c3ed299d0be813de01503b8.png" alt="\eta"/> can be either constant or gradually decaying. For
classification, the default learning rate schedule (<tt class="docutils literal"><span class="pre">learning_rate='optimal'</span></tt>)
is given by</p>
<div class="math">
<p><img src="../_images/math/f12f7e91b0d9d96b5e417194a1a348c718b981b1.png" alt="\eta^{(t)} = \frac {1}{\alpha  (t_0 + t)}"/></p>
</div><p>where <img class="math" src="../_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/> is the time step (there are a total of <cite>n_samples * n_iter</cite>
time steps), <img class="math" src="../_images/math/fb761c2e199ad45ccf14767f48b88169479d840f.png" alt="t_0"/> is determined based on a heuristic proposed by Léon Bottou
such that the expected initial updates are comparable with the expected
size of the weights (this assuming that the norm of the training samples is
approx. 1). The exact definition can be found in <tt class="docutils literal"><span class="pre">_init_t</span></tt> in <tt class="xref py py-class docutils literal"><span class="pre">BaseSGD</span></tt>.</p>
<p>For regression the default learning rate schedule is inverse scaling
(<tt class="docutils literal"><span class="pre">learning_rate='invscaling'</span></tt>), given by</p>
<div class="math">
<p><img src="../_images/math/1e8904a391eec39276c9794f76d1b3a247e5fdf0.png" alt="\eta^{(t)} = \frac{eta_0}{t^{power\_t}}"/></p>
</div><p>where <img class="math" src="../_images/math/17ed5419fbfe317f160a2be3da9c6f0ce53b5b86.png" alt="eta_0"/> and <img class="math" src="../_images/math/138a8dd99b6da12de6f02b76afeda6e5885a7f7c.png" alt="power\_t"/> are hyperparameters chosen by the
user via <tt class="docutils literal"><span class="pre">eta0</span></tt> and <tt class="docutils literal"><span class="pre">power_t</span></tt>, resp.</p>
<p>For a constant learning rate use <tt class="docutils literal"><span class="pre">learning_rate='constant'</span></tt> and use <tt class="docutils literal"><span class="pre">eta0</span></tt>
to specify the learning rate.</p>
<p>The model parameters can be accessed through the members <tt class="docutils literal"><span class="pre">coef_</span></tt> and
<tt class="docutils literal"><span class="pre">intercept_</span></tt>:</p>
<blockquote>
<div><ul class="simple">
<li>Member <tt class="docutils literal"><span class="pre">coef_</span></tt> holds the weights <img class="math" src="../_images/math/8659700e6646cd91bc02c32affaa5ec046ee9935.png" alt="w"/></li>
<li>Member <tt class="docutils literal"><span class="pre">intercept_</span></tt> holds <img class="math" src="../_images/math/5e87bf41a96deddf6cb485ff530f153f2590e9cc.png" alt="b"/></li>
</ul>
</div></blockquote>
<div class="topic">
<p class="topic-title first">References:</p>
<ul class="simple">
<li><a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.58.7377">&#8220;Solving large scale linear prediction problems using stochastic
gradient descent algorithms&#8221;</a>
T. Zhang - In Proceedings of ICML &#8216;04.</li>
<li><a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.124.4696">&#8220;Regularization and variable selection via the elastic net&#8221;</a>
H. Zou, T. Hastie - Journal of the Royal Statistical Society Series B,
67 (2), 301-320.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="implementation-details">
<h2>1.3.7. Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<p>The implementation of SGD is influenced by the <a class="reference external" href="http://leon.bottou.org/projects/sgd">Stochastic Gradient SVM</a>  of Léon Bottou. Similar to SvmSGD,
the weight vector is represented as the product of a scalar and a vector
which allows an efficient weight update in the case of L2 regularization.
In the case of sparse feature vectors, the intercept is updated with a
smaller learning rate (multiplied by 0.01) to account for the fact that
it is updated more frequently. Training examples are picked up sequentially
and the learning rate is lowered after each observed example. We adopted the
learning rate schedule from Shalev-Shwartz et al. 2007.
For multi-class classification, a &#8220;one versus all&#8221; approach is used.
We use the truncated gradient algorithm proposed by Tsuruoka et al. 2009
for L1 regularization (and the Elastic Net).
The code is written in Cython.</p>
<div class="topic">
<p class="topic-title first">References:</p>
<ul class="simple">
<li><a class="reference external" href="http://leon.bottou.org/projects/sgd">&#8220;Stochastic Gradient Descent&#8221;</a> L. Bottou - Website, 2010.</li>
<li><a class="reference external" href="http://leon.bottou.org/slides/largescale/lstut.pdf">&#8220;The Tradeoffs of Large Scale Machine Learning&#8221;</a> L. Bottou - Website, 2011.</li>
<li><a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.74.8513">&#8220;Pegasos: Primal estimated sub-gradient solver for svm&#8221;</a>
S. Shalev-Shwartz, Y. Singer, N. Srebro - In Proceedings of ICML &#8216;07.</li>
<li><a class="reference external" href="http://www.aclweb.org/anthology/P/P09/P09-1054.pdf">&#8220;Stochastic gradient descent training for l1-regularized log-linear models with cumulative penalty&#8221;</a>
Y. Tsuruoka, J. Tsujii, S. Ananiadou -  In Proceedings of the AFNLP/ACL &#8216;09.</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer">
        &copy; 2010 - 2014, scikit-learn developers (BSD License).
      <a href="../_sources/modules/sgd.txt" rel="nofollow">Show this page source</a>
    </div>
     <div class="rel">
    
    <div class="buttonPrevious">
      <a href="svm.html">Previous
      </a>
    </div>
    <div class="buttonNext">
      <a href="neighbors.html">Next
      </a>
    </div>
    <div class="buttonPrevious">
      <a href="../np-modindex.html">Previous
      </a>
    </div>
    <div class="buttonNext">
      <a href="../py-modindex.html">Next
      </a>
    </div>
    
     </div>

    
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-22606712-2']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    

    <script src="http://www.google.com/jsapi" type="text/javascript"></script>
    <script type="text/javascript"> google.load('search', '1',
        {language : 'en'}); google.setOnLoadCallback(function() {
            var customSearchControl = new
            google.search.CustomSearchControl('016639176250731907682:tjtqbvtvij0');
            customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
            var options = new google.search.DrawOptions();
            options.setAutoComplete(true);
            customSearchControl.draw('cse', options); }, true);
    </script>
  </body>
</html>