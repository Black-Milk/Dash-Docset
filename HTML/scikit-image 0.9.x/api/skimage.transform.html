



<!DOCTYPE html>
<html lang="en">
<head>
        <title>Module: transform &mdash; skimage v0.9.0 docs</title>
    
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../_static/css/custom.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
    
    <script src="http://code.jquery.com/jquery-latest.js"></script>
    <script src="../_static/js/bootstrap.min.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <link rel="top" title="skimage v0.9.0 docs" href="../index.html" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="shortcut icon" href="../_static/favicon.ico">
</head>
<body class="container">
    <a href="http://scikit-image.org" class="logo"><img src="../_static/img/logo.png" alt=""></a>
    <div class="clearfix"></div>
    <div class="navbar">
        <div class="navbar-inner">
            <ul class="nav">
                <li><a href="/">Home</a></li>
<li><a href="/download.html">Download</a></li>
<li><a href="/docs/dev/auto_examples">Gallery</a></li>
<li><a href="/docs/dev">Documentation</a></li>
<li><a href="https://github.com/scikit-image/scikit-image">Source</a></li>
            </ul>
            <form class="navbar-form pull-right" action="../search.html" method="get">
                <input type="text" class="search span3" name="q" placeholder="Search documentation ...">
                <input type="hidden" name="check_keywords" value="yes" >
                <input type="hidden" name="area" value="default" >
            </form>
        </div>
    </div>
    <div class="row">
        <div class="span9">
            
  <div class="section" id="module-skimage.transform">
<span id="module-transform"></span><h1>Module: <tt class="xref py py-mod docutils literal"><span class="pre">transform</span></tt><a class="headerlink" href="#module-skimage.transform" title="Permalink to this headline">¶</a></h1>
<div class="section" id="affinetransform">
<h2><a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><tt class="xref py py-class docutils literal"><span class="pre">AffineTransform</span></tt></a><a class="headerlink" href="#affinetransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.AffineTransform">
<em class="property">class </em><tt class="descclassname">skimage.transform.</tt><tt class="descname">AffineTransform</tt><big>(</big><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>shear=None</em>, <em>translation=None</em><big>)</big><a class="headerlink" href="#skimage.transform.AffineTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.transform._geometric.ProjectiveTransform</span></tt></p>
<p>2D affine transformation of the form:</p>
<div class="highlight-python"><pre>X = a0*x + a1*y + a2 =
  = sx*x*cos(rotation) - sy*y*sin(rotation + shear) + a2

Y = b0*x + b1*y + b2 =
  = sx*x*sin(rotation) + sy*y*cos(rotation + shear) + b2</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">sx</span></tt> and <tt class="docutils literal"><span class="pre">sy</span></tt> are zoom factors in the x and y directions,
and the homogeneous transformation matrix is:</p>
<div class="highlight-python"><pre>[[a0  a1  a2]
 [b0  b1  b2]
 [0   0    1]]</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>matrix</strong> : (3, 3) array, optional</p>
<blockquote>
<div><p>Homogeneous transformation matrix.</p>
</div></blockquote>
<p><strong>scale</strong> : (sx, sy) as array, list or tuple, optional</p>
<blockquote>
<div><p>Scale factors.</p>
</div></blockquote>
<p><strong>rotation</strong> : float, optional</p>
<blockquote>
<div><p>Rotation angle in counter-clockwise direction as radians.</p>
</div></blockquote>
<p><strong>shear</strong> : float, optional</p>
<blockquote>
<div><p>Shear angle in counter-clockwise direction as radians.</p>
</div></blockquote>
<p><strong>translation</strong> : (tx, ty) as array, list or tuple, optional</p>
<blockquote class="last">
<div><p>Translation parameters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.AffineTransform.__init__">
<tt class="descname">__init__</tt><big>(</big><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>shear=None</em>, <em>translation=None</em><big>)</big><a class="headerlink" href="#skimage.transform.AffineTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.rotation">
<tt class="descname">rotation</tt><a class="headerlink" href="#skimage.transform.AffineTransform.rotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.scale">
<tt class="descname">scale</tt><a class="headerlink" href="#skimage.transform.AffineTransform.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.shear">
<tt class="descname">shear</tt><a class="headerlink" href="#skimage.transform.AffineTransform.shear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.translation">
<tt class="descname">translation</tt><a class="headerlink" href="#skimage.transform.AffineTransform.translation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="piecewiseaffinetransform">
<h2><a class="reference internal" href="#skimage.transform.PiecewiseAffineTransform" title="skimage.transform.PiecewiseAffineTransform"><tt class="xref py py-class docutils literal"><span class="pre">PiecewiseAffineTransform</span></tt></a><a class="headerlink" href="#piecewiseaffinetransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.PiecewiseAffineTransform">
<em class="property">class </em><tt class="descclassname">skimage.transform.</tt><tt class="descname">PiecewiseAffineTransform</tt><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.transform._geometric.ProjectiveTransform</span></tt></p>
<p>2D piecewise affine transformation.</p>
<p>Control points are used to define the mapping. The transform is based on
a Delaunay triangulation of the points to form a mesh. Each triangle is
used to find a local affine transform.</p>
<dl class="method">
<dt id="skimage.transform.PiecewiseAffineTransform.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.PiecewiseAffineTransform.estimate">
<tt class="descname">estimate</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the control points with which to perform the piecewise mapping.</p>
<p>Number of source and destination coordinates must match.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>src</strong> : (N, 2) array</p>
<blockquote>
<div><p>Source coordinates.</p>
</div></blockquote>
<p><strong>dst</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>Destination coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.PiecewiseAffineTransform.inverse">
<tt class="descname">inverse</tt><big>(</big><em>coords</em><big>)</big><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<p>Coordinates outside of the mesh will be set to <cite>- 1</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>coords</strong> : (N, 2) array</p>
<blockquote>
<div><p>Source coordinates.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>coords</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>Transformed coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="polynomialtransform">
<h2><a class="reference internal" href="#skimage.transform.PolynomialTransform" title="skimage.transform.PolynomialTransform"><tt class="xref py py-class docutils literal"><span class="pre">PolynomialTransform</span></tt></a><a class="headerlink" href="#polynomialtransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.PolynomialTransform">
<em class="property">class </em><tt class="descclassname">skimage.transform.</tt><tt class="descname">PolynomialTransform</tt><big>(</big><em>params=None</em><big>)</big><a class="headerlink" href="#skimage.transform.PolynomialTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.transform._geometric.GeometricTransform</span></tt></p>
<p>2D transformation of the form:</p>
<div class="highlight-python"><pre>X = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i ))
Y = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i ))</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>params</strong> : (2, N) array, optional</p>
<blockquote class="last">
<div><p>Polynomial coefficients where <cite>N * 2 = (order + 1) * (order + 2)</cite>. So,
a_ji is defined in <cite>params[0, :]</cite> and b_ji in <cite>params[1, :]</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.PolynomialTransform.__init__">
<tt class="descname">__init__</tt><big>(</big><em>params=None</em><big>)</big><a class="headerlink" href="#skimage.transform.PolynomialTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.PolynomialTransform.estimate">
<tt class="descname">estimate</tt><big>(</big><em>src</em>, <em>dst</em>, <em>order=2</em><big>)</big><a class="headerlink" href="#skimage.transform.PolynomialTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the transformation matrix with the explicit transformation
parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-python"><pre>X = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i ))
Y = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i ))</pre>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-python"><pre>0 = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i )) - X
0 = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i )) - Y</pre>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-python"><pre>A   = [[1 x y x**2 x*y y**2 ... 0 ...             0 -X]
       [0 ...                 0 1 x y x**2 x*y y**2 -Y]
        ...
        ...
      ]
x.T = [a00 a10 a11 a20 a21 a22 ... ann
       b00 b10 b11 b20 b21 b22 ... bnn c3]</pre>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>src</strong> : (N, 2) array</p>
<blockquote>
<div><p>Source coordinates.</p>
</div></blockquote>
<p><strong>dst</strong> : (N, 2) array</p>
<blockquote>
<div><p>Destination coordinates.</p>
</div></blockquote>
<p><strong>order</strong> : int, optional</p>
<blockquote class="last">
<div><p>Polynomial order (number of coefficients is order + 1).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.PolynomialTransform.inverse">
<tt class="descname">inverse</tt><big>(</big><em>coords</em><big>)</big><a class="headerlink" href="#skimage.transform.PolynomialTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="projectivetransform">
<h2><a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><tt class="xref py py-class docutils literal"><span class="pre">ProjectiveTransform</span></tt></a><a class="headerlink" href="#projectivetransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.ProjectiveTransform">
<em class="property">class </em><tt class="descclassname">skimage.transform.</tt><tt class="descname">ProjectiveTransform</tt><big>(</big><em>matrix=None</em><big>)</big><a class="headerlink" href="#skimage.transform.ProjectiveTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.transform._geometric.GeometricTransform</span></tt></p>
<p>Matrix transformation.</p>
<p>Apply a projective transformation (homography) on coordinates.</p>
<p>For each homogeneous coordinate <img class="math" src="../_images/math/8800e6ed331cf15ba182031609babfac06216a77.png" alt="\mathbf{x} = [x, y, 1]^T"/>, its
target position is calculated by multiplying with the given matrix,
<img class="math" src="../_images/math/b1902d279ba37d60bdce4e0e987b7cd19d48974e.png" alt="H"/>, to give <img class="math" src="../_images/math/42a03cd1c073037bd9cd9e953d4ab607bb70d4c5.png" alt="H \mathbf{x}"/>:</p>
<div class="highlight-python"><pre>[[a0 a1 a2]
 [b0 b1 b2]
 [c0 c1 1 ]].</pre>
</div>
<p>E.g., to rotate by theta degrees clockwise, the matrix should be:</p>
<div class="highlight-python"><pre>[[cos(theta) -sin(theta) 0]
 [sin(theta)  cos(theta) 0]
 [0            0         1]]</pre>
</div>
<p>or, to translate x by 10 and y by 20:</p>
<div class="highlight-python"><pre>[[1 0 10]
 [0 1 20]
 [0 0 1 ]].</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>matrix</strong> : (3, 3) array, optional</p>
<blockquote class="last">
<div><p>Homogeneous transformation matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.ProjectiveTransform.__init__">
<tt class="descname">__init__</tt><big>(</big><em>matrix=None</em><big>)</big><a class="headerlink" href="#skimage.transform.ProjectiveTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.ProjectiveTransform.estimate">
<tt class="descname">estimate</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#skimage.transform.ProjectiveTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the transformation matrix with the explicit transformation
parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">0</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-python"><pre>A   = [[x y 1 0 0 0 -x*X -y*X -X]
       [0 0 0 x y 1 -x*Y -y*Y -Y]
        ...
        ...
      ]
x.T = [a0 a1 a2 b0 b1 b2 c0 c1 c3]</pre>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<p>In case of the affine transformation the coefficients c0 and c1 are 0.
Thus the system of equations is:</p>
<div class="highlight-python"><pre>A   = [[x y 1 0 0 0 -X]
       [0 0 0 x y 1 -Y]
        ...
        ...
      ]
x.T = [a0 a1 a2 b0 b1 b2 c3]</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>src</strong> : (N, 2) array</p>
<blockquote>
<div><p>Source coordinates.</p>
</div></blockquote>
<p><strong>dst</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>Destination coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.ProjectiveTransform.inverse">
<tt class="descname">inverse</tt><big>(</big><em>coords</em><big>)</big><a class="headerlink" href="#skimage.transform.ProjectiveTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>coords</strong> : (N, 2) array</p>
<blockquote>
<div><p>Source coordinates.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>coords</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>Transformed coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="similaritytransform">
<h2><a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><tt class="xref py py-class docutils literal"><span class="pre">SimilarityTransform</span></tt></a><a class="headerlink" href="#similaritytransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.SimilarityTransform">
<em class="property">class </em><tt class="descclassname">skimage.transform.</tt><tt class="descname">SimilarityTransform</tt><big>(</big><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>translation=None</em><big>)</big><a class="headerlink" href="#skimage.transform.SimilarityTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.transform._geometric.ProjectiveTransform</span></tt></p>
<p>2D similarity transformation of the form:</p>
<div class="highlight-python"><pre>X = a0*x - b0*y + a1 =
  = m*x*cos(rotation) + m*y*sin(rotation) + a1

Y = b0*x + a0*y + b1 =
  = m*x*sin(rotation) + m*y*cos(rotation) + b1</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">m</span></tt> is a zoom factor and the homogeneous transformation matrix is:</p>
<div class="highlight-python"><pre>[[a0  b0  a1]
 [b0  a0  b1]
 [0   0    1]]</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>matrix</strong> : (3, 3) array, optional</p>
<blockquote>
<div><p>Homogeneous transformation matrix.</p>
</div></blockquote>
<p><strong>scale</strong> : float, optional</p>
<blockquote>
<div><p>Scale factor.</p>
</div></blockquote>
<p><strong>rotation</strong> : float, optional</p>
<blockquote>
<div><p>Rotation angle in counter-clockwise direction as radians.</p>
</div></blockquote>
<p><strong>translation</strong> : (tx, ty) as array, list or tuple, optional</p>
<blockquote class="last">
<div><p>x, y translation parameters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.SimilarityTransform.__init__">
<tt class="descname">__init__</tt><big>(</big><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>translation=None</em><big>)</big><a class="headerlink" href="#skimage.transform.SimilarityTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.SimilarityTransform.estimate">
<tt class="descname">estimate</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#skimage.transform.SimilarityTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the transformation matrix with the explicit parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">b0</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a1</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a0</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b1</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">0</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">b0</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a0</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-python"><pre>A   = [[x 1 -y 0 -X]
       [y 0  x 1 -Y]
        ...
        ...
      ]
x.T = [a0 a1 b0 b1 c3]</pre>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>src</strong> : (N, 2) array</p>
<blockquote>
<div><p>Source coordinates.</p>
</div></blockquote>
<p><strong>dst</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>Destination coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="skimage.transform.SimilarityTransform.rotation">
<tt class="descname">rotation</tt><a class="headerlink" href="#skimage.transform.SimilarityTransform.rotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.SimilarityTransform.scale">
<tt class="descname">scale</tt><a class="headerlink" href="#skimage.transform.SimilarityTransform.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.SimilarityTransform.translation">
<tt class="descname">translation</tt><a class="headerlink" href="#skimage.transform.SimilarityTransform.translation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.downscale_local_mean</span></tt></a>(...)</td>
<td>Down-sample N-dimensional image by local averaging.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.estimate_transform" title="skimage.transform.estimate_transform"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.estimate_transform</span></tt></a>(ttype,&nbsp;...)</td>
<td>Estimate 2D geometric transformation parameters.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.frt2</span></tt></a>(a)</td>
<td>Compute the 2-dimensional finite radon transform (FRT) for an n x n</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.hough_circle" title="skimage.transform.hough_circle"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.hough_circle</span></tt></a></td>
<td>Perform a circular Hough transform.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.hough_ellipse" title="skimage.transform.hough_ellipse"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.hough_ellipse</span></tt></a></td>
<td>Perform an elliptical Hough transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.hough_line</span></tt></a></td>
<td>Perform a straight line Hough transform.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.hough_line_peaks" title="skimage.transform.hough_line_peaks"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.hough_line_peaks</span></tt></a>(hspace,&nbsp;...)</td>
<td>Return peaks in hough transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.ifrt2</span></tt></a>(a)</td>
<td>Compute the 2-dimensional inverse finite radon transform (iFRT) for</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.integral_image" title="skimage.transform.integral_image"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.integral_image</span></tt></a>(x)</td>
<td>Integral image / summed area table.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.integrate" title="skimage.transform.integrate"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.integrate</span></tt></a>(ii,&nbsp;r0,&nbsp;c0,&nbsp;r1,&nbsp;c1)</td>
<td>Use an integral image to integrate over a given window.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.iradon" title="skimage.transform.iradon"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.iradon</span></tt></a>(radon_image[,&nbsp;...])</td>
<td>Inverse radon transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.iradon_sart" title="skimage.transform.iradon_sart"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.iradon_sart</span></tt></a>(radon_image[,&nbsp;...])</td>
<td>Inverse radon transform</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.probabilistic_hough_line" title="skimage.transform.probabilistic_hough_line"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.probabilistic_hough_line</span></tt></a></td>
<td>Return lines from a progressive probabilistic line Hough transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.pyramid_expand" title="skimage.transform.pyramid_expand"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.pyramid_expand</span></tt></a>(image[,&nbsp;...])</td>
<td>Upsample and then smooth image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.pyramid_gaussian" title="skimage.transform.pyramid_gaussian"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.pyramid_gaussian</span></tt></a>(image[,&nbsp;...])</td>
<td>Yield images of the Gaussian pyramid formed by the input image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.pyramid_laplacian" title="skimage.transform.pyramid_laplacian"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.pyramid_laplacian</span></tt></a>(image[,&nbsp;...])</td>
<td>Yield images of the laplacian pyramid formed by the input image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.pyramid_reduce" title="skimage.transform.pyramid_reduce"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.pyramid_reduce</span></tt></a>(image[,&nbsp;...])</td>
<td>Smooth and then downsample image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.radon" title="skimage.transform.radon"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.radon</span></tt></a>(image[,&nbsp;theta,&nbsp;circle])</td>
<td>Calculates the radon transform of an image given specified projection angles.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.rescale" title="skimage.transform.rescale"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.rescale</span></tt></a>(image,&nbsp;scale[,&nbsp;...])</td>
<td>Scale image by a certain factor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.resize" title="skimage.transform.resize"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.resize</span></tt></a>(image,&nbsp;output_shape)</td>
<td>Resize image to match a certain size.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.rotate" title="skimage.transform.rotate"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.rotate</span></tt></a>(image,&nbsp;angle[,&nbsp;...])</td>
<td>Rotate image by a certain angle around its center.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.swirl" title="skimage.transform.swirl"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.swirl</span></tt></a>(image[,&nbsp;center,&nbsp;...])</td>
<td>Perform a swirl transformation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.warp</span></tt></a>(image[,&nbsp;inverse_map,&nbsp;...])</td>
<td>Warp an image according to a given coordinate transformation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.warp_coords" title="skimage.transform.warp_coords"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.warp_coords</span></tt></a>(coord_map,&nbsp;shape)</td>
<td>Build the source coordinates for the output pixels of an image warp.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="downscale-local-mean">
<h2>downscale_local_mean<a class="headerlink" href="#downscale-local-mean" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.downscale_local_mean">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">downscale_local_mean</tt><big>(</big><em>image</em>, <em>factors</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.transform.downscale_local_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Down-sample N-dimensional image by local averaging.</p>
<p>The image is padded with <cite>cval</cite> if it is not perfectly divisible by the
integer factors.</p>
<p>In contrast to the 2-D interpolation in <cite>skimage.transform.resize</cite> and
<cite>skimage.transform.rescale</cite> this function may be applied to N-dimensional
images and calculates the local mean of elements in each block of size
<cite>factors</cite> in the input image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>N-dimensional input image.</p>
</div></blockquote>
<p><strong>factors</strong> : array_like</p>
<blockquote>
<div><p>Array containing down-sampling integer factor along each axis.</p>
</div></blockquote>
<p><strong>cval</strong> : float, optional</p>
<blockquote>
<div><p>Constant padding value if image is not perfectly divisible by the
integer factors.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote class="last">
<div><p>Down-sampled image with same number of dimensions as input image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="estimate-transform">
<h2>estimate_transform<a class="headerlink" href="#estimate-transform" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.estimate_transform">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">estimate_transform</tt><big>(</big><em>ttype</em>, <em>src</em>, <em>dst</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#skimage.transform.estimate_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate 2D geometric transformation parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>ttype</strong> : {&#8216;similarity&#8217;, &#8216;affine&#8217;, &#8216;piecewise-affine&#8217;, &#8216;projective&#8217;,              &#8216;polynomial&#8217;}</p>
<blockquote>
<div><p>Type of transform.</p>
</div></blockquote>
<p><strong>kwargs</strong> : array or int</p>
<blockquote>
<div><p>Function parameters (src, dst, n, angle):</p>
<div class="highlight-python"><pre>NAME / TTYPE        FUNCTION PARAMETERS
'similarity'        `src, `dst`
'affine'            `src, `dst`
'piecewise-affine'  `src, `dst`
'projective'        `src, `dst`
'polynomial'        `src, `dst`, `order` (polynomial order,
                                          default order is 2)</pre>
</div>
<p>Also see examples below.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>tform</strong> : <tt class="xref py py-class docutils literal"><span class="pre">GeometricTransform</span></tt></p>
<blockquote class="last">
<div><p>Transform object containing the transformation parameters and providing
access to forward and inverse transformation functions.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">transform</span> <span class="k">as</span> <span class="n">tf</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># estimate transformation parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">estimate_transform</span><span class="p">(</span><span class="s">&#39;similarity&#39;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">tform</span><span class="p">(</span><span class="n">src</span><span class="p">))</span> <span class="c"># == src</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># warp image using the estimated transformation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">inverse_map</span><span class="o">=</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># create transformation with explicit parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># unite transformations, applied in order from left to right</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform3</span> <span class="o">=</span> <span class="n">tform</span> <span class="o">+</span> <span class="n">tform2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform3</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="c"># == tform2(tform(src))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="frt2">
<h2>frt2<a class="headerlink" href="#frt2" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.frt2">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">frt2</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#skimage.transform.frt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 2-dimensional finite radon transform (FRT) for an n x n
integer array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>a</strong> : array_like</p>
<blockquote>
<div><p>A 2-D square n x n integer array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>FRT</strong> : 2-D ndarray</p>
<blockquote class="last">
<div><p>Finite Radon Transform array of (n+1) x n integer coefficients.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><tt class="xref py py-obj docutils literal"><span class="pre">ifrt2</span></tt></a></dt>
<dd>The two-dimensional inverse FRT.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The FRT has a unique inverse iff n is prime. [FRT]
The idea for this algorithm is due to Vlad Negnevitski.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="frt" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[FRT]</a></td><td>A. Kingston and I. Svalbe, &#8220;Projective transforms on periodic
discrete image arrays,&#8221; in P. Hawkes (Ed), Advances in Imaging
and Electron Physics, 139 (2006)</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Generate a test image:
Use a prime number for the array dimensions</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SIZE</span> <span class="o">=</span> <span class="mi">59</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Finite Radon Transform:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">frt2</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="hough-circle">
<h2>hough_circle<a class="headerlink" href="#hough-circle" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough_circle">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">hough_circle</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.transform.hough_circle" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a circular Hough transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>img</strong> : (M, N) ndarray</p>
<blockquote>
<div><p>Input image with nonzero values representing edges.</p>
</div></blockquote>
<p><strong>radius</strong> : ndarray</p>
<blockquote>
<div><p>Radii at which to compute the Hough transform.</p>
</div></blockquote>
<p><strong>normalize</strong> : boolean, optional (default True)</p>
<blockquote>
<div><p>Normalize the accumulator with the number
of pixels used to draw the radius.</p>
</div></blockquote>
<p><strong>full_output</strong> : boolean, optional (default False)</p>
<blockquote>
<div><p>Extend the output size by twice the largest
radius in order to detect centers outside the
input picture.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>H</strong> : 3D ndarray (radius index, (M + 2R, N + 2R) ndarray)</p>
<blockquote class="last">
<div><p>Hough transform accumulator for each radius.
R designates the larger radius if full_output is True.
Otherwise, R = 0.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="hough-ellipse">
<h2>hough_ellipse<a class="headerlink" href="#hough-ellipse" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough_ellipse">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">hough_ellipse</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.transform.hough_ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an elliptical Hough transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>img</strong> : (M, N) ndarray</p>
<blockquote>
<div><p>Input image with nonzero values representing edges.</p>
</div></blockquote>
<p><strong>threshold: int, optional (default 4)</strong> :</p>
<blockquote>
<div><p>Accumulator threshold value.</p>
</div></blockquote>
<p><strong>accuracy</strong> : double, optional (default 1)</p>
<blockquote>
<div><p>Bin size on the minor axis used in the accumulator.</p>
</div></blockquote>
<p><strong>min_size</strong> : int, optional (default 4)</p>
<blockquote>
<div><p>Minimal major axis length.</p>
</div></blockquote>
<p><strong>max_size</strong> : int, optional</p>
<blockquote>
<div><p>Maximal minor axis length. (default None)
If None, the value is set to the half of the smaller
image dimension.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>result</strong> : ndarray with fields [(accumulator, y0, x0, a, b, orientation)]</p>
<blockquote class="last">
<div><p>Where <tt class="docutils literal"><span class="pre">(yc,</span> <span class="pre">xc)</span></tt> is the center, <tt class="docutils literal"><span class="pre">(a,</span> <span class="pre">b)</span></tt> the major and minor
axes, respectively. The <cite>orientation</cite> value follows
<cite>skimage.draw.ellipse_perimeter</cite> convention.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The accuracy must be chosen to produce a peak in the accumulator
distribution. In other words, a flat accumulator distribution with low
values may be caused by a too low bin size.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r237" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[R237]</a></td><td>Xie, Yonghong, and Qiang Ji. &#8220;A new efficient ellipse detection
method.&#8221; Pattern Recognition, 2002. Proceedings. 16th International
Conference on. Vol. 2. IEEE, 2002</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">ellipse_perimeter</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">cc</span><span class="p">,</span> <span class="n">rr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">hough_ellipse</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="go">[(10, 10.0, 8.0, 6.0, 0.0, 10.0)]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="hough-line">
<h2>hough_line<a class="headerlink" href="#hough-line" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough_line">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">hough_line</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.transform.hough_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a straight line Hough transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>img</strong> : (M, N) ndarray</p>
<blockquote>
<div><p>Input image with nonzero values representing edges.</p>
</div></blockquote>
<p><strong>theta</strong> : 1D ndarray of double</p>
<blockquote>
<div><p>Angles at which to compute the transform, in radians.
Defaults to -pi/2 .. pi/2</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>H</strong> : 2-D ndarray of uint64</p>
<blockquote>
<div><p>Hough transform accumulator.</p>
</div></blockquote>
<p><strong>theta</strong> : ndarray</p>
<blockquote>
<div><p>Angles at which the transform was computed, in radians.</p>
</div></blockquote>
<p><strong>distances</strong> : ndarray</p>
<blockquote class="last">
<div><p>Distance values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The origin is the top left corner of the original image.
X and Y axis are horizontal and vertical edges respectively.
The distance is the minimal algebraic distance from the origin
to the detected line.</p>
<p class="rubric">Examples</p>
<p>Generate a test image:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[:,</span> <span class="mi">65</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">45</span><span class="p">,</span> <span class="mi">35</span><span class="p">:</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">90</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.95</span>
</pre></div>
</div>
<p>Apply the Hough transform:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">hough_line</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough_line</span>
<span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">line</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">img</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span><span class="p">[:,</span> <span class="mi">65</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">45</span><span class="p">,</span> <span class="mi">35</span><span class="p">:</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">line</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">img</span><span class="p">[</span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.95</span>

<span class="n">out</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">hough_line</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Input image&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">bone</span><span class="p">,</span>
           <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                   <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Hough transform&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Angle (degree)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Distance (pixel)&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../plots/hough_tf.py">Source code</a>, <a class="reference external" href="../plots/hough_tf.png">png</a>, <a class="reference external" href="../plots/hough_tf.pdf">pdf</a>)</p>
<div class="figure">
<img alt="../_images/hough_tf.png" src="../_images/hough_tf.png" />
</div>
</dd></dl>

</div>
<div class="section" id="hough-line-peaks">
<h2>hough_line_peaks<a class="headerlink" href="#hough-line-peaks" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough_line_peaks">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">hough_line_peaks</tt><big>(</big><em>hspace</em>, <em>angles</em>, <em>dists</em>, <em>min_distance=9</em>, <em>min_angle=10</em>, <em>threshold=None</em>, <em>num_peaks=inf</em><big>)</big><a class="headerlink" href="#skimage.transform.hough_line_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return peaks in hough transform.</p>
<p>Identifies most prominent lines separated by a certain angle and distance
in a hough transform. Non-maximum suppression with different sizes is
applied separately in the first (distances) and second (angles) dimension
of the hough space to identify peaks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>hspace</strong> : (N, M) array</p>
<blockquote>
<div><p>Hough space returned by the <cite>hough_line</cite> function.</p>
</div></blockquote>
<p><strong>angles</strong> : (M,) array</p>
<blockquote>
<div><p>Angles returned by the <cite>hough_line</cite> function. Assumed to be continuous.
(<cite>angles[-1] - angles[0] == PI</cite>).</p>
</div></blockquote>
<p><strong>dists</strong> : (N, ) array</p>
<blockquote>
<div><p>Distances returned by the <cite>hough_line</cite> function.</p>
</div></blockquote>
<p><strong>min_distance</strong> : int</p>
<blockquote>
<div><p>Minimum distance separating lines (maximum filter size for first
dimension of hough space).</p>
</div></blockquote>
<p><strong>min_angle</strong> : int</p>
<blockquote>
<div><p>Minimum angle separating lines (maximum filter size for second
dimension of hough space).</p>
</div></blockquote>
<p><strong>threshold</strong> : float</p>
<blockquote>
<div><p>Minimum intensity of peaks. Default is <cite>0.5 * max(hspace)</cite>.</p>
</div></blockquote>
<p><strong>num_peaks</strong> : int</p>
<blockquote>
<div><p>Maximum number of peaks. When the number of peaks exceeds <cite>num_peaks</cite>,
return <cite>num_peaks</cite> coordinates based on peak intensity.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>hspace, angles, dists</strong> : tuple of array</p>
<blockquote class="last">
<div><p>Peak values in hough space, angles and distances.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough_line</span><span class="p">,</span> <span class="n">hough_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">line</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">line</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">line</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">cc</span><span class="p">,</span> <span class="n">rr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hspace</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dists</span> <span class="o">=</span> <span class="n">hough_line</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hspace</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dists</span> <span class="o">=</span> <span class="n">hough_peaks</span><span class="p">(</span><span class="n">hspace</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angles</span>
<span class="go">array([  0.74590887,  -0.79856126])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dists</span>
<span class="go">array([  10.74418605,  0.51162791])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="ifrt2">
<h2>ifrt2<a class="headerlink" href="#ifrt2" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.ifrt2">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">ifrt2</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#skimage.transform.ifrt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 2-dimensional inverse finite radon transform (iFRT) for
an (n+1) x n integer array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>a</strong> : array_like</p>
<blockquote>
<div><p>A 2-D (n+1) row x n column integer array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>iFRT</strong> : 2-D n x n ndarray</p>
<blockquote class="last">
<div><p>Inverse Finite Radon Transform array of n x n integer coefficients.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><tt class="xref py py-obj docutils literal"><span class="pre">frt2</span></tt></a></dt>
<dd>The two-dimensional FRT</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The FRT has a unique inverse iff n is prime.
See <a class="reference internal" href="#r238">[R238]</a> for an overview.
The idea for this algorithm is due to Vlad Negnevitski.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r238" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R238]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> A. Kingston and I. Svalbe, &#8220;Projective transforms on periodic
discrete image arrays,&#8221; in P. Hawkes (Ed), Advances in Imaging
and Electron Physics, 139 (2006)</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SIZE</span> <span class="o">=</span> <span class="mi">59</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Finite Radon Transform:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">frt2</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Inverse Finite Radon Transform to recover the input</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fi</span> <span class="o">=</span> <span class="n">ifrt2</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Check that it&#8217;s identical to the original</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">img</span><span class="o">-</span><span class="n">fi</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="integral-image">
<h2>integral_image<a class="headerlink" href="#integral-image" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.integral_image">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">integral_image</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#skimage.transform.integral_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Integral image / summed area table.</p>
<p>The integral image contains the sum of all elements above and to the
left of it, i.e.:</p>
<div class="math">
<p><img src="../_images/math/60eb18acdabe921f0fcbc69cf1dfc9fe4934bb1d.png" alt="S[m, n] = \sum_{i \leq m} \sum_{j \leq n} X[i, j]"/></p>
</div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>x</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>S</strong> : ndarray</p>
<blockquote class="last">
<div><p>Integral image / summed area table.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r239" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[R239]</a></td><td>F.C. Crow, &#8220;Summed-area tables for texture mapping,&#8221;
ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="integrate">
<h2>integrate<a class="headerlink" href="#integrate" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.integrate">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">integrate</tt><big>(</big><em>ii</em>, <em>r0</em>, <em>c0</em>, <em>r1</em>, <em>c1</em><big>)</big><a class="headerlink" href="#skimage.transform.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Use an integral image to integrate over a given window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>ii</strong> : ndarray</p>
<blockquote>
<div><p>Integral image.</p>
</div></blockquote>
<p><strong>r0, c0</strong> : int or ndarray</p>
<blockquote>
<div><p>Top-left corner(s) of block to be summed.</p>
</div></blockquote>
<p><strong>r1, c1</strong> : int or ndarray</p>
<blockquote>
<div><p>Bottom-right corner(s) of block to be summed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>S</strong> : scalar or ndarray</p>
<blockquote class="last">
<div><p>Integral (sum) over the given window(s).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="iradon">
<h2>iradon<a class="headerlink" href="#iradon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.iradon">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">iradon</tt><big>(</big><em>radon_image</em>, <em>theta=None</em>, <em>output_size=None</em>, <em>filter='ramp'</em>, <em>interpolation='linear'</em>, <em>circle=False</em><big>)</big><a class="headerlink" href="#skimage.transform.iradon" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse radon transform.</p>
<p>Reconstruct an image from the radon transform, using the filtered
back projection algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>radon_image</strong> : array_like, dtype=float</p>
<blockquote>
<div><p>Image containing radon transform (sinogram). Each column of
the image corresponds to a projection along a different angle. The
tomography rotation axis should lie at the pixel index
<tt class="docutils literal"><span class="pre">radon_image.shape[0]</span> <span class="pre">//</span> <span class="pre">2</span></tt> along the 0th dimension of
<tt class="docutils literal"><span class="pre">radon_image</span></tt>.</p>
</div></blockquote>
<p><strong>theta</strong> : array_like, dtype=float, optional</p>
<blockquote>
<div><p>Reconstruction angles (in degrees). Default: m angles evenly spaced
between 0 and 180 (if the shape of <cite>radon_image</cite> is (N, M)).</p>
</div></blockquote>
<p><strong>output_size</strong> : int</p>
<blockquote>
<div><p>Number of rows and columns in the reconstruction.</p>
</div></blockquote>
<p><strong>filter</strong> : str, optional (default ramp)</p>
<blockquote>
<div><p>Filter used in frequency domain filtering. Ramp filter used by default.
Filters available: ramp, shepp-logan, cosine, hamming, hann.
Assign None to use no filter.</p>
</div></blockquote>
<p><strong>interpolation</strong> : str, optional (default &#8216;linear&#8217;)</p>
<blockquote>
<div><p>Interpolation method used in reconstruction. Methods available:
&#8216;linear&#8217;, &#8216;nearest&#8217;, and &#8216;cubic&#8217; (&#8216;cubic&#8217; is slow).</p>
</div></blockquote>
<p><strong>circle</strong> : boolean, optional</p>
<blockquote>
<div><p>Assume the reconstructed image is zero outside the inscribed circle.
Also changes the default output_size to match the behaviour of
<tt class="docutils literal"><span class="pre">radon</span></tt> called with <tt class="docutils literal"><span class="pre">circle=True</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>reconstructed</strong> : ndarray</p>
<blockquote class="last">
<div><p>Reconstructed image. The rotation axis will be located in the pixel
with indices
<tt class="docutils literal"><span class="pre">(reconstructed.shape[0]</span> <span class="pre">//</span> <span class="pre">2,</span> <span class="pre">reconstructed.shape[1]</span> <span class="pre">//</span> <span class="pre">2)</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>It applies the Fourier slice theorem to reconstruct an image by
multiplying the frequency domain of the filter with the FFT of the
projection data. This algorithm is called filtered back projection.</p>
</dd></dl>

</div>
<div class="section" id="iradon-sart">
<h2>iradon_sart<a class="headerlink" href="#iradon-sart" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.iradon_sart">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">iradon_sart</tt><big>(</big><em>radon_image</em>, <em>theta=None</em>, <em>image=None</em>, <em>projection_shifts=None</em>, <em>clip=None</em>, <em>relaxation=0.15</em><big>)</big><a class="headerlink" href="#skimage.transform.iradon_sart" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse radon transform</p>
<p>Reconstruct an image from the radon transform, using a single iteration of
the Simultaneous Algebraic Reconstruction Technique (SART) algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>radon_image</strong> : 2D array, dtype=float</p>
<blockquote>
<div><p>Image containing radon transform (sinogram). Each column of
the image corresponds to a projection along a different angle. The
tomography rotation axis should lie at the pixel index
<tt class="docutils literal"><span class="pre">radon_image.shape[0]</span> <span class="pre">//</span> <span class="pre">2</span></tt> along the 0th dimension of
<tt class="docutils literal"><span class="pre">radon_image</span></tt>.</p>
</div></blockquote>
<p><strong>theta</strong> : 1D array, dtype=float, optional</p>
<blockquote>
<div><p>Reconstruction angles (in degrees). Default: m angles evenly spaced
between 0 and 180 (if the shape of <cite>radon_image</cite> is (N, M)).</p>
</div></blockquote>
<p><strong>image</strong> : 2D array, dtype=float, optional</p>
<blockquote>
<div><p>Image containing an initial reconstruction estimate. Shape of this
array should be <tt class="docutils literal"><span class="pre">(radon_image.shape[0],</span> <span class="pre">radon_image.shape[0])</span></tt>. The
default is an array of zeros.</p>
</div></blockquote>
<p><strong>projection_shifts</strong> : 1D array, dtype=float</p>
<blockquote>
<div><p>Shift the projections contained in <tt class="docutils literal"><span class="pre">radon_image</span></tt> (the sinogram) by
this many pixels before reconstructing the image. The i&#8217;th value
defines the shift of the i&#8217;th column of <tt class="docutils literal"><span class="pre">radon_image</span></tt>.</p>
</div></blockquote>
<p><strong>clip</strong> : length-2 sequence of floats</p>
<blockquote>
<div><p>Force all values in the reconstructed tomogram to lie in the range
<tt class="docutils literal"><span class="pre">[clip[0],</span> <span class="pre">clip[1]]</span></tt></p>
</div></blockquote>
<p><strong>relaxation</strong> : float</p>
<blockquote>
<div><p>Relaxation parameter for the update step. A higher value can
improve the convergence rate, but one runs the risk of instabilities.
Values close to or higher than 1 are not recommended.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>reconstructed</strong> : ndarray</p>
<blockquote class="last">
<div><p>Reconstructed image. The rotation axis will be located in the pixel
with indices
<tt class="docutils literal"><span class="pre">(reconstructed.shape[0]</span> <span class="pre">//</span> <span class="pre">2,</span> <span class="pre">reconstructed.shape[1]</span> <span class="pre">//</span> <span class="pre">2)</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Algebraic Reconstruction Techniques are based on formulating the tomography
reconstruction problem as a set of linear equations. Along each ray,
the projected value is the sum of all the values of the cross section along
the ray. A typical feature of SART (and a few other variants of algebraic
techniques) is that it samples the cross section at equidistant points
along the ray, using linear interpolation between the pixel values of the
cross section. The resulting set of linear equations are then solved using
a slightly modified Kaczmarz method.</p>
<p>When using SART, a single iteration is usually sufficient to obtain a good
reconstruction. Further iterations will tend to enhance high-frequency
information, but will also often increase the noise.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r240" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[R240]</a></td><td>AC Kak, M Slaney, &#8220;Principles of Computerized Tomographic
Imaging&#8221;, IEEE Press 1988.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r241" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[R241]</a></td><td>AH Andersen, AC Kak, &#8220;Simultaneous algebraic reconstruction
technique (SART): a superior implementation of the ART algorithm&#8221;,
Ultrasonic Imaging 6 pp 81&#8211;94 (1984)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r242" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[R242]</a></td><td>S Kaczmarz, &#8220;Angenäherte auflösung von systemen linearer
gleichungen&#8221;, Bulletin International de l’Academie Polonaise des
Sciences et des Lettres 35 pp 355&#8211;357 (1937)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r243" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[R243]</a></td><td>Kohler, T. &#8220;A projection access scheme for iterative
reconstruction based on the golden section.&#8221; Nuclear Science
Symposium Conference Record, 2004 IEEE. Vol. 6. IEEE, 2004.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r244" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[R244]</a></td><td>Kaczmarz&#8217; method, Wikipedia,
<a class="reference external" href="http://en.wikipedia.org/wiki/Kaczmarz_method">http://en.wikipedia.org/wiki/Kaczmarz_method</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="probabilistic-hough-line">
<h2>probabilistic_hough_line<a class="headerlink" href="#probabilistic-hough-line" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.probabilistic_hough_line">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">probabilistic_hough_line</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.transform.probabilistic_hough_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Return lines from a progressive probabilistic line Hough transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>img</strong> : (M, N) ndarray</p>
<blockquote>
<div><p>Input image with nonzero values representing edges.</p>
</div></blockquote>
<p><strong>threshold</strong> : int, optional (default 10)</p>
<blockquote>
<div><p>Threshold</p>
</div></blockquote>
<p><strong>line_length</strong> : int, optional (default 50)</p>
<blockquote>
<div><p>Minimum accepted length of detected lines.
Increase the parameter to extract longer lines.</p>
</div></blockquote>
<p><strong>line_gap</strong> : int, optional, (default 10)</p>
<blockquote>
<div><p>Maximum gap between pixels to still form a line.
Increase the parameter to merge broken lines more aggresively.</p>
</div></blockquote>
<p><strong>theta</strong> : 1D ndarray, dtype=double, optional, default (-pi/2 .. pi/2)</p>
<blockquote>
<div><p>Angles at which to compute the transform, in radians.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>lines</strong> : list</p>
<blockquote class="last">
<div><p>List of lines identified, lines in format ((x0, y0), (x1, y0)),
indicating line start and end.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r245" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[R245]</a></td><td>C. Galamhos, J. Matas and J. Kittler, &#8220;Progressive probabilistic
Hough transform for line detection&#8221;, in IEEE Computer Society
Conference on Computer Vision and Pattern Recognition, 1999.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="pyramid-expand">
<h2>pyramid_expand<a class="headerlink" href="#pyramid-expand" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_expand">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">pyramid_expand</tt><big>(</big><em>image</em>, <em>upscale=2</em>, <em>sigma=None</em>, <em>order=1</em>, <em>mode='reflect'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.transform.pyramid_expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Upsample and then smooth image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>upscale</strong> : float, optional</p>
<blockquote>
<div><p>Upscale factor.</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote>
<div><p>Sigma for Gaussian filter. Default is <cite>2 * upscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</div></blockquote>
<p><strong>order</strong> : int, optional</p>
<blockquote>
<div><p>Order of splines used in interpolation of upsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;reflect&#8217;, &#8216;constant&#8217;, &#8216;nearest&#8217;, &#8216;mirror&#8217;, &#8216;wrap&#8217;}, optional</p>
<blockquote>
<div><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &#8216;constant&#8217;.</p>
</div></blockquote>
<p><strong>cval</strong> : float, optional</p>
<blockquote>
<div><p>Value to fill past edges of input if mode is &#8216;constant&#8217;.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>out</strong> : array</p>
<blockquote class="last">
<div><p>Upsampled and smoothed float image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r246" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[R246]</a></td><td><a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="pyramid-gaussian">
<h2>pyramid_gaussian<a class="headerlink" href="#pyramid-gaussian" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_gaussian">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">pyramid_gaussian</tt><big>(</big><em>image</em>, <em>max_layer=-1</em>, <em>downscale=2</em>, <em>sigma=None</em>, <em>order=1</em>, <em>mode='reflect'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.transform.pyramid_gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield images of the Gaussian pyramid formed by the input image.</p>
<p>Recursively applies the <cite>pyramid_reduce</cite> function to the image, and yields
the downscaled images.</p>
<p>Note that the first image of the pyramid will be the original, unscaled
image. The total number of images is <cite>max_layer + 1</cite>. In case all layers
are computed, the last image is either a one-pixel image or the image where
the reduction does not change its shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>max_layer</strong> : int</p>
<blockquote>
<div><p>Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</div></blockquote>
<p><strong>downscale</strong> : float, optional</p>
<blockquote>
<div><p>Downscale factor.</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote>
<div><p>Sigma for Gaussian filter. Default is <cite>2 * downscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</div></blockquote>
<p><strong>order</strong> : int, optional</p>
<blockquote>
<div><p>Order of splines used in interpolation of downsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;reflect&#8217;, &#8216;constant&#8217;, &#8216;nearest&#8217;, &#8216;mirror&#8217;, &#8216;wrap&#8217;}, optional</p>
<blockquote>
<div><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &#8216;constant&#8217;.</p>
</div></blockquote>
<p><strong>cval</strong> : float, optional</p>
<blockquote>
<div><p>Value to fill past edges of input if mode is &#8216;constant&#8217;.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>pyramid</strong> : generator</p>
<blockquote class="last">
<div><p>Generator yielding pyramid layers as float images.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r247" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[R247]</a></td><td><a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="pyramid-laplacian">
<h2>pyramid_laplacian<a class="headerlink" href="#pyramid-laplacian" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_laplacian">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">pyramid_laplacian</tt><big>(</big><em>image</em>, <em>max_layer=-1</em>, <em>downscale=2</em>, <em>sigma=None</em>, <em>order=1</em>, <em>mode='reflect'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.transform.pyramid_laplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield images of the laplacian pyramid formed by the input image.</p>
<p>Each layer contains the difference between the downsampled and the
downsampled, smoothed image:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">layer</span> <span class="o">=</span> <span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">)</span> <span class="o">-</span> <span class="n">smooth</span><span class="p">(</span><span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that the first image of the pyramid will be the difference between the
original, unscaled image and its smoothed version. The total number of
images is <cite>max_layer + 1</cite>. In case all layers are computed, the last image
is either a one-pixel image or the image where the reduction does not
change its shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>max_layer</strong> : int</p>
<blockquote>
<div><p>Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</div></blockquote>
<p><strong>downscale</strong> : float, optional</p>
<blockquote>
<div><p>Downscale factor.</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote>
<div><p>Sigma for Gaussian filter. Default is <cite>2 * downscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</div></blockquote>
<p><strong>order</strong> : int, optional</p>
<blockquote>
<div><p>Order of splines used in interpolation of downsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;reflect&#8217;, &#8216;constant&#8217;, &#8216;nearest&#8217;, &#8216;mirror&#8217;, &#8216;wrap&#8217;}, optional</p>
<blockquote>
<div><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &#8216;constant&#8217;.</p>
</div></blockquote>
<p><strong>cval</strong> : float, optional</p>
<blockquote>
<div><p>Value to fill past edges of input if mode is &#8216;constant&#8217;.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>pyramid</strong> : generator</p>
<blockquote class="last">
<div><p>Generator yielding pyramid layers as float images.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r248" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[R248]</a></td><td><a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r249" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[R249]</a></td><td><a class="reference external" href="http://sepwww.stanford.edu/~morgan/texturematch/paper_html/node3.html">http://sepwww.stanford.edu/~morgan/texturematch/paper_html/node3.html</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="pyramid-reduce">
<h2>pyramid_reduce<a class="headerlink" href="#pyramid-reduce" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_reduce">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">pyramid_reduce</tt><big>(</big><em>image</em>, <em>downscale=2</em>, <em>sigma=None</em>, <em>order=1</em>, <em>mode='reflect'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.transform.pyramid_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth and then downsample image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>downscale</strong> : float, optional</p>
<blockquote>
<div><p>Downscale factor.</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote>
<div><p>Sigma for Gaussian filter. Default is <cite>2 * downscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</div></blockquote>
<p><strong>order</strong> : int, optional</p>
<blockquote>
<div><p>Order of splines used in interpolation of downsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;reflect&#8217;, &#8216;constant&#8217;, &#8216;nearest&#8217;, &#8216;mirror&#8217;, &#8216;wrap&#8217;}, optional</p>
<blockquote>
<div><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &#8216;constant&#8217;.</p>
</div></blockquote>
<p><strong>cval</strong> : float, optional</p>
<blockquote>
<div><p>Value to fill past edges of input if mode is &#8216;constant&#8217;.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>out</strong> : array</p>
<blockquote class="last">
<div><p>Smoothed and downsampled float image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r250" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[R250]</a></td><td><a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="radon">
<h2>radon<a class="headerlink" href="#radon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.radon">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">radon</tt><big>(</big><em>image</em>, <em>theta=None</em>, <em>circle=False</em><big>)</big><a class="headerlink" href="#skimage.transform.radon" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the radon transform of an image given specified
projection angles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : array_like, dtype=float</p>
<blockquote>
<div><p>Input image. The rotation axis will be located in the pixel with
indices <tt class="docutils literal"><span class="pre">(image.shape[0]</span> <span class="pre">//</span> <span class="pre">2,</span> <span class="pre">image.shape[1]</span> <span class="pre">//</span> <span class="pre">2)</span></tt>.</p>
</div></blockquote>
<p><strong>theta</strong> : array_like, dtype=float, optional (default np.arange(180))</p>
<blockquote>
<div><p>Projection angles (in degrees).</p>
</div></blockquote>
<p><strong>circle</strong> : boolean, optional</p>
<blockquote>
<div><p>Assume image is zero outside the inscribed circle, making the
width of each projection (the first dimension of the sinogram)
equal to <tt class="docutils literal"><span class="pre">min(image.shape)</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>radon_image</strong> : ndarray</p>
<blockquote>
<div><p>Radon transform (sinogram).  The tomography rotation axis will lie
at the pixel index <tt class="docutils literal"><span class="pre">radon_image.shape[0]</span> <span class="pre">//</span> <span class="pre">2</span></tt> along the 0th
dimension of <tt class="docutils literal"><span class="pre">radon_image</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first"><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>If called with <tt class="docutils literal"><span class="pre">circle=True</span></tt> and <tt class="docutils literal"><span class="pre">image</span> <span class="pre">!=</span> <span class="pre">0</span></tt> outside the inscribed
circle</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="rescale">
<h2>rescale<a class="headerlink" href="#rescale" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.rescale">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">rescale</tt><big>(</big><em>image</em>, <em>scale</em>, <em>order=1</em>, <em>mode='constant'</em>, <em>cval=0.0</em><big>)</big><a class="headerlink" href="#skimage.transform.rescale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale image by a certain factor.</p>
<p>Performs interpolation to upscale or down-scale images. For down-sampling
N-dimensional images with integer factors by applying the arithmetic sum or
mean, see <cite>skimage.measure.local_sum</cite> and
<cite>skimage.transform.downscale_local_mean</cite>, respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>scale</strong> : {float, tuple of floats}</p>
<blockquote>
<div><p>Scale factors. Separate scale factors can be defined as
<cite>(row_scale, col_scale)</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>scaled</strong> : ndarray</p>
<blockquote class="last">
<div><p>Scaled version of the input.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">rescale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(51, 51)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(256, 256)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="resize">
<h2>resize<a class="headerlink" href="#resize" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.resize">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">resize</tt><big>(</big><em>image</em>, <em>output_shape</em>, <em>order=1</em>, <em>mode='constant'</em>, <em>cval=0.0</em><big>)</big><a class="headerlink" href="#skimage.transform.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize image to match a certain size.</p>
<p>Performs interpolation to up-size or down-size images. For down-sampling
N-dimensional images by applying the arithmetic sum or mean, see
<cite>skimage.measure.local_sum</cite> and <cite>skimage.transform.downscale_local_mean</cite>,
respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>output_shape</strong> : tuple or ndarray</p>
<blockquote>
<div><p>Size of the generated output image <cite>(rows, cols[, dim])</cite>. If <cite>dim</cite> is
not provided, the number of channels is preserved. In case the number
of input channels does not equal the number of output channels a
3-dimensional interpolation is applied.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>resized</strong> : ndarray</p>
<blockquote class="last">
<div><p>Resized version of the input.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">resize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="rotate">
<h2>rotate<a class="headerlink" href="#rotate" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.rotate">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">rotate</tt><big>(</big><em>image</em>, <em>angle</em>, <em>resize=False</em>, <em>order=1</em>, <em>mode='constant'</em>, <em>cval=0.0</em><big>)</big><a class="headerlink" href="#skimage.transform.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate image by a certain angle around its center.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>angle</strong> : float</p>
<blockquote>
<div><p>Rotation angle in degrees in counter-clockwise direction.</p>
</div></blockquote>
<p><strong>resize</strong> : bool, optional</p>
<blockquote>
<div><p>Determine whether the shape of the output image will be automatically
calculated, so the complete rotated image exactly fits. Default is
False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>rotated</strong> : ndarray</p>
<blockquote class="last">
<div><p>Rotated version of the input.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">rotate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(512, 512)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(530, 530)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(512, 512)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="swirl">
<h2>swirl<a class="headerlink" href="#swirl" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.swirl">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">swirl</tt><big>(</big><em>image</em>, <em>center=None</em>, <em>strength=1</em>, <em>radius=100</em>, <em>rotation=0</em>, <em>output_shape=None</em>, <em>order=1</em>, <em>mode='constant'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.transform.swirl" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a swirl transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>center</strong> : (x,y) tuple or (2,) ndarray, optional</p>
<blockquote>
<div><p>Center coordinate of transformation.</p>
</div></blockquote>
<p><strong>strength</strong> : float, optional</p>
<blockquote>
<div><p>The amount of swirling applied.</p>
</div></blockquote>
<p><strong>radius</strong> : float, optional</p>
<blockquote>
<div><p>The extent of the swirl in pixels.  The effect dies out
rapidly beyond <cite>radius</cite>.</p>
</div></blockquote>
<p><strong>rotation</strong> : float, optional</p>
<blockquote>
<div><p>Additional rotation applied to the image.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>swirled</strong> : ndarray</p>
<blockquote class="last">
<div><p>Swirled version of the input.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="warp">
<h2>warp<a class="headerlink" href="#warp" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.warp">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">warp</tt><big>(</big><em>image</em>, <em>inverse_map=None</em>, <em>map_args={}</em>, <em>output_shape=None</em>, <em>order=1</em>, <em>mode='constant'</em>, <em>cval=0.0</em>, <em>reverse_map=None</em><big>)</big><a class="headerlink" href="#skimage.transform.warp" title="Permalink to this definition">¶</a></dt>
<dd><p>Warp an image according to a given coordinate transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D or 3-D array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>inverse_map</strong> : transformation object, callable <tt class="docutils literal"><span class="pre">xy</span> <span class="pre">=</span> <span class="pre">f(xy,</span> <span class="pre">**kwargs)</span></tt>, (3, 3) array</p>
<blockquote>
<div><p>Inverse coordinate map. A function that transforms a (N, 2) array of
<tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></tt> coordinates in the <em>output image</em> into their corresponding
coordinates in the <em>source image</em> (e.g. a transformation object or its
inverse). See example section for usage.</p>
</div></blockquote>
<p><strong>map_args</strong> : dict, optional</p>
<blockquote>
<div><p>Keyword arguments passed to <cite>inverse_map</cite>.</p>
</div></blockquote>
<p><strong>output_shape</strong> : tuple (rows, cols), optional</p>
<blockquote>
<div><p>Shape of the output image generated. By default the shape of the input
image is preserved.</p>
</div></blockquote>
<p><strong>order</strong> : int, optional</p>
<blockquote>
<div><p>The order of interpolation. The order has to be in the range 0-5:
* 0: Nearest-neighbor
* 1: Bi-linear (default)
* 2: Bi-quadratic
* 3: Bi-cubic
* 4: Bi-quartic
* 5: Bi-quintic</p>
</div></blockquote>
<p><strong>mode</strong> : string, optional</p>
<blockquote>
<div><p>Points outside the boundaries of the input are filled according
to the given mode (&#8216;constant&#8217;, &#8216;nearest&#8217;, &#8216;reflect&#8217; or &#8216;wrap&#8217;).</p>
</div></blockquote>
<p><strong>cval</strong> : float, optional</p>
<blockquote class="last">
<div><p>Used in conjunction with mode &#8216;constant&#8217;, the value outside
the image boundaries.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In case of a <cite>SimilarityTransform</cite>, <cite>AffineTransform</cite> and
<cite>ProjectiveTransform</cite> and <cite>order</cite> in [0, 3] this function uses the
underlying transformation matrix to warp the image with a much faster
routine.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">warp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
</pre></div>
</div>
<p>The following image warps are all equal but differ substantially in
execution time.</p>
<p>Use a geometric transform to warp an image (fast):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">SimilarityTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">tform</span><span class="p">)</span>
</pre></div>
</div>
<p>Shift an image to the right with a callable (slow):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">shift_right</span><span class="p">)</span>
</pre></div>
</div>
<p>Use a transformation matrix to warp an image (fast):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">ProjectiveTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ProjectiveTransform</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="p">))</span>
</pre></div>
</div>
<p>You can also use the inverse of a geometric transformation (fast):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="warp-coords">
<h2>warp_coords<a class="headerlink" href="#warp-coords" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.warp_coords">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">warp_coords</tt><big>(</big><em>coord_map</em>, <em>shape</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em><big>)</big><a class="headerlink" href="#skimage.transform.warp_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the source coordinates for the output pixels of an image warp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>coord_map</strong> : callable like GeometricTransform.inverse</p>
<blockquote>
<div><p>Return input coordinates for given output coordinates.
Coordinates are in the shape (P, 2), where P is the number
of coordinates and each element is a <tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></tt> pair.</p>
</div></blockquote>
<p><strong>shape</strong> : tuple</p>
<blockquote>
<div><p>Shape of output image <tt class="docutils literal"><span class="pre">(rows,</span> <span class="pre">cols[,</span> <span class="pre">bands])</span></tt>.</p>
</div></blockquote>
<p><strong>dtype</strong> : np.dtype or string</p>
<blockquote>
<div><p>dtype for return value (sane choices: float32 or float64).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>coords</strong> : (ndim, rows, cols[, bands]) array of dtype <cite>dtype</cite></p>
<blockquote class="last">
<div><p>Coordinates for <cite>scipy.ndimage.map_coordinates</cite>, that will yield
an image of shape (orows, ocols, bands) by drawing from source
points according to the <cite>coord_transform_fn</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This is a lower-level routine that produces the source coordinates used by
<cite>warp()</cite>.</p>
<p>It is provided separately from <cite>warp</cite> to give additional flexibility to
users who would like, for example, to re-use a particular coordinate
mapping, to use specific dtypes at various points along the the
image-warping process, or to implement different post-processing logic
than <cite>warp</cite> performs after the call to <cite>ndimage.map_coordinates</cite>.</p>
<p class="rubric">Examples</p>
<p>Produce a coordinate map that Shifts an image up and to the right:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">map_coordinates</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_up10_left20</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">])[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">lena</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">warp_coords</span><span class="p">(</span><span class="n">shift_up10_left20</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped_image</span> <span class="o">=</span> <span class="n">map_coordinates</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


        </div>
        <div class="span3"><h4 class="sidebar-box-heading">Navigation</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <li><a href="../index.html">Documentation Home</a></li>
    </ul>
</div>
        <h4 class="sidebar-box-heading">Contents</h4>
        <div class="well sidebar-box toc">
            <ul class="nav nav-list">
<li><a class="reference internal" href="#">Module: <tt class="docutils literal"><span class="pre">transform</span></tt></a><ul class="nav nav-list">
<li><a class="reference internal" href="#affinetransform"><tt class="docutils literal"><span class="pre">AffineTransform</span></tt></a></li>
<li><a class="reference internal" href="#piecewiseaffinetransform"><tt class="docutils literal"><span class="pre">PiecewiseAffineTransform</span></tt></a></li>
<li><a class="reference internal" href="#polynomialtransform"><tt class="docutils literal"><span class="pre">PolynomialTransform</span></tt></a></li>
<li><a class="reference internal" href="#projectivetransform"><tt class="docutils literal"><span class="pre">ProjectiveTransform</span></tt></a></li>
<li><a class="reference internal" href="#similaritytransform"><tt class="docutils literal"><span class="pre">SimilarityTransform</span></tt></a></li>
<li><a class="reference internal" href="#downscale-local-mean">downscale_local_mean</a></li>
<li><a class="reference internal" href="#estimate-transform">estimate_transform</a></li>
<li><a class="reference internal" href="#frt2">frt2</a></li>
<li><a class="reference internal" href="#hough-circle">hough_circle</a></li>
<li><a class="reference internal" href="#hough-ellipse">hough_ellipse</a></li>
<li><a class="reference internal" href="#hough-line">hough_line</a></li>
<li><a class="reference internal" href="#hough-line-peaks">hough_line_peaks</a></li>
<li><a class="reference internal" href="#ifrt2">ifrt2</a></li>
<li><a class="reference internal" href="#integral-image">integral_image</a></li>
<li><a class="reference internal" href="#integrate">integrate</a></li>
<li><a class="reference internal" href="#iradon">iradon</a></li>
<li><a class="reference internal" href="#iradon-sart">iradon_sart</a></li>
<li><a class="reference internal" href="#probabilistic-hough-line">probabilistic_hough_line</a></li>
<li><a class="reference internal" href="#pyramid-expand">pyramid_expand</a></li>
<li><a class="reference internal" href="#pyramid-gaussian">pyramid_gaussian</a></li>
<li><a class="reference internal" href="#pyramid-laplacian">pyramid_laplacian</a></li>
<li><a class="reference internal" href="#pyramid-reduce">pyramid_reduce</a></li>
<li><a class="reference internal" href="#radon">radon</a></li>
<li><a class="reference internal" href="#rescale">rescale</a></li>
<li><a class="reference internal" href="#resize">resize</a></li>
<li><a class="reference internal" href="#rotate">rotate</a></li>
<li><a class="reference internal" href="#swirl">swirl</a></li>
<li><a class="reference internal" href="#warp">warp</a></li>
<li><a class="reference internal" href="#warp-coords">warp_coords</a></li>
</ul>
</li>
</ul>

        </div>

<h4 class="sidebar-box-heading">Versions</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <script src="../_static/docversions.js"></script>
        <script type="text/javascript">
            insert_version_links();
        </script>
    </ul>
</div>
        </div>
    </div>
    <div class="well footer">
        <small>
            &copy; Copyright the scikit-image development team.
            Created using <a href="http://twitter.github.com/bootstrap/">Bootstrap</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.
        </small>
    </div>
</body>
</html>