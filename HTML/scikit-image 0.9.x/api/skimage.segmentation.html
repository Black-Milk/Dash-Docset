



<!DOCTYPE html>
<html lang="en">
<head>
        <title>Module: segmentation &mdash; skimage v0.9.0 docs</title>
    
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../_static/css/custom.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
    
    <script src="http://code.jquery.com/jquery-latest.js"></script>
    <script src="../_static/js/bootstrap.min.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <link rel="top" title="skimage v0.9.0 docs" href="../index.html" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="shortcut icon" href="../_static/favicon.ico">
</head>
<body class="container">
    <a href="http://scikit-image.org" class="logo"><img src="../_static/img/logo.png" alt=""></a>
    <div class="clearfix"></div>
    <div class="navbar">
        <div class="navbar-inner">
            <ul class="nav">
                <li><a href="/">Home</a></li>
<li><a href="/download.html">Download</a></li>
<li><a href="/docs/dev/auto_examples">Gallery</a></li>
<li><a href="/docs/dev">Documentation</a></li>
<li><a href="https://github.com/scikit-image/scikit-image">Source</a></li>
            </ul>
            <form class="navbar-form pull-right" action="../search.html" method="get">
                <input type="text" class="search span3" name="q" placeholder="Search documentation ...">
                <input type="hidden" name="check_keywords" value="yes" >
                <input type="hidden" name="area" value="default" >
            </form>
        </div>
    </div>
    <div class="row">
        <div class="span9">
            
  <div class="section" id="module-skimage.segmentation">
<span id="module-segmentation"></span><h1>Module: <tt class="xref py py-mod docutils literal"><span class="pre">segmentation</span></tt><a class="headerlink" href="#module-skimage.segmentation" title="Permalink to this headline">¶</a></h1>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#skimage.segmentation.clear_border" title="skimage.segmentation.clear_border"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.clear_border</span></tt></a>(image[,&nbsp;...])</td>
<td>Clear objects connected to image border.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.segmentation.felzenszwalb" title="skimage.segmentation.felzenszwalb"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.felzenszwalb</span></tt></a>(image[,&nbsp;...])</td>
<td>Computes Felsenszwalb&#8217;s efficient graph based image segmentation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.segmentation.find_boundaries" title="skimage.segmentation.find_boundaries"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.find_boundaries</span></tt></a>(label_img)</td>
<td>Return bool array where boundaries between labeled regions are True.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.segmentation.join_segmentations" title="skimage.segmentation.join_segmentations"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.join_segmentations</span></tt></a>(s1,&nbsp;s2)</td>
<td>Return the join of the two input segmentations.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.segmentation.mark_boundaries" title="skimage.segmentation.mark_boundaries"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.mark_boundaries</span></tt></a>(image,&nbsp;...)</td>
<td>Return image with boundaries between labeled regions highlighted.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.segmentation.quickshift" title="skimage.segmentation.quickshift"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.quickshift</span></tt></a></td>
<td>Segments image using quickshift clustering in Color-(x,y) space.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.segmentation.random_walker" title="skimage.segmentation.random_walker"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.random_walker</span></tt></a>(data,&nbsp;labels)</td>
<td>Random walker algorithm for segmentation from markers.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.segmentation.relabel_from_one" title="skimage.segmentation.relabel_from_one"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.relabel_from_one</span></tt></a>(*args,&nbsp;...)</td>
<td><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">relabel_sequential</span></tt> instead.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.segmentation.relabel_sequential" title="skimage.segmentation.relabel_sequential"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.relabel_sequential</span></tt></a>(...)</td>
<td>Relabel arbitrary labels to {<cite>offset</cite>, ...</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.segmentation.slic" title="skimage.segmentation.slic"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.slic</span></tt></a>(image[,&nbsp;...])</td>
<td>Segments image using k-means clustering in Color-(x,y,z) space.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.segmentation.visualize_boundaries" title="skimage.segmentation.visualize_boundaries"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.visualize_boundaries</span></tt></a>(...)</td>
<td><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">mark_boundaries</span></tt> instead.</td>
</tr>
</tbody>
</table>
<div class="section" id="clear-border">
<h2>clear_border<a class="headerlink" href="#clear-border" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.clear_border">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">clear_border</tt><big>(</big><em>image</em>, <em>buffer_size=0</em>, <em>bgval=0</em><big>)</big><a class="headerlink" href="#skimage.segmentation.clear_border" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear objects connected to image border.</p>
<p>The changes will be applied to the input image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : (N, M) array</p>
<blockquote>
<div><p>Binary image.</p>
</div></blockquote>
<p><strong>buffer_size</strong> : int, optional</p>
<blockquote>
<div><p>Define additional buffer around image border.</p>
</div></blockquote>
<p><strong>bgval</strong> : float or int, optional</p>
<blockquote>
<div><p>Value for cleared objects.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>image</strong> : (N, M) array</p>
<blockquote class="last">
<div><p>Cleared binary image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.segmentation</span> <span class="kn">import</span> <span class="n">clear_border</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clear_border</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 1, 1, 1, 1, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="felzenszwalb">
<h2>felzenszwalb<a class="headerlink" href="#felzenszwalb" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.felzenszwalb">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">felzenszwalb</tt><big>(</big><em>image</em>, <em>scale=1</em>, <em>sigma=0.8</em>, <em>min_size=20</em><big>)</big><a class="headerlink" href="#skimage.segmentation.felzenszwalb" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes Felsenszwalb&#8217;s efficient graph based image segmentation.</p>
<p>Produces an oversegmentation of a multichannel (i.e. RGB) image
using a fast, minimum spanning tree based clustering on the image grid.
The parameter <tt class="docutils literal"><span class="pre">scale</span></tt> sets an observation level. Higher scale means
less and larger segments. <tt class="docutils literal"><span class="pre">sigma</span></tt> is the diameter of a Gaussian kernel,
used for smoothing the image prior to segmentation.</p>
<p>The number of produced segments as well as their size can only be
controlled indirectly through <tt class="docutils literal"><span class="pre">scale</span></tt>. Segment size within an image can
vary greatly depending on local contrast.</p>
<p>For RGB images, the algorithm computes a separate segmentation for each
channel and then combines these. The combined segmentation is the
intersection of the separate segmentations on the color channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : (width, height, 3) or (width, height) ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>scale</strong> : float</p>
<blockquote>
<div><p>Free parameter. Higher means larger clusters.</p>
</div></blockquote>
<p><strong>sigma</strong> : float</p>
<blockquote>
<div><p>Width of Gaussian kernel used in preprocessing.</p>
</div></blockquote>
<p><strong>min_size</strong> : int</p>
<blockquote>
<div><p>Minimum component size. Enforced using postprocessing.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>segment_mask</strong> : (width, height) ndarray</p>
<blockquote class="last">
<div><p>Integer mask indicating segment labels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r220" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[R220]</a></td><td>Efficient graph-based image segmentation, Felzenszwalb, P.F. and
Huttenlocher, D.P.  International Journal of Computer Vision, 2004</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="find-boundaries">
<h2>find_boundaries<a class="headerlink" href="#find-boundaries" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.find_boundaries">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">find_boundaries</tt><big>(</big><em>label_img</em><big>)</big><a class="headerlink" href="#skimage.segmentation.find_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Return bool array where boundaries between labeled regions are True.</p>
</dd></dl>

</div>
<div class="section" id="join-segmentations">
<h2>join_segmentations<a class="headerlink" href="#join-segmentations" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.join_segmentations">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">join_segmentations</tt><big>(</big><em>s1</em>, <em>s2</em><big>)</big><a class="headerlink" href="#skimage.segmentation.join_segmentations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the join of the two input segmentations.</p>
<p>The join J of S1 and S2 is defined as the segmentation in which two
voxels are in the same segment if and only if they are in the same
segment in <em>both</em> S1 and S2.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>s1, s2</strong> : numpy arrays</p>
<blockquote>
<div><p>s1 and s2 are label fields of the same shape.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>j</strong> : numpy array</p>
<blockquote class="last">
<div><p>The join segmentation of s1 and s2.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.segmentation</span> <span class="kn">import</span> <span class="n">join_segmentations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">join_segmentations</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
<span class="go">array([[0, 1, 3, 2],</span>
<span class="go">       [0, 5, 3, 2],</span>
<span class="go">       [4, 5, 5, 3]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="mark-boundaries">
<h2>mark_boundaries<a class="headerlink" href="#mark-boundaries" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.mark_boundaries">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">mark_boundaries</tt><big>(</big><em>image</em>, <em>label_img</em>, <em>color=(1</em>, <em>1</em>, <em>0)</em>, <em>outline_color=(0</em>, <em>0</em>, <em>0)</em><big>)</big><a class="headerlink" href="#skimage.segmentation.mark_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Return image with boundaries between labeled regions highlighted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : (M, N[, 3]) array</p>
<blockquote>
<div><p>Grayscale or RGB image.</p>
</div></blockquote>
<p><strong>label_img</strong> : (M, N) array</p>
<blockquote>
<div><p>Label array where regions are marked by different integer values.</p>
</div></blockquote>
<p><strong>color</strong> : length-3 sequence</p>
<blockquote>
<div><p>RGB color of boundaries in the output image.</p>
</div></blockquote>
<p><strong>outline_color</strong> : length-3 sequence</p>
<blockquote class="last">
<div><p>RGB color surrounding boundaries in the output image. If None, no
outline is drawn.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="quickshift">
<h2>quickshift<a class="headerlink" href="#quickshift" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.quickshift">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">quickshift</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.segmentation.quickshift" title="Permalink to this definition">¶</a></dt>
<dd><p>Segments image using quickshift clustering in Color-(x,y) space.</p>
<p>Produces an oversegmentation of the image using the quickshift mode-seeking
algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : (width, height, channels) ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>ratio</strong> : float, optional, between 0 and 1 (default 1).</p>
<blockquote>
<div><p>Balances color-space proximity and image-space proximity.
Higher values give more weight to color-space.</p>
</div></blockquote>
<p><strong>kernel_size</strong> : float, optional (default 5)</p>
<blockquote>
<div><p>Width of Gaussian kernel used in smoothing the
sample density. Higher means fewer clusters.</p>
</div></blockquote>
<p><strong>max_dist</strong> : float, optional (default 10)</p>
<blockquote>
<div><p>Cut-off point for data distances.
Higher means fewer clusters.</p>
</div></blockquote>
<p><strong>return_tree</strong> : bool, optional (default False)</p>
<blockquote>
<div><p>Whether to return the full segmentation hierarchy tree and distances.</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional (default 0)</p>
<blockquote>
<div><p>Width for Gaussian smoothing as preprocessing. Zero means no smoothing.</p>
</div></blockquote>
<p><strong>convert2lab</strong> : bool, optional (default True)</p>
<blockquote>
<div><p>Whether the input should be converted to Lab colorspace prior to
segmentation. For this purpose, the input is assumed to be RGB.</p>
</div></blockquote>
<p><strong>random_seed</strong> : None (default) or int, optional</p>
<blockquote>
<div><p>Random seed used for breaking ties.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>segment_mask</strong> : (width, height) ndarray</p>
<blockquote class="last">
<div><p>Integer mask indicating segment labels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The authors advocate to convert the image to Lab color space prior to
segmentation, though this is not strictly necessary. For this to work, the
image must be given in RGB format.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r221" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[R221]</a></td><td>Quick shift and kernel methods for mode seeking,
Vedaldi, A. and Soatto, S.
European Conference on Computer Vision, 2008</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="random-walker">
<h2>random_walker<a class="headerlink" href="#random-walker" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.random_walker">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">random_walker</tt><big>(</big><em>data</em>, <em>labels</em>, <em>beta=130</em>, <em>mode='bf'</em>, <em>tol=0.001</em>, <em>copy=True</em>, <em>multichannel=False</em>, <em>return_full_prob=False</em>, <em>depth=1.0</em>, <em>spacing=None</em><big>)</big><a class="headerlink" href="#skimage.segmentation.random_walker" title="Permalink to this definition">¶</a></dt>
<dd><p>Random walker algorithm for segmentation from markers.</p>
<p>Random walker algorithm is implemented for gray-level or multichannel
images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>data</strong> : array_like</p>
<blockquote>
<div><p>Image to be segmented in phases. Gray-level <cite>data</cite> can be two- or
three-dimensional; multichannel data can be three- or four-
dimensional (multichannel=True) with the highest dimension denoting
channels. Data spacing is assumed isotropic unless depth keyword
argument is used.</p>
</div></blockquote>
<p><strong>labels</strong> : array of ints, of same shape as <cite>data</cite> without channels dimension</p>
<blockquote>
<div><p>Array of seed markers labeled with different positive integers
for different phases. Zero-labeled pixels are unlabeled pixels.
Negative labels correspond to inactive pixels that are not taken
into account (they are removed from the graph). If labels are not
consecutive integers, the labels array will be transformed so that
labels are consecutive. In the multichannel case, <cite>labels</cite> should have
the same shape as a single channel of <cite>data</cite>, i.e. without the final
dimension denoting channels.</p>
</div></blockquote>
<p><strong>beta</strong> : float</p>
<blockquote>
<div><p>Penalization coefficient for the random walker motion
(the greater <cite>beta</cite>, the more difficult the diffusion).</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;bf&#8217;, &#8216;cg_mg&#8217;, &#8216;cg&#8217;} (default: &#8216;bf&#8217;)</p>
<blockquote>
<div><p>Mode for solving the linear system in the random walker
algorithm.</p>
<ul class="simple">
<li>&#8216;bf&#8217; (brute force, default): an LU factorization of the Laplacian is
computed. This is fast for small images (&lt;1024x1024), but very slow
(due to the memory cost) and memory-consuming for big images (in 3-D
for example).</li>
<li>&#8216;cg&#8217; (conjugate gradient): the linear system is solved iteratively
using the Conjugate Gradient method from scipy.sparse.linalg. This is
less memory-consuming than the brute force method for large images,
but it is quite slow.</li>
<li>&#8216;cg_mg&#8217; (conjugate gradient with multigrid preconditioner): a
preconditioner is computed using a multigrid solver, then the
solution is computed with the Conjugate Gradient method.  This mode
requires that the pyamg module (<a class="reference external" href="http://pyamg.org/">http://pyamg.org/</a>) is
installed. For images of size &gt; 512x512, this is the recommended
(fastest) mode.</li>
</ul>
</div></blockquote>
<p><strong>tol</strong> : float</p>
<blockquote>
<div><p>tolerance to achieve when solving the linear system, in
cg&#8217; and &#8216;cg_mg&#8217; modes.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>If copy is False, the <cite>labels</cite> array will be overwritten with
the result of the segmentation. Use copy=False if you want to
save on memory.</p>
</div></blockquote>
<p><strong>multichannel</strong> : bool, default False</p>
<blockquote>
<div><p>If True, input data is parsed as multichannel data (see &#8216;data&#8217; above
for proper input format in this case)</p>
</div></blockquote>
<p><strong>return_full_prob</strong> : bool, default False</p>
<blockquote>
<div><p>If True, the probability that a pixel belongs to each of the labels
will be returned, instead of only the most likely label.</p>
</div></blockquote>
<p><strong>depth</strong> : float, default 1. [DEPRECATED]</p>
<blockquote>
<div><p>Correction for non-isotropic voxel depths in 3D volumes.
Default (1.) implies isotropy.  This factor is derived as follows:
depth = (out-of-plane voxel spacing) / (in-plane voxel spacing), where
in-plane voxel spacing represents the first two spatial dimensions and
out-of-plane voxel spacing represents the third spatial dimension.
<cite>depth</cite> is deprecated as of 0.9, in favor of <cite>spacing</cite>.</p>
</div></blockquote>
<p><strong>spacing</strong> : iterable of floats</p>
<blockquote>
<div><p>Spacing between voxels in each spatial dimension. If <cite>None</cite>, then
the spacing between pixels/voxels in each dimension is assumed 1.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>output</strong> : ndarray</p>
<blockquote class="last">
<div><ul class="simple">
<li>If <cite>return_full_prob</cite> is False, array of ints of same shape as
<cite>data</cite>, in which each pixel has been labeled according to the marker
that reached the pixel first by anisotropic diffusion.</li>
<li>If <cite>return_full_prob</cite> is True, array of floats of shape
<cite>(nlabels, data.shape)</cite>. <cite>output[label_nb, i, j]</cite> is the probability
that label <cite>label_nb</cite> reaches the pixel <cite>(i, j)</cite> first.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="skimage.morphology.html#skimage.morphology.watershed" title="skimage.morphology.watershed"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.watershed</span></tt></a></dt>
<dd>watershed segmentation A segmentation algorithm based on mathematical morphology and &#8220;flooding&#8221; of regions from markers.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Multichannel inputs are scaled with all channel data combined. Ensure all
channels are separately normalized prior to running this algorithm.</p>
<p>The <cite>spacing</cite> argument is specifically for anisotropic datasets, where
data points are spaced differently in one or more spatial dimensions.
Anisotropic data is commonly encountered in medical imaging.</p>
<p>The algorithm was first proposed in <em>Random walks for image
segmentation</em>, Leo Grady, IEEE Trans Pattern Anal Mach Intell.
2006 Nov;28(11):1768-83.</p>
<p>The algorithm solves the diffusion equation at infinite times for
sources placed on markers of each phase in turn. A pixel is labeled with
the phase that has the greatest probability to diffuse first to the pixel.</p>
<p>The diffusion equation is solved by minimizing x.T L x for each phase,
where L is the Laplacian of the weighted graph of the image, and x is
the probability that a marker of the given phase arrives first at a pixel
by diffusion (x=1 on markers of the phase, x=0 on the other markers, and
the other coefficients are looked for). Each pixel is attributed the label
for which it has a maximal value of x. The Laplacian L of the image
is defined as:</p>
<blockquote>
<div><ul class="simple">
<li>L_ii = d_i, the number of neighbors of pixel i (the degree of i)</li>
<li>L_ij = -w_ij if i and j are adjacent pixels</li>
</ul>
</div></blockquote>
<p>The weight w_ij is a decreasing function of the norm of the local gradient.
This ensures that diffusion is easier between pixels of similar values.</p>
<p>When the Laplacian is decomposed into blocks of marked and unmarked
pixels:</p>
<div class="highlight-python"><pre>L = M B.T
    B A</pre>
</div>
<p>with first indices corresponding to marked pixels, and then to unmarked
pixels, minimizing x.T L x for one phase amount to solving:</p>
<div class="highlight-python"><pre>A x = - B x_m</pre>
</div>
<p>where x_m = 1 on markers of the given phase, and 0 on other markers.
This linear system is solved in the algorithm using a direct method for
small images, and an iterative method for larger images.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c">#Marker for first phase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="c">#Marker for second phase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_walker</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], dtype=int32)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="relabel-from-one">
<h2>relabel_from_one<a class="headerlink" href="#relabel-from-one" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.relabel_from_one">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">relabel_from_one</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#skimage.segmentation.relabel_from_one" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">relabel_sequential</span></tt> instead.</p>
<p>Convert labels in an arbitrary label field to {1, ... number_of_labels}.</p>
<p>This function is deprecated, see <tt class="docutils literal"><span class="pre">relabel_sequential</span></tt> for more.</p>
</dd></dl>

</div>
<div class="section" id="relabel-sequential">
<h2>relabel_sequential<a class="headerlink" href="#relabel-sequential" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.relabel_sequential">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">relabel_sequential</tt><big>(</big><em>label_field</em>, <em>offset=1</em><big>)</big><a class="headerlink" href="#skimage.segmentation.relabel_sequential" title="Permalink to this definition">¶</a></dt>
<dd><p>Relabel arbitrary labels to {<cite>offset</cite>, ... <cite>offset</cite> + number_of_labels}.</p>
<p>This function also returns the forward map (mapping the original labels to
the reduced labels) and the inverse map (mapping the reduced labels back
to the original ones).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>label_field</strong> : numpy array of int, arbitrary shape</p>
<blockquote>
<div><p>An array of labels.</p>
</div></blockquote>
<p><strong>offset</strong> : int, optional</p>
<blockquote>
<div><p>The return labels will start at <cite>offset</cite>, which should be
strictly positive.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>relabeled</strong> : numpy array of int, same shape as <cite>label_field</cite></p>
<blockquote>
<div><p>The input label field with labels mapped to
{1, ..., number_of_labels}.</p>
</div></blockquote>
<p><strong>forward_map</strong> : numpy array of int, shape <tt class="docutils literal"><span class="pre">(label_field.max()</span> <span class="pre">+</span> <span class="pre">1,)</span></tt></p>
<blockquote>
<div><p>The map from the original label space to the returned label
space. Can be used to re-apply the same mapping. See examples
for usage.</p>
</div></blockquote>
<p><strong>inverse_map</strong> : 1D numpy array of int, of length offset + number of labels</p>
<blockquote class="last">
<div><p>The map from the new label space to the original space. This
can be used to reconstruct the original label field from the
relabeled one.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The label 0 is assumed to denote the background and is never remapped.</p>
<p>The forward map can be extremely big for some inputs, since its
length is given by the maximum of the label field. However, in most
situations, <tt class="docutils literal"><span class="pre">label_field.max()</span></tt> is much smaller than
<tt class="docutils literal"><span class="pre">label_field.size</span></tt>, and in these cases the forward map is
guaranteed to be smaller than either the input or output images.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.segmentation</span> <span class="kn">import</span> <span class="n">relabel_sequential</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">42</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relab</span><span class="p">,</span> <span class="n">fw</span><span class="p">,</span> <span class="n">inv</span> <span class="o">=</span> <span class="n">relabel_sequential</span><span class="p">(</span><span class="n">label_field</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relab</span>
<span class="go">array([1, 1, 2, 2, 3, 5, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fw</span>
<span class="go">array([0, 1, 0, 0, 0, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
<span class="go">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,</span>
<span class="go">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
<span class="go">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
<span class="go">       0, 0, 0, 0, 0, 0, 0, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inv</span>
<span class="go">array([ 0,  1,  5,  8, 42, 99])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">fw</span><span class="p">[</span><span class="n">label_field</span><span class="p">]</span> <span class="o">==</span> <span class="n">relab</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">inv</span><span class="p">[</span><span class="n">relab</span><span class="p">]</span> <span class="o">==</span> <span class="n">label_field</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relab</span><span class="p">,</span> <span class="n">fw</span><span class="p">,</span> <span class="n">inv</span> <span class="o">=</span> <span class="n">relabel_sequential</span><span class="p">(</span><span class="n">label_field</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relab</span>
<span class="go">array([5, 5, 6, 6, 7, 9, 8])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="slic">
<h2>slic<a class="headerlink" href="#slic" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.slic">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">slic</tt><big>(</big><em>image</em>, <em>n_segments=100</em>, <em>compactness=10.0</em>, <em>max_iter=10</em>, <em>sigma=None</em>, <em>spacing=None</em>, <em>multichannel=True</em>, <em>convert2lab=True</em>, <em>ratio=None</em><big>)</big><a class="headerlink" href="#skimage.segmentation.slic" title="Permalink to this definition">¶</a></dt>
<dd><p>Segments image using k-means clustering in Color-(x,y,z) space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : 2D, 3D or 4D ndarray</p>
<blockquote>
<div><p>Input image, which can be 2D or 3D, and grayscale or multichannel
(see <cite>multichannel</cite> parameter).</p>
</div></blockquote>
<p><strong>n_segments</strong> : int, optional</p>
<blockquote>
<div><p>The (approximate) number of labels in the segmented output image.</p>
</div></blockquote>
<p><strong>compactness</strong> : float, optional</p>
<blockquote>
<div><p>Balances color-space proximity and image-space proximity. Higher
values give more weight to image-space. As <cite>compactness</cite> tends to
infinity, superpixel shapes become square/cubic.</p>
</div></blockquote>
<p><strong>max_iter</strong> : int, optional</p>
<blockquote>
<div><p>Maximum number of iterations of k-means.</p>
</div></blockquote>
<p><strong>sigma</strong> : float or (3,) array-like of floats, optional</p>
<blockquote>
<div><p>Width of Gaussian smoothing kernel for pre-processing for each
dimension of the image. The same sigma is applied to each dimension in
case of a scalar value. Zero means no smoothing.
Note, that <cite>sigma</cite> is automatically scaled if it is scalar and a
manual voxel spacing is provided (see Notes section).</p>
</div></blockquote>
<p><strong>spacing</strong> : (3,) array-like of floats, optional</p>
<blockquote>
<div><p>The voxel spacing along each image dimension. By default, <cite>slic</cite>
assumes uniform spacing (same voxel resolution along z, y and x).
This parameter controls the weights of the distances along z, y,
and x during k-means clustering.</p>
</div></blockquote>
<p><strong>multichannel</strong> : bool, optional</p>
<blockquote>
<div><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension.</p>
</div></blockquote>
<p><strong>convert2lab</strong> : bool, optional</p>
<blockquote>
<div><p>Whether the input should be converted to Lab colorspace prior to
segmentation. For this purpose, the input is assumed to be RGB. Highly
recommended.</p>
</div></blockquote>
<p><strong>ratio</strong> : float, optional</p>
<blockquote>
<div><p>Synonym for <cite>compactness</cite>. This keyword is deprecated.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>labels</strong> : 2D or 3D array</p>
<blockquote>
<div><p>Integer mask indicating segment labels.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first"><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>If:</dt>
<dd><ul class="first last simple">
<li>the image dimension is not 2 or 3 and <cite>multichannel == False</cite>, OR</li>
<li>the image dimension is not 3 or 4 and <cite>multichannel == True</cite></li>
</ul>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ul class="simple">
<li>If <cite>sigma &gt; 0</cite>, the image is smoothed using a Gaussian kernel prior to
segmentation.</li>
<li>If <cite>sigma</cite> is scalar and <cite>spacing</cite> is provided, the kernel width is
divided along each dimension by the spacing. For example, if <tt class="docutils literal"><span class="pre">sigma=1</span></tt>
and <tt class="docutils literal"><span class="pre">spacing=[5,</span> <span class="pre">1,</span> <span class="pre">1]</span></tt>, the effective <cite>sigma</cite> is <tt class="docutils literal"><span class="pre">[0.2,</span> <span class="pre">1,</span> <span class="pre">1]</span></tt>. This
ensures sensible smoothing for anisotropic images.</li>
<li>The image is rescaled to be in [0, 1] prior to processing.</li>
<li>Images of shape (M, N, 3) are interpreted as 2D RGB images by default. To
interpret them as 3D with the last dimension having length 3, use
<cite>multichannel=False</cite>.</li>
</ul>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r222" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[R222]</a></td><td>Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi,
Pascal Fua, and Sabine Süsstrunk, SLIC Superpixels Compared to
State-of-the-art Superpixel Methods, TPAMI, May 2012.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.segmentation</span> <span class="kn">import</span> <span class="n">slic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">lena</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">lena</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segments</span> <span class="o">=</span> <span class="n">slic</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">n_segments</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">compactness</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Increasing the compactness parameter yields more square regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segments</span> <span class="o">=</span> <span class="n">slic</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">n_segments</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">compactness</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="visualize-boundaries">
<h2>visualize_boundaries<a class="headerlink" href="#visualize-boundaries" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.visualize_boundaries">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">visualize_boundaries</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#skimage.segmentation.visualize_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">mark_boundaries</span></tt> instead.</p>
</dd></dl>

</div>
</div>


        </div>
        <div class="span3"><h4 class="sidebar-box-heading">Navigation</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <li><a href="../index.html">Documentation Home</a></li>
    </ul>
</div>
        <h4 class="sidebar-box-heading">Contents</h4>
        <div class="well sidebar-box toc">
            <ul class="nav nav-list">
<li><a class="reference internal" href="#">Module: <tt class="docutils literal"><span class="pre">segmentation</span></tt></a><ul class="nav nav-list">
<li><a class="reference internal" href="#clear-border">clear_border</a></li>
<li><a class="reference internal" href="#felzenszwalb">felzenszwalb</a></li>
<li><a class="reference internal" href="#find-boundaries">find_boundaries</a></li>
<li><a class="reference internal" href="#join-segmentations">join_segmentations</a></li>
<li><a class="reference internal" href="#mark-boundaries">mark_boundaries</a></li>
<li><a class="reference internal" href="#quickshift">quickshift</a></li>
<li><a class="reference internal" href="#random-walker">random_walker</a></li>
<li><a class="reference internal" href="#relabel-from-one">relabel_from_one</a></li>
<li><a class="reference internal" href="#relabel-sequential">relabel_sequential</a></li>
<li><a class="reference internal" href="#slic">slic</a></li>
<li><a class="reference internal" href="#visualize-boundaries">visualize_boundaries</a></li>
</ul>
</li>
</ul>

        </div>

<h4 class="sidebar-box-heading">Versions</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <script src="../_static/docversions.js"></script>
        <script type="text/javascript">
            insert_version_links();
        </script>
    </ul>
</div>
        </div>
    </div>
    <div class="well footer">
        <small>
            &copy; Copyright the scikit-image development team.
            Created using <a href="http://twitter.github.com/bootstrap/">Bootstrap</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.
        </small>
    </div>
</body>
</html>